DialogProc<>DialogProc<>INT_PTR CALLBACK\r\nDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
DialogProcDx<>DialogProcDx<>virtual INT_PTR CALLBACK\r\nDialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
WM_ACTIVATE<>OnActivate<>void OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
WM_ACTIVATEAPP<>OnActivateApp<>void OnActivateApp(HWND hwnd, BOOL fActivate, DWORD dwThreadId)
WM_ASKCBFORMATNAME<>OnAskCBFormatName<>void OnAskCBFormatName(HWND hwnd, int cchMax, LPTSTR rgchName)
WM_CANCELMODE<>OnCancelMode<>void OnCancelMode(HWND hwnd)
WM_CHANGECBCHAIN<>OnChangeCBChain<>void OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext)
WM_CHAR<>OnChar<>void OnChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_CHARTOITEM<>OnCharToItem<>int OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret)
WM_CHILDACTIVATE<>OnChildActivate<>void OnChildActivate(HWND hwnd)
WM_CLEAR<>OnClear<>void OnClear(HWND hwnd)
WM_CLOSE<>OnClose<>void OnClose(HWND hwnd)
WM_COMMAND<>OnCommand<>void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
WM_COMMNOTIFY<>OnCommNotify<>void OnCommNotify(HWND hwnd, int cid, UINT flags)
WM_COMPACTING<>OnCompacting<>void OnCompacting(HWND hwnd, UINT compactRatio)
WM_COMPAREITEM<>OnCompareItem<>int OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT * lpCompareItem)
WM_CONTEXTMENU<>OnContextMenu<>void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
WM_COPY<>OnCopy<>void OnCopy(HWND hwnd)
WM_COPYDATA<>OnCopyData<>BOOL OnCopyData(HWND hwnd, HWND hwndFrom, PCOPYDATASTRUCT pcds);
WM_CREATE<>OnCreate<>BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
WM_CTLCOLORBTN<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORDLG<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLOREDIT<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORLISTBOX<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORMSGBOX<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORSCROLLBAR<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORSTATIC<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CUT<>OnCut<>void OnCut(HWND hwnd)
WM_DEADCHAR<>OnDeadChar<>void OnDeadChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_DELETEITEM<>OnDeleteItem<>void OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem)
WM_DESTROY<>OnDestroy<>void OnDestroy(HWND hwnd)
WM_DESTROYCLIPBOARD<>OnDestroyClipboard<>void OnDestroyClipboard(HWND hwnd)
WM_DEVICECHANGE<>OnDeviceChange<>BOOL OnDeviceChange(HWND hwnd, UINT uEvent, DWORD dwEventData)
WM_DEVMODECHANGE<>OnDevModeChange<>void OnDevModeChange(HWND hwnd, LPCTSTR lpszDeviceName)
WM_DISPLAYCHANGE<>OnDisplayChange<>void OnDisplayChange(HWND hwnd, UINT bitsPerPixel, UINT cxScreen, UINT cyScreen)
WM_DRAWCLIPBOARD<>OnDrawClipboard<>void OnDrawClipboard(HWND hwnd)
WM_DRAWITEM<>OnDrawItem<>void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
WM_DROPFILES<>OnDropFiles<>void OnDropFiles(HWND hwnd, HDROP hdrop)
WM_ENABLE<>OnEnable<>void OnEnable(HWND hwnd, BOOL fEnable)
WM_ENDSESSION<>OnEndSession<>void OnEndSession(HWND hwnd, BOOL fEnding)
WM_ENTERIDLE<>OnEnterIdle<>void OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource)
WM_ERASEBKGND<>OnEraseBkgnd<>BOOL OnEraseBkgnd(HWND hwnd, HDC hdc)
WM_FONTCHANGE<>OnFontChange<>void OnFontChange(HWND hwnd)
WM_GETDLGCODE<>OnGetDlgCode<>UINT OnGetDlgCode(HWND hwnd, LPMSG lpmsg)
WM_GETFONT<>OnGetFont<>HFONT OnGetFont(HWND hwnd)
WM_GETMINMAXINFO<>OnGetMinMaxInfo<>void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpMinMaxInfo)
WM_GETTEXT<>OnGetText<>INT OnGetText(HWND hwnd, int cchTextMax, LPTSTR lpszText)
WM_GETTEXTLENGTH<>OnGetTextLength<>INT OnGetTextLength(HWND hwnd)
WM_HOTKEY<>OnHotKey<>void OnHotKey(HWND hwnd, int idHotKey, UINT fuModifiers, UINT vk)
WM_HSCROLL<>OnHScroll<>void OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
WM_HSCROLLCLIPBOARD<>OnHScrollClipboard<>void OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos)
WM_ICONERASEBKGND<>OnIconEraseBkgnd<>BOOL OnIconEraseBkgnd(HWND hwnd, HDC hdc)
WM_INITDIALOG<>OnInitDialog<>BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
WM_INITMENU<>OnInitMenu<>void OnInitMenu(HWND hwnd, HMENU hMenu)
WM_INITMENUPOPUP<>OnInitMenuPopup<>void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
WM_KEYDOWN<>OnKey<>void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_KEYUP<>OnKey<>void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_KILLFOCUS<>OnKillFocus<>void OnKillFocus(HWND hwnd, HWND hwndNewFocus)
WM_LBUTTONDBLCLK<>OnLButtonDown<>void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_LBUTTONDOWN<>OnLButtonDown<>void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_LBUTTONUP<>OnLButtonUp<>void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
WM_MBUTTONDBLCLK<>OnMButtonDown<>void OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_MBUTTONDOWN<>OnMButtonDown<>void OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_MBUTTONUP<>OnMButtonUp<>void OnMButtonUp(HWND hwnd, int x, int y, UINT flags)
WM_MDIACTIVATE<>MDIActivate<>void MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate)
WM_MDICASCADE<>MDICascade<>BOOL MDICascade(HWND hwnd, UINT cmd)
WM_MDICREATE<>MDICreate<>HWND MDICreate(HWND hwnd, const LPMDICREATESTRUCT lpmcs)
WM_MDIDESTROY<>MDIDestroy<>void MDIDestroy(HWND hwnd, HWND hwndDestroy)
WM_MDIGETACTIVE<>MDIGetActive<>HWND MDIGetActive(HWND hwnd)
WM_MDIICONARRANGE<>MDIIconArrange<>void MDIIconArrange(HWND hwnd)
WM_MDIMAXIMIZE<>MDIMaximize<>void MDIMaximize(HWND hwnd, HWND hwndMaximize)
WM_MDINEXT<>MDINext<>HWND MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev)
WM_MDIRESTORE<>MDIRestore<>void MDIRestore(HWND hwnd, HWND hwndRestore)
WM_MDISETMENU<>MDISetMenu<>HMENU MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow)
WM_MDITILE<>MDITile<>BOOL MDITile(HWND hwnd, UINT cmd)
WM_MEASUREITEM<>OnMeasureItem<>void OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem)
WM_MENUCHAR<>OnMenuChar<>DWORD OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu)
WM_MENUSELECT<>OnMenuSelect<>void OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
WM_MOUSEACTIVATE<>OnMouseActivate<>int OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
WM_MOUSEMOVE<>OnMouseMove<>void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
WM_MOUSEWHEEL<>OnMouseWheel<>void OnMouseWheel(HWND hwnd, int xPos, int yPos, int zDelta, UINT fwKeys)
WM_MOVE<>OnMove<>void OnMove(HWND hwnd, int x, int y)
WM_NCACTIVATE<>OnNCActivate<>BOOL OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized)
WM_NCCALCSIZE<>OnNCCalcSize<>UINT OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS * lpcsp)
WM_NCCREATE<>OnNCCreate<>BOOL OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
WM_NCDESTROY<>OnNCDestroy<>void OnNCDestroy(HWND hwnd)
WM_NCHITTEST<>OnNCHitTest<>UINT OnNCHitTest(HWND hwnd, int x, int y)
WM_NCLBUTTONDBLCLK<>OnNCLButtonDown<>void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCLBUTTONDOWN<>OnNCLButtonDown<>void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCLBUTTONUP<>OnNCLButtonUp<>void OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCMBUTTONDBLCLK<>OnNCMButtonDown<>void OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCMBUTTONDOWN<>OnNCMButtonDown<>void OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCMBUTTONUP<>OnNCMButtonUp<>void OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCMOUSEMOVE<>OnNCMouseMove<>void OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCPAINT<>OnNCPaint<>void OnNCPaint(HWND hwnd, HRGN hrgn)
WM_NCRBUTTONDBLCLK<>OnNCRButtonDown<>void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCRBUTTONDOWN<>OnNCRButtonDown<>void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCRBUTTONUP<>OnNCRButtonUp<>void OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NEXTDLGCTL<>OnNextDlgCtl<>HWND OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext)
WM_NOTIFY<>OnNotify<>LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
WM_PAINT<>OnPaint<>void OnPaint(HWND hwnd)
WM_PAINTCLIPBOARD<>OnPaintClipboard<>void OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const LPPAINTSTRUCT lpPaintStruct)
WM_PALETTECHANGED<>OnPaletteChanged<>void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
WM_PALETTEISCHANGING<>OnPaletteIsChanging<>void OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange)
WM_PARENTNOTIFY<>OnParentNotify<>void OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild)
WM_PASTE<>OnPaste<>void OnPaste(HWND hwnd)
WM_POWER<>OnPower<>void OnPower(HWND hwnd, int code)
WM_QUERYDRAGICON<>OnQueryDragIcon<>HICON OnQueryDragIcon(HWND hwnd)
WM_QUERYENDSESSION<>OnQueryEndSession<>BOOL OnQueryEndSession(HWND hwnd)
WM_QUERYNEWPALETTE<>OnQueryNewPalette<>BOOL OnQueryNewPalette(HWND hwnd)
WM_QUERYOPEN<>OnQueryOpen<>BOOL OnQueryOpen(HWND hwnd)
WM_QUEUESYNC<>OnQueueSync<>void OnQueueSync(HWND hwnd)
WM_QUIT<>OnQuit<>void OnQuit(HWND hwnd, int exitCode)
WM_RBUTTONDBLCLK<>OnRButtonDown<>void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_RBUTTONDOWN<>OnRButtonDown<>void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_RBUTTONUP<>OnRButtonUp<>void OnRButtonUp(HWND hwnd, int x, int y, UINT flags)
WM_RENDERALLFORMATS<>OnRenderAllFormats<>void OnRenderAllFormats(HWND hwnd)
WM_RENDERFORMAT<>OnRenderFormat<>HANDLE OnRenderFormat(HWND hwnd, UINT fmt)
WM_SETCURSOR<>OnSetCursor<>BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
WM_SETFOCUS<>OnSetFocus<>void OnSetFocus(HWND hwnd, HWND hwndOldFocus)
WM_SETFONT<>OnSetFont<>void OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw)
WM_SETREDRAW<>OnSetRedraw<>void OnSetRedraw(HWND hwnd, BOOL fRedraw)
WM_SETTEXT<>OnSetText<>void OnSetText(HWND hwnd, LPCTSTR lpszText)
WM_SHOWWINDOW<>OnShowWindow<>void OnShowWindow(HWND hwnd, BOOL fShow, UINT status)
WM_SIZE<>OnSize<>void OnSize(HWND hwnd, UINT state, int cx, int cy)
WM_SIZECLIPBOARD<>OnSizeClipboard<>void OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const LPRECT lprc)
WM_SPOOLERSTATUS<>OnSpoolerStatus<>void OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue)
WM_SYSCHAR<>OnSysChar<>void OnSysChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_SYSCOLORCHANGE<>OnSysColorChange<>void OnSysColorChange(HWND hwnd)
WM_SYSCOMMAND<>OnSysCommand<>void OnSysCommand(HWND hwnd, UINT cmd, int x, int y)
WM_SYSDEADCHAR<>OnSysDeadChar<>void OnSysDeadChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_SYSKEYDOWN<>OnSysKey<>void OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_SYSKEYUP<>OnSysKey<>void OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_SYSTEMERROR<>OnSystemError<>void OnSystemError(HWND hwnd, int errCode)
WM_TIMECHANGE<>OnTimeChange<>void OnTimeChange(HWND hwnd)
WM_TIMER<>OnTimer<>void OnTimer(HWND hwnd, UINT id)
WM_UNDO<>OnUndo<>void OnUndo(HWND hwnd)
WM_VKEYTOITEM<>OnVkeyToItem<>int OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret)
WM_VSCROLL<>OnVScroll<>void OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
WM_VSCROLLCLIPBOARD<>OnVScrollClipboard<>void OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos)
WM_WINDOWPOSCHANGED<>OnWindowPosChanged<>void OnWindowPosChanged(HWND hwnd, const LPWINDOWPOS lpwpos)
WM_WINDOWPOSCHANGING<>OnWindowPosChanging<>BOOL OnWindowPosChanging(HWND hwnd, LPWINDOWPOS lpwpos)
WM_WININICHANGE<>OnWinIniChange<>void OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
WinMain<>WinMain<>INT WINAPI\r\nWinMain(HINSTANCE   hInstance,\r\n        HINSTANCE   hPrevInstance,\r\n        LPSTR       lpCmdLine,\r\n        INT         nCmdShow)
WindowProc<>WindowProc<>LRESULT CALLBACK\r\nWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
WindowProcDx<>WindowProcDx<>virtual LRESULT CALLBACK\r\nWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
_tWinMain<>_tWinMain<>extern "C" INT WINAPI\r\n_tWinMain(HINSTANCE   hInstance,\r\n          HINSTANCE   hPrevInstance,\r\n          LPTSTR      lpCmdLine,\r\n          INT         nCmdShow)
wWinMain<>wWinMain<>extern "C" INT WINAPI\r\nwWinMain(HINSTANCE   hInstance,\r\n         HINSTANCE   hPrevInstance,\r\n         LPWSTR      lpCmdLine,\r\n         INT         nCmdShow)
OnMessage<>OnMessage<>LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam)
OnMessageEx<>OnMessageEx<>LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
MWindowClass<>MWindowClass<>class MWindowClass : public MWindowBase\r\n{\r\npublic:\r\n    MWindowClass()\r\n    {\r\n    }\r\n\r\n    virtual ~MWindowClass()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MWindowClass Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n};
MDialogClass<>MDialogClass<>class MDialogClass : public MDialogBase\r\n{\r\npublic:\r\n    MDialogClass()\r\n    {\r\n    }\r\n\r\n    virtual ~MDialogClass()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n};\r\n
CMakeLists.txt<>CMakeLists.txt<># CMakeLists.txt --- CMake project settings\r\n#    ex) cmake -G "Visual Studio 9 2008"\r\n#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles"\r\n##############################################################################\r\n\r\n# CMake minimum version\r\ncmake_minimum_required(VERSION 2.4)\r\n\r\n# project name and language\r\nproject(MyProject CXX)\r\n\r\n# check build type\r\nif (NOT CMAKE_BUILD_TYPE)\r\n    message(STATUS "No build type selected, default to Debug")\r\n    set(CMAKE_BUILD_TYPE "Debug")\r\nendif()\r\n\r\n# make uppercase string of build type\r\nstring(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)\r\n\r\n# check build type again\r\nif (NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")\r\n    message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")\r\nendif()\r\n\r\n# set output directory (build/)\r\nset(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)\r\nset(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})\r\nset(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})\r\n\r\n# enable Win32 resource\r\nenable_language(RC)\r\n\r\nif (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")\r\n    # using Clang\r\n    set(CMAKE_C_FLAGS "-static")\r\n    set(CMAKE_CXX_FLAGS "-static")\r\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")\r\n    # using GCC\r\n    set(CMAKE_C_FLAGS "-static -static-libgcc -static-libstdc++")\r\n    set(CMAKE_CXX_FLAGS "-static -static-libgcc -static-libstdc++")\r\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")\r\n    # replace "/MD" with "/MT" (building without runtime DLLs)\r\n    set(CompilerFlags\r\n        CMAKE_C_FLAGS\r\n        CMAKE_C_FLAGS_DEBUG\r\n        CMAKE_C_FLAGS_RELEASE\r\n        CMAKE_C_FLAGS_RELWITHDEBINFO\r\n        CMAKE_CXX_FLAGS\r\n        CMAKE_CXX_FLAGS_DEBUG\r\n        CMAKE_CXX_FLAGS_RELEASE\r\n        CMAKE_CXX_FLAGS_RELWITHDEBINFO)\r\n    foreach(CompilerFlags ${CompilerFlags})\r\n        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")\r\n    endforeach()\r\nendif()\r\n\r\n##############################################################################\r\n\r\n# executable\r\nadd_executable(MyProject WIN32 MyProject.cpp MyProject_res.rc)\r\n\r\n# link\r\ntarget_link_libraries(MyProject comctl32)\r\n\r\n##############################################################################\r\n
MMainWnd<>MMainWnd<>class MMainWnd : public MWindowBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n    HACCEL      m_hAccel;       // the access keys\r\n\r\n    MMainWnd(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL), m_hAccel(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainWnd()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MMainWnd Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n        wcx.lpszMenuName = MAKEINTRESOURCE(1);\r\n        wcx.hIcon = m_hIcon;\r\n        wcx.hIconSm = m_hIconSm;\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnDestroy(HWND hwnd)\r\n    {\r\n        ::PostQuitMessage(0);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n        m_hAccel = ::LoadAccelerators(m_hInst, MAKEINTRESOURCE(1));\r\n\r\n        if (!CreateWindowDx(NULL, LoadStringDx(1)))\r\n        {\r\n            MsgBoxDx(TEXT("failure of CreateWindow"), NULL, MB_ICONERROR);\r\n            return FALSE;\r\n        }\r\n\r\n        ::ShowWindow(*this, nCmdShow);\r\n        ::UpdateWindow(*this);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        // message loop\r\n        MSG msg;\r\n        while (::GetMessage(&msg, NULL, 0, 0))\r\n        {\r\n            if (!::TranslateAccelerator(m_hwnd, m_hAccel, &msg))\r\n            {\r\n                ::TranslateMessage(&msg);\r\n                ::DispatchMessage(&msg);\r\n            }\r\n        }\r\n        return INT(msg.wParam);\r\n    }\r\n};\r\n
MMainDlg<>MMainDlg<>class MMainDlg : public MDialogBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n\r\n    MMainDlg(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : MDialogBase(1), m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainDlg()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        return INT(DialogBoxDx(NULL));\r\n    }\r\n};\r\n
targetver.h<>targetver.h<>// targetver.h --- target versioning header for Win             -*- C++ -*-\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n// targetver.h is used to define the Win32API macros that target the \r\n// version of the Win you wish to support.\r\n\r\n// For Win95\r\n//#define WINVER          0x0400\r\n//#define _WIN32_WINDOWS  0x0400\r\n//#define _WIN32_WINNT    0x0400\r\n//#define _WIN32_IE       0x0300\r\n\r\n// For Win98\r\n//#define WINVER          0x0410\r\n//#define _WIN32_WINDOWS  0x0410\r\n//#define _WIN32_WINNT    0x0410\r\n//#define _WIN32_IE       0x0401\r\n\r\n// For WinNT4\r\n//#define WINVER          0x0400\r\n//#define _WIN32_WINNT    0x0400\r\n//#define _WIN32_IE       0x0200\r\n//#define NTDDI_VERSION   0x05000000\r\n\r\n// For WinME\r\n//#define WINVER          0x0500\r\n//#define _WIN32_WINNT    0x0500\r\n//#define _WIN32_IE       0x0500\r\n\r\n// For Win2000\r\n//#define WINVER          0x0500\r\n//#define _WIN32_WINNT    0x0500\r\n//#define _WIN32_IE       0x0500\r\n//#define NTDDI_VERSION   0x05000000\r\n\r\n// For WinXP\r\n#define WINVER          0x0501\r\n#define _WIN32_WINNT    0x0501\r\n#define _WIN32_IE       0x0501\r\n#define NTDDI_VERSION   0x05010000\r\n\r\n// For WinVista\r\n//#define WINVER          0x0600\r\n//#define _WIN32_WINNT    0x0600\r\n//#define _WIN32_IE       0x0600\r\n//#define NTDDI_VERSION   0x06000000\r\n\r\n// For Win7\r\n//#define WINVER          0x0601\r\n//#define _WIN32_WINNT    0x0601\r\n//#define _WIN32_IE       0x0601\r\n//#define NTDDI_VERSION   0x06010000\r\n\r\n// For Win8.1\r\n//#define WINVER          0x0602\r\n//#define _WIN32_WINNT    0x0602\r\n//#define _WIN32_IE       0x0602\r\n//#define NTDDI_VERSION   0x06030000\r\n\r\n// For Win10\r\n//#define WINVER          0x0A00\r\n//#define _WIN32_WINNT    0x0A00\r\n//#define _WIN32_IE       0x0A00\r\n//#define NTDDI_VERSION   0x0A000000\r\n\r\n// Users of Visual Studio 10+ can do this instead\r\n// #include "SDKDDKver.h"\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
.gitignore<>.gitignore<>*.autosave\r\n*.cmake\r\n*.dir\r\n*.exe\r\n*.filters\r\n*.idb\r\n*.map\r\n*.ncb\r\n*.o\r\n*.obj\r\n*.opensdf\r\n*.res\r\n*.sdf\r\n*.sln\r\n*.suo\r\n*.tds\r\n*.user\r\n*.vcproj\r\n*.vcxproj\r\n*~\r\n.vs\r\nCMakeCache.txt\r\nCMakeFiles\r\nDebug\r\nMakefile\r\nRelease\r\nTMP1.$$$\r\nbuild\r\nipch\r\nx64\r\n
MyProject.cpp (Window)<>MyProject.cpp (Window)<>// MyProject.cpp\r\n\r\n#include "targetver.h"\r\n#include "MWindowBase.hpp"\r\n\r\nclass MMainWnd : public MWindowBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n    HACCEL      m_hAccel;       // the access keys\r\n\r\n    MMainWnd(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL), m_hAccel(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainWnd()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MMainWnd Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n        wcx.lpszMenuName = MAKEINTRESOURCE(1);\r\n        wcx.hIcon = m_hIcon;\r\n        wcx.hIconSm = m_hIconSm;\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        if (id == 1)\r\n        {\r\n            DestroyWindow(hwnd);\r\n        }\r\n    }\r\n\r\n    void OnDestroy(HWND hwnd)\r\n    {\r\n        ::PostQuitMessage(0);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n        m_hAccel = ::LoadAccelerators(m_hInst, MAKEINTRESOURCE(1));\r\n\r\n        if (!CreateWindowDx(NULL, LoadStringDx(1)))\r\n        {\r\n            MsgBoxDx(TEXT("failure of CreateWindow"), NULL, MB_ICONERROR);\r\n            return FALSE;\r\n        }\r\n\r\n        ::ShowWindow(*this, nCmdShow);\r\n        ::UpdateWindow(*this);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        // message loop\r\n        MSG msg;\r\n        while (::GetMessage(&msg, NULL, 0, 0))\r\n        {\r\n            if (!::TranslateAccelerator(m_hwnd, m_hAccel, &msg))\r\n            {\r\n                ::TranslateMessage(&msg);\r\n                ::DispatchMessage(&msg);\r\n            }\r\n        }\r\n        return INT(msg.wParam);\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Win32 main function\r\n\r\nextern "C"\r\nINT APIENTRY _tWinMain(\r\n    HINSTANCE   hInstance,\r\n    HINSTANCE   hPrevInstance,\r\n    LPTSTR      lpCmdLine,\r\n    INT         nCmdShow)\r\n{\r\n    int ret = -1;\r\n\r\n    {\r\n        MMainWnd app(__argc, __targv, hInstance);\r\n\r\n        ::InitCommonControls();\r\n\r\n        if (app.StartDx(nCmdShow))\r\n        {\r\n            ret = app.RunDx();\r\n        }\r\n    }\r\n\r\n#if (WINVER >= 0x0500)\r\n    HANDLE hProcess = GetCurrentProcess();\r\n    DebugPrintDx(TEXT("Count of GDI objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_GDIOBJECTS));\r\n    DebugPrintDx(TEXT("Count of USER objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_USEROBJECTS));\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG)\r\n    // for detecting memory leak (MSVC only)\r\n    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\r\n#endif\r\n\r\n    return ret;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
MyProject.cpp (Dialog)<>MyProject.cpp (Dialog)<>// MyProject.cpp\r\n\r\n#include "targetver.h"\r\n#include "MWindowBase.hpp"\r\n\r\nclass MMainDlg : public MDialogBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n\r\n    MMainDlg(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : MDialogBase(1), m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainDlg()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        SendMessageDx(WM_SETICON, ICON_BIG, LPARAM(m_hIcon));\r\n        SendMessageDx(WM_SETICON, ICON_SMALL, LPARAM(m_hIconSm));\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        return INT(DialogBoxDx(NULL));\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Win32 main function\r\n\r\nextern "C"\r\nINT APIENTRY _tWinMain(\r\n    HINSTANCE   hInstance,\r\n    HINSTANCE   hPrevInstance,\r\n    LPTSTR      lpCmdLine,\r\n    INT         nCmdShow)\r\n{\r\n    int ret = -1;\r\n\r\n    {\r\n        MMainDlg app(__argc, __targv, hInstance);\r\n\r\n        ::InitCommonControls();\r\n\r\n        if (app.StartDx(nCmdShow))\r\n        {\r\n            ret = app.RunDx();\r\n        }\r\n    }\r\n\r\n#if (WINVER >= 0x0500)\r\n    HANDLE hProcess = GetCurrentProcess();\r\n    DebugPrintDx(TEXT("Count of GDI objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_GDIOBJECTS));\r\n    DebugPrintDx(TEXT("Count of USER objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_USEROBJECTS));\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG)\r\n    // for detecting memory leak (MSVC only)\r\n    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\r\n#endif\r\n\r\n    return ret;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
MyProject_res.rc<>MyProject_res.rc<>#include "targetver.h"\r\n#include <windows.h>\r\n#include "resource.h"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Encoding\r\n\r\n#pragma code_page(65001)    // UTF-8\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Icon\r\n\r\n1 ICON "MainIcon.ico"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Menus\r\n\r\n1 MENU\r\n{\r\n    POPUP "&File"\r\n    {\r\n        MENUITEM "E&xit\\tAlt+F4", 1\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Dialogs\r\n\r\n1 DIALOG 0, 0, 215, 135\r\nCAPTION "Sample Dialog"\r\nSTYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_DLGFRAME\r\nFONT 9, "MS Shell Dlg"\r\n{\r\n    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14\r\n    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Version Info\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\nFILEVERSION     0, 0, 0, 0\r\nPRODUCTVERSION  0, 0, 0, 0\r\nFILEOS          VOS_NT_WINDOWS32\r\nFILETYPE        VFT_APP\r\nBEGIN\r\n    // English (U.S.)\r\n    BLOCK "StringFileInfo"\r\n    BEGIN\r\n        BLOCK "040904E4"\r\n        BEGIN\r\n            VALUE "CompanyName", "Katayama Hirofumi MZ\\0"\r\n            VALUE "FileDescription", "MyProject\\0"\r\n            VALUE "FileVersion", "0.0\\0"\r\n            VALUE "LegalCopyright", "Copyright (C) 2018 Katayama Hirofumi MZ\\0"\r\n            VALUE "ProductName", "MyProject\\0"\r\n            VALUE "ProductVersion", "0.0\\0"\r\n        END\r\n    END\r\n    // Japanese\r\n    BLOCK "StringFileInfo"\r\n    BEGIN\r\n        BLOCK "041103A4"\r\n        BEGIN\r\n            VALUE "CompanyName", "•ÐŽR”Ž•¶MZ\\0"\r\n            VALUE "FileDescription", "MyProject\\0"\r\n            VALUE "FileVersion", "0.0\\0"\r\n            VALUE "LegalCopyright", "Copyright (C) 2018 •ÐŽR”Ž•¶MZ\\0"\r\n            VALUE "ProductName", "MyProject\\0"\r\n            VALUE "ProductVersion", "0.0\\0"\r\n        END\r\n    END\r\n    BLOCK "VarFileInfo"\r\n    BEGIN\r\n        // English (U.S.)\r\n        VALUE "Translation", 0x0409, 0x04E4\r\n    END\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n
MWindowBase.hpp<>MWindowBase.hpp<>// MWindowBase.hpp --- MZC4 window base and dialog base         -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MWINDOWBASE_HPP_\r\n#define MZC4_MWINDOWBASE_HPP_    63     /* Version 63 */\r\n\r\nclass MWindowBase;\r\nclass MDialogBase;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#if _MSC_VER > 1000\r\n    #pragma once        // For speed!\r\n#endif\r\n\r\n#ifndef STRICT\r\n    #define STRICT  1   // We must do strictly! Good bye to old style!\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG) && !defined(_CRTDBG_MAP_ALLOC)\r\n    // for detecting memory leak (MSVC only)\r\n    #define _CRTDBG_MAP_ALLOC\r\n    #include <crtdbg.h>\r\n#endif\r\n\r\n#if __STDC_VERSION__ >= 199901L && !defined(C99)\r\n    #define C99             1\r\n#endif\r\n#if __cplusplus >= 201103L && !defined(CXX11)\r\n    #define CXX11           1\r\n#endif\r\n\r\n//#define MZC4_FAT_AND_RICH   1\r\n//#define MZC4_HANDLE_MAP     1\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// headers\r\n\r\n// Win32API headers\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_WINDOWSX\r\n    #include <windowsx.h>   // Win32API Macro APIs\r\n#endif\r\n#ifndef _INC_COMMCTRL\r\n    #include <commctrl.h>   // common controls\r\n#endif\r\n#ifndef _INC_COMMDLG\r\n    #include <commdlg.h>    // common dialogs\r\n#endif\r\n#ifndef _INC_TCHAR\r\n    #include <tchar.h>      // generic text mappings\r\n#endif\r\n\r\n#include <dlgs.h>           // dialog control IDs\r\n\r\n#ifndef NO_STRSAFE\r\n    #include <strsafe.h>    // StringCch* or StringCb*\r\n#endif\r\n\r\n// standard C/C++ library\r\n#include <cassert>          // assert\r\n#include <cstring>          // C string library\r\n\r\n#include <map>              // std::map\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _countof\r\n    #define _countof(array)     (sizeof(array) / sizeof(array[0]))\r\n#endif\r\n\r\n// MString\r\n#ifndef MString\r\n    #include <string>       // std::string and std::wstring\r\n    typedef std::string     MStringA;\r\n    typedef std::wstring    MStringW;\r\n    #ifdef UNICODE\r\n        #define MString     MStringW\r\n    #else\r\n        #define MString     MStringA\r\n    #endif\r\n#endif\r\n\r\n// NOTE: Old Digital Mars C/C++ Compiler doesn't define INT_PTR type likely.\r\n#ifdef __DMC__\r\n    #ifndef INT_PTR\r\n        #ifdef _WIN64\r\n            #define INT_PTR     LPARAM\r\n        #else\r\n            #define INT_PTR     BOOL\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// public functions\r\n\r\n#ifndef MZCAPI\r\n    #define MZCAPI      WINAPI\r\n#endif\r\n\r\n#ifndef MZCAPIV\r\n    #define MZCAPIV     WINAPIV\r\n#endif\r\n\r\nVOID MZCAPIV DebugPrintDx(const char *format, ...);\r\nVOID MZCAPIV DebugPrintDx(const WCHAR *format, ...);\r\nRECT MZCAPI GetVirtualScreenRectDx();\r\nVOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc);\r\nRECT MZCAPI WorkAreaFromWindowDx(HWND hwnd);\r\nSIZE MZCAPI SizeFromRectDx(LPCRECT prc);\r\nLPTSTR MZCAPI LoadStringDx(INT nID);\r\nLPCTSTR MZCAPI GetStringDx(INT nStringID);\r\nLPCTSTR MZCAPI GetStringDx(LPCTSTR psz);\r\nBOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);\r\nBOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);\r\nBOOL MZCAPI SetWindowPosDx(HWND hwnd, LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n    HWND hwndInsertAfter = NULL,\r\n    UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\nBOOL MZCAPI SetWindowPosDx(HWND hwnd, const RECT *prc);\r\nLPSTR MZCAPI MakeFilterDx(LPSTR psz);\r\nLPWSTR MZCAPI MakeFilterDx(LPWSTR psz);\r\nHBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height);\r\nvoid MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr);\r\nvoid MZCAPI PremultiplyDx(HBITMAP hbm32bpp);\r\nBOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text);\r\nvoid MZCAPI\r\nPopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y);\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Messaging\r\n\r\n// LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam);\r\n#define HANDLE_MESSAGE(hwnd, uMsg, OnMessage) \\\r\n    case (uMsg): return (OnMessage)((hwnd), (wParam), (lParam))\r\n\r\n// LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n#define HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessageEx) \\\r\n    case (uMsg): return (OnMessageEx)((hwnd), (uMsg), (wParam), (lParam))\r\n\r\n#define DO_MSG(WM_, fn) \\\r\n    case (WM_): return HANDLE_##WM_(hwnd, (wParam), (lParam), (fn))\r\n#define DO_MESSAGE(uMsg, OnMessage) \\\r\n    HANDLE_MESSAGE(hwnd, uMsg, OnMessage)\r\n#define DO_MESSAGE_EX(uMsg, OnMessageEx) \\\r\n    HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessage)\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MWindowBase\r\n{\r\nprotected:\r\n    MSG m_msg;\r\npublic:\r\n    HWND m_hwnd;\r\n    WNDPROC m_fnOldProc;\r\n\r\n    MWindowBase() : m_hwnd(NULL), m_fnOldProc(NULL)\r\n    {\r\n    }\r\n\r\n    MWindowBase(HWND hwnd) : m_hwnd(hwnd), m_fnOldProc(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MWindowBase()\r\n    {\r\n    }\r\n\r\n    operator HWND() const\r\n    {\r\n        return Handle();\r\n    }\r\n    bool operator!() const\r\n    {\r\n        return Handle() == NULL;\r\n    }\r\n    HWND Handle() const\r\n    {\r\n        return (this ? m_hwnd : NULL);\r\n    }\r\n\r\n#ifdef MZC4_HANDLE_MAP\r\n    typedef std::map<HWND, void *> handle_map_type;\r\n    static handle_map_type& GetHandleMap()\r\n    {\r\n        static handle_map_type s_map;\r\n        return s_map;\r\n    }\r\n    static MWindowBase *GetUserData(HWND hwnd)\r\n    {\r\n        handle_map_type::iterator it = GetHandleMap().find(hwnd);\r\n        if (it == GetHandleMap().end())\r\n            return NULL;\r\n        return reinterpret_cast<MWindowBase *>(it->second);\r\n    }\r\n    static void SetUserData(HWND hwnd, void *ptr)\r\n    {\r\n        if (ptr)\r\n        {\r\n            GetHandleMap().insert(std::make_pair(hwnd, ptr));\r\n        }\r\n        else\r\n        {\r\n            GetHandleMap().erase(hwnd);\r\n        }\r\n    }\r\n#else\r\n    static MWindowBase *GetUserData(HWND hwnd)\r\n    {\r\n        return reinterpret_cast<MWindowBase *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));\r\n    }\r\n    static void SetUserData(HWND hwnd, void *ptr)\r\n    {\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptr);\r\n    }\r\n#endif\r\n    virtual void PostNcDestroy()\r\n    {\r\n        SetUserData(m_hwnd, NULL);\r\n        m_hwnd = NULL;\r\n    }\r\n\r\n    MWindowBase *GetUserData() const\r\n    {\r\n        return GetUserData(m_hwnd);\r\n    }\r\n\r\n    LRESULT CALLBACK\r\n    CallWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    virtual LRESULT MZCAPI\r\n    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        if (m_fnOldProc)\r\n        {\r\n            return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);\r\n        }\r\n        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    LRESULT MZCAPI DefaultProcDx()\r\n    {\r\n        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);\r\n    }\r\n\r\n    VOID SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return DefaultProcDx(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    static LRESULT CALLBACK\r\n    WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("katahiromz's MWindowBase Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n    }\r\n\r\n    BOOL RegisterClassDx();\r\n\r\n    BOOL CreateWindowDx(HWND hwndParent, LPCTSTR pszText,\r\n                        DWORD Style = WS_OVERLAPPEDWINDOW, DWORD ExStyle = 0,\r\n                        INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,\r\n                        INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT,\r\n                        HMENU hMenu = NULL);\r\n    BOOL CreateAsChildDx(HWND hwndParent, LPCTSTR pszText,\r\n                         DWORD Style = WS_CHILD | WS_VISIBLE,\r\n                         DWORD ExStyle = 0, INT nCtrlID = -1,\r\n                         INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,\r\n                         INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT);\r\n\r\n    BOOL Attach(HWND hwnd)\r\n    {\r\n        m_hwnd = hwnd;\r\n        SetUserData(m_hwnd, this);\r\n        return m_hwnd != NULL;\r\n    }\r\n\r\n    HWND Detach()\r\n    {\r\n        HWND hwnd = m_hwnd;\r\n        SetUserData(hwnd, NULL);\r\n        m_hwnd = NULL;\r\n        return hwnd;\r\n    }\r\n\r\n    virtual void PostSubclassDx(HWND hwnd)\r\n    {\r\n    }\r\n\r\n    BOOL SubclassDx(HWND hwnd)\r\n    {\r\n        Attach(hwnd);\r\n        m_fnOldProc = SubclassWindow(hwnd, MWindowBase::WindowProc);\r\n        if (m_fnOldProc)\r\n        {\r\n            PostSubclassDx(hwnd);\r\n        }\r\n        return m_fnOldProc != NULL;\r\n    }\r\n\r\n    VOID UnsubclassDx()\r\n    {\r\n        SubclassWindow(m_hwnd, m_fnOldProc);\r\n        Detach();\r\n        m_fnOldProc = NULL;\r\n    }\r\n\r\n    BOOL SubclassChildDx(MWindowBase& child, UINT nItemID)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return child.SubclassDx(::GetDlgItem(m_hwnd, nItemID));\r\n    }\r\n\r\n    INT MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,\r\n                 UINT uType = MB_ICONINFORMATION);\r\n\r\n    INT MsgBoxDx(UINT nStringID, UINT nTitleID, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), MAKEINTRESOURCE(nTitleID), uType);\r\n    }\r\n\r\n    INT MsgBoxDx(UINT nStringID, LPCTSTR pszTitle, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), pszTitle, uType);\r\n    }\r\n\r\n    INT MsgBoxDx(UINT nStringID, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), NULL, uType);\r\n    }\r\n\r\n    INT MsgBoxDx(LPCTSTR pszString, UINT uType)\r\n    {\r\n        return MsgBoxDx(pszString, NULL, uType);\r\n    }\r\n\r\n    INT ErrorBoxDx(UINT nStringID, UINT uType = MB_ICONERROR)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), TEXT("ERROR"), uType);\r\n    }\r\n    INT ErrorBoxDx(LPCTSTR pszString, UINT uType = MB_ICONERROR)\r\n    {\r\n        return MsgBoxDx(pszString, TEXT("ERROR"), uType);\r\n    }\r\n\r\n    VOID CenterWindowDx() const\r\n    {\r\n        CenterWindowDx(m_hwnd);\r\n    }\r\n\r\n    static INT GetWindowTextLength(HWND hwnd)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetWindowTextLength(hwnd);\r\n    }\r\n    INT GetWindowTextLength() const\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::GetWindowTextLength(Handle());\r\n    }\r\n\r\n    static MString GetWindowText(HWND hwnd);\r\n    static INT GetWindowText(HWND hwnd, LPTSTR pszText, INT cchMax)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetWindowText(hwnd, pszText, cchMax);\r\n    }\r\n    MString GetWindowText() const\r\n    {\r\n        return GetWindowText(m_hwnd);\r\n    }\r\n\r\n    static UINT GetDlgItemText(HWND hwnd, INT nCtrlID, LPTSTR psz, INT cchMax)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetDlgItemText(hwnd, nCtrlID, psz, cchMax);\r\n    }\r\n    static MString GetDlgItemText(HWND hwnd, INT nCtrlID)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return GetWindowText(::GetDlgItem(hwnd, nCtrlID));\r\n    }\r\n    MString GetDlgItemText(INT nCtrlID) const\r\n    {\r\n        return GetWindowText(::GetDlgItem(m_hwnd, nCtrlID));\r\n    }\r\n\r\n    static BOOL SetWindowText(HWND hwnd, LPCTSTR pszText = NULL)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::SetWindowText(hwnd, pszText);\r\n    }\r\n    BOOL SetWindowText(LPCTSTR pszText = NULL)\r\n    {\r\n        return SetWindowText(Handle(), pszText);\r\n    }\r\n\r\n    static VOID CenterWindowDx(HWND hwnd);\r\n\r\n    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);\r\n    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);\r\n\r\n    BOOL MZCAPI GetWindowPosDx(POINT *ppt = NULL, SIZE *psiz = NULL);\r\n    BOOL MZCAPI GetWindowPosDx(RECT *prc);\r\n\r\n    static BOOL SetWindowPosDx(HWND hwnd,\r\n                               LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n                               HWND hwndInsertAfter = NULL,\r\n                               UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\n    static BOOL SetWindowPosDx(HWND hwnd, const RECT *prc);\r\n\r\n    BOOL SetWindowPosDx(LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n                        HWND hwndInsertAfter = NULL,\r\n                        UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\n    BOOL SetWindowPosDx(const RECT *prc);\r\n\r\n    static HWND GetAncestorDx(HWND hTarget);\r\n    HWND GetAncestorDx() const\r\n    {\r\n        return GetAncestorDx(m_hwnd);\r\n    }\r\n\r\n    HICON LoadIconDx(INT id)\r\n    {\r\n        return LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(id));\r\n    }\r\n\r\n    HICON LoadSmallIconDx(UINT id)\r\n    {\r\n        INT cxSmall = GetSystemMetrics(SM_CXSMICON);\r\n        INT cySmall = GetSystemMetrics(SM_CYSMICON);\r\n        return HICON(LoadImage(GetModuleHandle(NULL), \r\n                               MAKEINTRESOURCE(id),\r\n                               IMAGE_ICON, cxSmall, cySmall, 0));\r\n    }\r\n\r\n    HFONT GetFontDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowFont(m_hwnd);\r\n    }\r\n    void SetFontDx(HFONT hFont, BOOL bRedraw = TRUE)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        SetWindowFont(m_hwnd, hFont, bRedraw);\r\n    }\r\n    DWORD GetStyleDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowStyle(m_hwnd);\r\n    }\r\n    DWORD SetStyleDx(DWORD dwNewStyle)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return SetWindowLong(m_hwnd, GWL_STYLE, dwNewStyle);\r\n    }\r\n    void ModifyStyleDx(DWORD dwRemove, DWORD dwAdd)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        DWORD style = GetStyleDx();\r\n        style &= ~dwRemove;\r\n        style |= dwAdd;\r\n        SetStyleDx(style);\r\n    }\r\n    DWORD GetExStyleDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowExStyle(m_hwnd);\r\n    }\r\n    DWORD SetExStyleDx(DWORD dwNewExStyle)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return SetWindowLong(m_hwnd, GWL_EXSTYLE, dwNewExStyle);\r\n    }\r\n    void ModifyExStyleDx(DWORD dwRemove, DWORD dwAdd)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        DWORD exstyle = GetExStyleDx();\r\n        exstyle &= ~dwRemove;\r\n        exstyle |= dwAdd;\r\n        SetExStyleDx(exstyle);\r\n    }\r\n\r\n    HWND GetChildDx(HWND hwndChild) const\r\n    {\r\n        return hwndChild;\r\n    }\r\n    HWND GetChildDx(UINT id) const\r\n    {\r\n        return ::GetDlgItem(m_hwnd, id);\r\n    }\r\n    UINT GetCtrlIDDx(HWND hwndChild) const\r\n    {\r\n        return ::GetDlgCtrlID(hwndChild);\r\n    }\r\n    UINT GetCtrlIDDx(UINT nChildID) const\r\n    {\r\n        return nChildID;\r\n    }\r\n\r\n    LRESULT SendMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return ::SendMessage(m_hwnd, uMsg, wParam, lParam);\r\n    }\r\n    BOOL PostMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return ::PostMessage(m_hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    static HHOOK HookCenterMsgBoxDx(BOOL bHook);\r\n\r\nprivate:\r\n    static inline LRESULT CALLBACK\r\n    _msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam);\r\n\r\n#ifdef MZC4_FAT_AND_RICH\r\npublic:\r\n    #include "MWindowBaseRichMethods.hpp"\r\n#endif\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MDialogBase : public MWindowBase\r\n{\r\npublic:\r\n    BOOL    m_bModal;\r\n    HWND    m_hwndOwner;\r\n    LPCTSTR m_pDialogName;\r\n\r\n    MDialogBase() : m_bModal(FALSE), m_hwndOwner(NULL), m_pDialogName(NULL)\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner), m_pDialogName(NULL)\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner, INT nDialogID)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner),\r\n          m_pDialogName(MAKEINTRESOURCE(nDialogID))\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner, LPCTSTR pDialogName)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner),\r\n          m_pDialogName(pDialogName)\r\n    {\r\n    }\r\n\r\n    MDialogBase(INT nDialogID)\r\n        : m_bModal(FALSE), m_hwndOwner(NULL),\r\n          m_pDialogName(MAKEINTRESOURCE(nDialogID))\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("#32770");\r\n    }\r\n\r\n    virtual LRESULT MZCAPI\r\n    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    LRESULT MZCAPI DefaultProcDx()\r\n    {\r\n        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    static INT_PTR CALLBACK\r\n    DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    static MDialogBase *GetUserData(HWND hwnd)\r\n    {\r\n        return (MDialogBase *)GetWindowLongPtr(hwnd, DWLP_USER);\r\n    }\r\n    static VOID SetUserData(HWND hwnd, VOID *ptr)\r\n    {\r\n        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ptr);\r\n    }\r\n\r\n    BOOL CreateDialogDx(HWND hwndOwner, INT nDialogID);\r\n    BOOL CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName);\r\n    INT_PTR DialogBoxDx(HWND hwndOwner, INT nDialogID);\r\n    INT_PTR DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName);\r\n    BOOL CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr);\r\n    INT_PTR DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr);\r\n\r\n    BOOL CreateDialogDx(HWND hwndOwner)\r\n    {\r\n        return CreateDialogDx(hwndOwner, m_pDialogName);\r\n    }\r\n\r\n    INT_PTR DialogBoxDx(HWND hwndOwner)\r\n    {\r\n        return DialogBoxDx(hwndOwner, m_pDialogName);\r\n    }\r\n\r\n    DWORD GetDefID() const\r\n    {\r\n        return (DWORD)SendMessageDx(DM_GETDEFID);\r\n    }\r\n    BOOL SetDefID(UINT nID)\r\n    {\r\n        return (BOOL)SendMessageDx(DM_SETDEFID, (WPARAM)nID);\r\n    }\r\n\r\n    BOOL EndDialog(INT_PTR nResult)\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::EndDialog(Handle(), nResult);\r\n    }\r\n    static BOOL EndDialog(HWND hwnd, INT_PTR nResult)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::EndDialog(hwnd, nResult);\r\n    }\r\n\r\n    VOID NextDlgCtrl() const\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, FALSE);\r\n    }\r\n    VOID PrevDlgCtrl() const\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, TRUE);\r\n    }\r\n    VOID GotoDlgCtrl(HWND hwndCtrl)\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, (WPARAM)hwndCtrl, 1);\r\n    }\r\n\r\n    BOOL MapDialogRect(LPRECT prc) const\r\n    {\r\n        assert(IsWindow(Handle()));\r\n        return ::MapDialogRect(Handle(), prc);\r\n    }\r\n    static BOOL MapDialogRect(HWND hwnd, LPRECT prc)\r\n    {\r\n        assert(IsWindow(hwnd));\r\n        return ::MapDialogRect(hwnd, prc);\r\n    }\r\n\r\n    BOOL IsDialogMessage(LPMSG pMsg)\r\n    {\r\n        return ::IsDialogMessage(Handle(), pMsg);\r\n    }\r\n\r\n    BOOL Attach(HWND hwnd)\r\n    {\r\n        m_hwnd = hwnd;\r\n        SetUserData(m_hwnd, this);\r\n        return m_hwnd != NULL;\r\n    }\r\n\r\n    HWND Detach()\r\n    {\r\n        HWND hwnd = m_hwnd;\r\n        SetUserData(hwnd, NULL);\r\n        m_hwnd = NULL;\r\n        return hwnd;\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// public inline functions\r\n\r\ninline VOID MZCAPIV DebugPrintDx(const char *format, ...)\r\n{\r\n    #ifndef NDEBUG\r\n        char buffer[512];\r\n        va_list va;\r\n        va_start(va, format);\r\n#ifdef NO_STRSAFE\r\n        wsprintfA(buffer, format, va);\r\n#else\r\n        StringCchVPrintfA(buffer, _countof(buffer), format, va);\r\n#endif\r\n        va_end(va);\r\n        OutputDebugStringA(buffer);\r\n    #endif\r\n}\r\n\r\ninline VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...)\r\n{\r\n    #ifndef NDEBUG\r\n        WCHAR buffer[512];\r\n        va_list va;\r\n        va_start(va, format);\r\n#ifdef NO_STRSAFE\r\n        wsprintfW(buffer, format, va);\r\n#else\r\n        StringCchVPrintfW(buffer, _countof(buffer), format, va);\r\n#endif\r\n        va_end(va);\r\n        OutputDebugStringW(buffer);\r\n    #endif\r\n}\r\n\r\ninline RECT MZCAPI GetVirtualScreenRectDx()\r\n{\r\n    RECT rc;\r\n#ifndef SM_XVIRTUALSCREEN\r\n    #define SM_XVIRTUALSCREEN   76\r\n    #define SM_YVIRTUALSCREEN   77\r\n    #define SM_CXVIRTUALSCREEN  78\r\n    #define SM_CYVIRTUALSCREEN  79\r\n#endif\r\n    INT x = ::GetSystemMetrics(SM_XVIRTUALSCREEN);\r\n    INT y = ::GetSystemMetrics(SM_YVIRTUALSCREEN);\r\n    INT cx = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);\r\n    INT cy = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);\r\n    if (cx == 0)\r\n        cx = ::GetSystemMetrics(SM_CXSCREEN);\r\n    if (cy == 0)\r\n        cy = ::GetSystemMetrics(SM_CYSCREEN);\r\n    SetRect(&rc, x, y, x + cx, y + cy);\r\n    return rc;\r\n}\r\n\r\ninline VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc)\r\n{\r\n    if (ppt->x + siz.cx > prc->right)\r\n        ppt->x = prc->right - siz.cx;\r\n    if (ppt->y + siz.cy > prc->bottom)\r\n        ppt->y = prc->bottom - siz.cy;\r\n    if (ppt->x < prc->left)\r\n        ppt->x = prc->left;\r\n    if (ppt->y < prc->top)\r\n        ppt->y = prc->top;\r\n}\r\n\r\ninline RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd)\r\n{\r\n#if (WINVER >= 0x0500)\r\n    MONITORINFO mi;\r\n    mi.cbSize = sizeof(mi);\r\n    HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\r\n    if (GetMonitorInfo(hMonitor, &mi))\r\n    {\r\n        return mi.rcWork;\r\n    }\r\n#endif\r\n    RECT rc;\r\n    ::SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);\r\n    return rc;\r\n}\r\n\r\ninline SIZE MZCAPI SizeFromRectDx(LPCRECT prc)\r\n{\r\n    SIZE siz;\r\n    siz.cx = prc->right - prc->left;\r\n    siz.cy = prc->bottom - prc->top;\r\n    return siz;\r\n}\r\n\r\ninline LPTSTR MZCAPI LoadStringDx(INT nID)\r\n{\r\n    static UINT s_index = 0;\r\n    const UINT buf_size = 1024;\r\n    static TCHAR s_sz[4][buf_size];\r\n\r\n    TCHAR *buffer = s_sz[s_index];\r\n    s_index = (s_index + 1) % _countof(s_sz);\r\n    buffer[0] = 0;\r\n    ::LoadString(NULL, nID, buffer, buf_size);\r\n    return buffer;\r\n}\r\n\r\ninline LPCTSTR MZCAPI GetStringDx(LPCTSTR psz)\r\n{\r\n    if (psz == NULL)\r\n        return NULL;\r\n    if (IS_INTRESOURCE(psz))\r\n        return LoadStringDx(LOWORD(psz));\r\n    return psz;\r\n}\r\n\r\ninline LPCTSTR MZCAPI GetStringDx(INT nStringID)\r\n{\r\n    return LoadStringDx(nStringID);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nGetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    RECT rc;\r\n    if (!GetWindowRect(hwnd, &rc))\r\n        return FALSE;\r\n\r\n    if (ppt)\r\n    {\r\n        ppt->x = rc.left;\r\n        ppt->y = rc.top;\r\n        if (GetWindowStyle(hwnd) & WS_CHILD)\r\n        {\r\n            MapWindowPoints(NULL, GetParent(hwnd), ppt, 1);\r\n        }\r\n    }\r\n    if (psiz)\r\n    {\r\n        psiz->cx = rc.right - rc.left;\r\n        psiz->cy = rc.bottom - rc.top;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc)\r\n{\r\n    POINT pt;\r\n    SIZE siz;\r\n    if (!GetWindowPosDx(hwnd, &pt, &siz))\r\n        return FALSE;\r\n    prc->left = pt.x;\r\n    prc->top = pt.y;\r\n    prc->right = pt.x + siz.cx;\r\n    prc->bottom = pt.x + siz.cy;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MZCAPI\r\nSetWindowPosDx(HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    if (hwndInsertAfter == NULL)\r\n    {\r\n        uFlags |= SWP_NOZORDER;\r\n    }\r\n\r\n    INT x = 0, y = 0;\r\n    if (ppt == NULL)\r\n    {\r\n        uFlags |= SWP_NOMOVE;\r\n    }\r\n    else\r\n    {\r\n        x = ppt->x;\r\n        y = ppt->y;\r\n    }\r\n\r\n    INT cx = 0, cy = 0;\r\n    if (psiz == NULL)\r\n    {\r\n        uFlags |= SWP_NOSIZE;\r\n    }\r\n    else\r\n    {\r\n        cx = psiz->cx;\r\n        cy = psiz->cy;\r\n    }\r\n\r\n    return ::SetWindowPos(hwnd, hwndInsertAfter, x, y, cx, cy, uFlags);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nSetWindowPosDx(HWND hwnd, const RECT *prc)\r\n{\r\n    assert(prc);\r\n    POINT pt;\r\n    SIZE siz;\r\n    pt.x = prc->left;\r\n    pt.y = prc->top;\r\n    siz.cx = prc->right - prc->left;\r\n    siz.cy = prc->bottom - prc->top;\r\n    return ::SetWindowPosDx(hwnd, &pt, &siz);\r\n}\r\n\r\ninline LPSTR MZCAPI MakeFilterDx(LPSTR psz)\r\n{\r\n    for (LPSTR pch = psz; *pch; ++pch)\r\n    {\r\n        if (*pch == '|')\r\n            *pch = 0;\r\n    }\r\n    return psz;\r\n}\r\n\r\ninline LPWSTR MZCAPI MakeFilterDx(LPWSTR psz)\r\n{\r\n    for (LPWSTR pch = psz; *pch; ++pch)\r\n    {\r\n        if (*pch == L'|')\r\n            *pch = 0;\r\n    }\r\n    return psz;\r\n}\r\n\r\ninline HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height)\r\n{\r\n    BITMAPINFO bi;\r\n    ZeroMemory(&bi, sizeof(bi));\r\n    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\r\n    bi.bmiHeader.biWidth = width;\r\n    bi.bmiHeader.biHeight = height;\r\n    bi.bmiHeader.biPlanes = 1;\r\n    bi.bmiHeader.biBitCount = 24;\r\n    bi.bmiHeader.biCompression = BI_RGB;\r\n    HDC hDC = CreateCompatibleDC(NULL);\r\n    LPVOID pvBits;\r\n    HBITMAP hbm = CreateDIBSection(hDC, &bi, DIB_RGB_COLORS,\r\n                                   &pvBits, NULL, 0);\r\n    DeleteDC(hDC);\r\n    return hbm;\r\n}\r\n\r\ninline void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr)\r\n{\r\n    BITMAP bm;\r\n    if (!GetObject(hbm, sizeof(bm), &bm))\r\n        return;\r\n\r\n    HDC hDC = CreateCompatibleDC(NULL);\r\n    {\r\n        HGDIOBJ hbmOld = SelectObject(hDC, hbm);\r\n        {\r\n            RECT rc;\r\n            SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);\r\n            FillRect(hDC, &rc, hbr);\r\n            DeleteObject(hbr);\r\n        }\r\n        SelectObject(hDC, hbmOld);\r\n    }\r\n    DeleteDC(hDC);\r\n}\r\n\r\ninline void MZCAPI\r\nPremultiplyDx(HBITMAP hbm32bpp)\r\n{\r\n    BITMAP bm;\r\n    DWORD cdw;\r\n    LPBYTE pb;\r\n    BYTE alpha;\r\n    GetObject(hbm32bpp, sizeof(bm), &bm);\r\n    if (bm.bmBitsPixel == 32)\r\n    {\r\n        cdw = bm.bmWidth * bm.bmHeight;\r\n        pb = (LPBYTE) bm.bmBits;\r\n        while (cdw--)\r\n        {\r\n            alpha = pb[3];\r\n            pb[0] = (BYTE) ((DWORD) pb[0] * alpha / 255);\r\n            pb[1] = (BYTE) ((DWORD) pb[1] * alpha / 255);\r\n            pb[2] = (BYTE) ((DWORD) pb[2] * alpha / 255);\r\n            pb += 4;\r\n        }\r\n    }\r\n}\r\n\r\ninline BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text)\r\n{\r\n#ifdef UNICODE\r\n    UINT CF_ = CF_UNICODETEXT;\r\n#else\r\n    UINT CF_ = CF_TEXT;\r\n#endif\r\n    DWORD size = DWORD((text.size() + 1) * sizeof(TCHAR));\r\n    LPTSTR psz = (LPTSTR)GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, size);\r\n    if (psz)\r\n    {\r\n        HGLOBAL hGlobal = GlobalPtrHandle(psz);\r\n        CopyMemory(psz, text.c_str(), size);\r\n        GlobalUnlockPtr(psz);\r\n\r\n        if (OpenClipboard(hwnd))\r\n        {\r\n            EmptyClipboard();\r\n            SetClipboardData(CF_, hGlobal);\r\n            return CloseClipboard();\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline void MZCAPI\r\nPopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y)\r\n{\r\n    HMENU hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(nMenuID));\r\n    HMENU hSubMenu = GetSubMenu(hMenu, iSubMenu);\r\n\r\n    if (x == 0xFFFF && y == 0xFFFF)\r\n    {\r\n        RECT rc;\r\n        GetWindowRect(hContext, &rc);\r\n        x = rc.left;\r\n        y = rc.top;\r\n    }\r\n\r\n    SetForegroundWindow(hwnd);\r\n    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,\r\n        x, y, 0, hwnd, NULL);\r\n    PostMessage(hwnd, WM_NULL, 0, 0);\r\n    DestroyMenu(hMenu);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\ninline VOID\r\nMWindowBase::SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    m_msg.hwnd = hwnd;\r\n    m_msg.message = uMsg;\r\n    m_msg.wParam = wParam;\r\n    m_msg.lParam = lParam;\r\n    m_msg.time = GetMessageTime();\r\n    LONG nPos = GetMessagePos();\r\n    m_msg.pt.x = GET_X_LPARAM(nPos);\r\n    m_msg.pt.y = GET_Y_LPARAM(nPos);\r\n}\r\n\r\ninline /*static*/ LRESULT CALLBACK\r\nMWindowBase::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    MWindowBase *base;\r\n    if (uMsg == WM_CREATE)\r\n    {\r\n        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;\r\n        assert(pcs->lpCreateParams);\r\n        base = (MWindowBase *)pcs->lpCreateParams;\r\n        base->m_hwnd = hwnd;\r\n    }\r\n    else\r\n    {\r\n        base = GetUserData(hwnd);\r\n    }\r\n\r\n    LRESULT ret = 0;\r\n    if (base)\r\n    {\r\n        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);\r\n        ret = base->WindowProcDx(hwnd, uMsg, wParam, lParam);\r\n\r\n        if (uMsg == WM_NCDESTROY)\r\n        {\r\n            base->PostNcDestroy();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        ret = ::DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline BOOL MWindowBase::RegisterClassDx()\r\n{\r\n    HMODULE hMod = ::GetModuleHandle(NULL);\r\n\r\n    WNDCLASSEX wcx;\r\n    LPCTSTR pszClass = GetWndClassNameDx();\r\n    if (::GetClassInfoEx(NULL, pszClass, &wcx) ||\r\n        ::GetClassInfoEx(hMod, pszClass, &wcx))\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    ZeroMemory(&wcx, sizeof(wcx));\r\n    wcx.cbSize = sizeof(wcx);\r\n    wcx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;\r\n    wcx.lpfnWndProc = MWindowBase::WindowProc;\r\n    wcx.hInstance = hMod;\r\n    wcx.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);\r\n    wcx.hCursor = ::LoadCursor(NULL, IDC_ARROW);\r\n    wcx.hbrBackground = ::GetSysColorBrush(COLOR_3DFACE);\r\n    wcx.lpszMenuName = NULL;\r\n    wcx.lpszClassName = pszClass;\r\n    wcx.hIconSm = ::LoadIcon(NULL, IDI_APPLICATION);\r\n\r\n    ModifyWndClassDx(wcx);\r\n\r\n    return ::RegisterClassEx(&wcx);\r\n}\r\n\r\ninline BOOL MWindowBase::CreateWindowDx(\r\n    HWND hwndParent, LPCTSTR pszText,\r\n    DWORD Style/* = WS_OVERLAPPEDWINDOW*/, DWORD ExStyle/* = 0*/,\r\n    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,\r\n    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/,\r\n    HMENU hMenu/* = NULL*/)\r\n{\r\n    if (!RegisterClassDx())\r\n        return FALSE;\r\n\r\n    HWND hwnd = ::CreateWindowEx(ExStyle, GetWndClassNameDx(),\r\n        GetStringDx(pszText), Style, x, y, cx, cy, hwndParent,\r\n        hMenu, GetModuleHandle(NULL), this);\r\n    return Attach(hwnd);\r\n}\r\n\r\ninline BOOL\r\nMWindowBase::CreateAsChildDx(\r\n    HWND hwndParent, LPCTSTR pszText,\r\n    DWORD Style/* = WS_CHILD | WS_VISIBLE*/,\r\n    DWORD ExStyle/* = 0*/, INT nCtrlID/* = -1*/,\r\n    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,\r\n    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/)\r\n{\r\n    Style |= WS_CHILD;\r\n    return CreateWindowDx(hwndParent, pszText, Style, ExStyle,\r\n        x, y, cx, cy, (HMENU)(INT_PTR)nCtrlID);\r\n}\r\n\r\ninline INT\r\nMWindowBase::MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,\r\n                      UINT uType/* = MB_ICONINFORMATION*/)\r\n{\r\n    MString Title;\r\n    if (pszTitle == NULL)\r\n    {\r\n#ifdef IDS_APPNAME\r\n        Title = LoadStringDx(IDS_APPNAME);\r\n#else\r\n        if (m_hwnd)\r\n        {\r\n            Title = GetWindowText(GetAncestorDx());\r\n            size_t i = Title.find(TEXT(" - "));\r\n            if (i != MString::npos)\r\n            {\r\n                Title = Title.substr(i + 3);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Title = TEXT("ERROR");\r\n        }\r\n#endif\r\n    }\r\n    else\r\n    {\r\n        Title = GetStringDx(pszTitle);\r\n    }\r\n\r\n    MWindowBase::HookCenterMsgBoxDx(TRUE);\r\n    INT nID = ::MessageBox(m_hwnd, GetStringDx(pszString),\r\n                           Title.c_str(), uType);\r\n    MWindowBase::HookCenterMsgBoxDx(FALSE);\r\n\r\n    return nID;\r\n}\r\n\r\ninline /*static*/ MString MWindowBase::GetWindowText(HWND hwnd)\r\n{\r\n    INT cch = ::GetWindowTextLength(hwnd);\r\n    MString ret;\r\n    ret.resize(cch);\r\n    if (!::GetWindowText(hwnd, &ret[0], cch + 1))\r\n        ret.clear();\r\n    return ret;\r\n}\r\n\r\ninline /*static*/ VOID MWindowBase::CenterWindowDx(HWND hwnd)\r\n{\r\n    assert(IsWindow(hwnd));\r\n\r\n    BOOL bChild = !!(GetWindowStyle(hwnd) & WS_CHILD);\r\n\r\n    HWND hwndParent;\r\n    if (bChild)\r\n        hwndParent = ::GetParent(hwnd);\r\n    else\r\n        hwndParent = ::GetWindow(hwnd, GW_OWNER);\r\n\r\n    RECT rcWorkArea = WorkAreaFromWindowDx(hwnd);\r\n\r\n    RECT rcParent;\r\n    if (hwndParent)\r\n        ::GetWindowRect(hwndParent, &rcParent);\r\n    else\r\n        rcParent = rcWorkArea;\r\n\r\n    SIZE sizParent = SizeFromRectDx(&rcParent);\r\n\r\n    RECT rc;\r\n    ::GetWindowRect(hwnd, &rc);\r\n    SIZE siz = SizeFromRectDx(&rc);\r\n\r\n    POINT pt;\r\n    pt.x = rcParent.left + (sizParent.cx - siz.cx) / 2;\r\n    pt.y = rcParent.top + (sizParent.cy - siz.cy) / 2;\r\n\r\n    if (bChild && hwndParent)\r\n    {\r\n        ::GetClientRect(hwndParent, &rcParent);\r\n        ::MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);\r\n        RepositionPointDx(&pt, siz, &rcParent);\r\n\r\n        ::ScreenToClient(hwndParent, &pt);\r\n    }\r\n    else\r\n    {\r\n        RepositionPointDx(&pt, siz, &rcWorkArea);\r\n    }\r\n\r\n    ::SetWindowPos(hwnd, NULL, pt.x, pt.y, 0, 0,\r\n                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\r\n}\r\n\r\ninline /*static*/ BOOL MZCAPI\r\nMWindowBase::GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::GetWindowPosDx(hwnd, ppt, psiz);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nMWindowBase::GetWindowPosDx(POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::GetWindowPosDx(m_hwnd, ppt, psiz);\r\n}\r\n\r\ninline /*static*/ BOOL MZCAPI MWindowBase::GetWindowPosDx(HWND hwnd, RECT *prc)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::GetWindowPosDx(hwnd, prc);\r\n}\r\n\r\ninline BOOL MZCAPI MWindowBase::GetWindowPosDx(RECT *prc)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::GetWindowPosDx(m_hwnd, prc);\r\n}\r\n\r\ninline /*static*/ BOOL\r\nMWindowBase::SetWindowPosDx(\r\n    HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::SetWindowPosDx(hwnd, ppt, psiz, hwndInsertAfter, uFlags);\r\n}\r\n\r\ninline /*static*/ BOOL MWindowBase::SetWindowPosDx(HWND hwnd, const RECT *prc)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::SetWindowPosDx(hwnd, prc);\r\n}\r\n\r\ninline BOOL\r\nMWindowBase::SetWindowPosDx(\r\n    LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::SetWindowPosDx(m_hwnd, ppt, psiz, hwndInsertAfter, uFlags);\r\n}\r\n\r\ninline BOOL MWindowBase::SetWindowPosDx(const RECT *prc)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::SetWindowPosDx(m_hwnd, prc);\r\n}\r\n\r\ninline /*static*/ HWND MWindowBase::GetAncestorDx(HWND hTarget)\r\n{\r\n    HWND hwndParent;\r\n    for (;;)\r\n    {\r\n        hwndParent = ::GetParent(hTarget);\r\n        if (hwndParent == NULL)\r\n        {\r\n            hwndParent = ::GetWindow(hTarget, GW_OWNER);\r\n            if (hwndParent == NULL)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        hTarget = hwndParent;\r\n    }\r\n    return hTarget;\r\n}\r\n\r\n/*static*/ inline LRESULT CALLBACK\r\nMWindowBase::_msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam)\r\n{\r\n#ifndef MZC_NO_CENTER_MSGBOX\r\n    if (nCode == HCBT_ACTIVATE)\r\n    {\r\n        HWND hwnd = (HWND)wParam;\r\n        TCHAR szClassName[16];\r\n        ::GetClassName(hwnd, szClassName, _countof(szClassName));\r\n        if (lstrcmpi(szClassName, TEXT("#32770")) == 0)\r\n        {\r\n            CenterWindowDx(hwnd);\r\n        }\r\n    }\r\n#endif  // ndef MZC_NO_CENTER_MSGBOX\r\n\r\n    return 0;   // allow the operation\r\n}\r\n\r\ninline /*static*/ HHOOK MWindowBase::HookCenterMsgBoxDx(BOOL bHook)\r\n{\r\n#ifdef MZC_NO_CENTER_MSGBOX\r\n    return NULL;\r\n#else   // ndef MZC_NO_CENTER_MSGBOX\r\n    static HHOOK s_hHook = NULL;\r\n    if (bHook)\r\n    {\r\n        if (s_hHook == NULL)\r\n        {\r\n            DWORD dwThreadID = GetCurrentThreadId();\r\n            s_hHook = ::SetWindowsHookEx(WH_CBT, _msgBoxCbtProcDx, NULL, dwThreadID);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (s_hHook)\r\n        {\r\n            if (::UnhookWindowsHookEx(s_hHook))\r\n            {\r\n                s_hHook = NULL;\r\n            }\r\n        }\r\n    }\r\n    return s_hHook;\r\n#endif  // ndef MZC_NO_CENTER_MSGBOX\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ INT_PTR CALLBACK\r\nMDialogBase::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    MDialogBase *base;\r\n    if (uMsg == WM_INITDIALOG)\r\n    {\r\n        assert(lParam);\r\n        base = (MDialogBase *)lParam;\r\n        base->Attach(hwnd);\r\n    }\r\n    else\r\n    {\r\n        base = GetUserData(hwnd);\r\n    }\r\n\r\n    INT_PTR ret = 0;\r\n    if (base)\r\n    {\r\n        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);\r\n        ret = base->DialogProcDx(hwnd, uMsg, wParam, lParam);\r\n        if (uMsg == WM_NCDESTROY)\r\n        {\r\n            base->PostNcDestroy();\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline BOOL MDialogBase::CreateDialogDx(HWND hwndOwner, INT nDialogID)\r\n{\r\n    return CreateDialogDx(hwndOwner, MAKEINTRESOURCE(nDialogID));\r\n}\r\n\r\ninline INT_PTR MDialogBase::DialogBoxDx(HWND hwndOwner, INT nDialogID)\r\n{\r\n    return DialogBoxDx(hwndOwner, MAKEINTRESOURCE(nDialogID));\r\n}\r\n\r\ninline BOOL\r\nMDialogBase::CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = FALSE;\r\n    HWND hwnd = ::CreateDialogIndirectParam(::GetModuleHandle(NULL),\r\n        reinterpret_cast<const DLGTEMPLATE *>(ptr),\r\n        m_hwndOwner, MDialogBase::DialogProc,\r\n        reinterpret_cast<LPARAM>(this));\r\n    if (hwnd == NULL)\r\n    {\r\n        Detach();\r\n    }\r\n    return hwnd != NULL;\r\n}\r\n\r\ninline INT_PTR\r\nMDialogBase::DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = TRUE;\r\n    INT_PTR nID = ::DialogBoxIndirectParam(::GetModuleHandle(NULL),\r\n                                           (const DLGTEMPLATE *)ptr,\r\n                                           m_hwndOwner,\r\n                                           MDialogBase::DialogProc,\r\n                                           reinterpret_cast<LPARAM>(this));\r\n    return nID;\r\n}\r\n\r\ninline BOOL\r\nMDialogBase::CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = FALSE;\r\n    HWND hwnd = ::CreateDialogParam(::GetModuleHandle(NULL), pDialogName,\r\n                                    m_hwndOwner, MDialogBase::DialogProc,\r\n                                    reinterpret_cast<LPARAM>(this));\r\n    if (hwnd == NULL)\r\n    {\r\n        Detach();\r\n    }\r\n    return hwnd != NULL;\r\n}\r\n\r\ninline INT_PTR\r\nMDialogBase::DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = TRUE;\r\n    INT_PTR nID = ::DialogBoxParam(::GetModuleHandle(NULL),\r\n        pDialogName, m_hwndOwner, MDialogBase::DialogProc, (LPARAM)this);\r\n    return nID;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MWINDOWBASE_HPP_\r\n
