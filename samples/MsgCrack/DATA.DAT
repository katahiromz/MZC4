.gitignore<>.gitignore<>*.autosave\r\n*.cmake\r\n*.dir\r\n*.exe\r\n*.filters\r\n*.idb\r\n*.map\r\n*.ncb\r\n*.o\r\n*.obj\r\n*.opensdf\r\n*.res\r\n*.sdf\r\n*.sln\r\n*.suo\r\n*.tds\r\n*.user\r\n*.vcproj\r\n*.vcxproj\r\n*~\r\n.vs\r\nCMakeCache.txt\r\nCMakeFiles\r\nDebug\r\nMakefile\r\nRelease\r\nTMP1.$$$\r\nbuild\r\nipch\r\nx64\r\n*-old\r\n*.skrold\r\n
CMakeLists.txt<>CMakeLists.txt<># CMakeLists.txt --- CMake project settings\r\n#    ex) cmake -G "Visual Studio 9 2008"\r\n#    ex) cmake -DCMAKE_BUILD_TYPE=Release -G "MSYS Makefiles"\r\n##############################################################################\r\n\r\n# CMake minimum version\r\ncmake_minimum_required(VERSION 2.4)\r\n\r\n# project name and language\r\nproject(MyProject CXX)\r\n\r\n# check build type\r\nif (NOT CMAKE_BUILD_TYPE)\r\n    message(STATUS "No build type selected, default to Debug")\r\n    set(CMAKE_BUILD_TYPE "Debug")\r\nendif()\r\n\r\n# make uppercase string of build type\r\nstring(TOUPPER "${CMAKE_BUILD_TYPE}" uppercase_CMAKE_BUILD_TYPE)\r\n\r\n# check build type again\r\nif (NOT uppercase_CMAKE_BUILD_TYPE MATCHES "^(DEBUG|RELEASE|RELWITHDEBINFO|MINSIZEREL)$")\r\n    message(FATAL_ERROR "Invalid value for CMAKE_BUILD_TYPE: ${CMAKE_BUILD_TYPE}")\r\nendif()\r\n\r\n# set output directory (build/)\r\nset(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)\r\nset(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})\r\nset(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})\r\n\r\n# enable Win32 resource\r\nenable_language(RC)\r\n\r\nif (CMAKE_CXX_COMPILER_ID STREQUAL "Clang")\r\n    # using Clang\r\n    set(CMAKE_C_FLAGS "-static")\r\n    set(CMAKE_CXX_FLAGS "-static")\r\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL "GNU")\r\n    # using GCC\r\n    set(CMAKE_C_FLAGS "-static -static-libgcc -static-libstdc++")\r\n    set(CMAKE_CXX_FLAGS "-static -static-libgcc -static-libstdc++")\r\nelseif (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")\r\n    # replace "/MD" with "/MT" (building without runtime DLLs)\r\n    set(CompilerFlags\r\n        CMAKE_C_FLAGS\r\n        CMAKE_C_FLAGS_DEBUG\r\n        CMAKE_C_FLAGS_RELEASE\r\n        CMAKE_C_FLAGS_RELWITHDEBINFO\r\n        CMAKE_CXX_FLAGS\r\n        CMAKE_CXX_FLAGS_DEBUG\r\n        CMAKE_CXX_FLAGS_RELEASE\r\n        CMAKE_CXX_FLAGS_RELWITHDEBINFO)\r\n    foreach(CompilerFlags ${CompilerFlags})\r\n        string(REPLACE "/MD" "/MT" ${CompilerFlags} "${${CompilerFlags}}")\r\n    endforeach()\r\nendif()\r\n\r\n##############################################################################\r\n\r\n# executable\r\nadd_executable(MyProject WIN32 MyProject.cpp MyProject_res.rc)\r\n\r\n# link\r\ntarget_link_libraries(MyProject comctl32)\r\n\r\n##############################################################################\r\n
DialogProc<>DialogProc<>INT_PTR CALLBACK\r\nDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
DialogProcDx<>DialogProcDx<>virtual INT_PTR CALLBACK\r\nDialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
MAccel.hpp<>MAccel.hpp<>// MAccel.hpp -- Win32API accelerator wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MACCEL_HPP_\r\n#define MZC4_MACCEL_HPP_    5       /* Version 5 */\r\n\r\nclass MAccel;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MAccel\r\n{\r\npublic:\r\n    MAccel();\r\n    MAccel(UINT nResourceID);\r\n    MAccel(HACCEL hAccel);\r\n    MAccel(const MAccel& accel);\r\n    MAccel& operator=(HACCEL hAccel);\r\n    MAccel& operator=(const MAccel& accel);\r\n    virtual ~MAccel();\r\n\r\n    HACCEL Handle() const;\r\n    operator HACCEL() const;\r\n    bool operator!() const;\r\n\r\n    BOOL Attach(HACCEL hAccel);\r\n    HACCEL Detach();\r\n\r\n    INT GetAcceleratorCount() const;\r\n    INT CopyAcceleratorTable(LPACCEL pAccel, INT cEntries) const;\r\n\r\n    BOOL CreateAcceleratorTable(LPACCEL pAccel, INT cEntries);\r\n    BOOL LoadAccelerators(LPCTSTR pszResourceName);\r\n    BOOL LoadAccelerators(INT nResourceID);\r\n    BOOL DestroyAcceleratorTable();\r\n\r\n    BOOL TranslateAccelerator(HWND hWnd, MSG *pMsg);\r\n\r\n    static HACCEL CloneHandleDx(HACCEL hAccel);\r\n\r\npublic:\r\n    HACCEL m_hAccel;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MAccel::MAccel() : m_hAccel(NULL)\r\n{\r\n}\r\n\r\ninline MAccel::MAccel(UINT nResourceID) : m_hAccel(NULL)\r\n{\r\n    LoadAccelerators(nResourceID);\r\n}\r\n\r\ninline /*virtual*/ MAccel::~MAccel()\r\n{\r\n    DestroyAcceleratorTable();\r\n}\r\n\r\ninline MAccel::MAccel(HACCEL hAccel) : m_hAccel(hAccel)\r\n{\r\n}\r\n\r\ninline MAccel::MAccel(const MAccel& accel)\r\n    : m_hAccel(CloneHandleDx(accel))\r\n{\r\n}\r\n\r\ninline HACCEL MAccel::Handle() const\r\n{\r\n    return (this ? m_hAccel : NULL);\r\n}\r\n\r\ninline MAccel::operator HACCEL() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline bool MAccel::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline MAccel& MAccel::operator=(HACCEL hAccel)\r\n{\r\n    if (Handle() != hAccel)\r\n    {\r\n        Attach(hAccel);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MAccel& MAccel::operator=(const MAccel& accel)\r\n{\r\n    if (Handle() != accel.Handle())\r\n    {\r\n        HACCEL hAccel = CloneHandleDx(accel);\r\n        Attach(hAccel);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MAccel::Attach(HACCEL hAccel)\r\n{\r\n    DestroyAcceleratorTable();\r\n    m_hAccel = hAccel;\r\n    return m_hAccel != NULL;\r\n}\r\n\r\ninline HACCEL MAccel::Detach()\r\n{\r\n    HACCEL hAccel = m_hAccel;\r\n    m_hAccel = NULL;\r\n    return hAccel;\r\n}\r\n\r\ninline INT MAccel::GetAcceleratorCount() const\r\n{\r\n    assert(Handle());\r\n    return ::CopyAcceleratorTable(Handle(), NULL, 0);\r\n}\r\n\r\ninline INT MAccel::CopyAcceleratorTable(LPACCEL pAccel, INT cEntries) const\r\n{\r\n    assert(Handle());\r\n    return ::CopyAcceleratorTable(Handle(), pAccel, cEntries);\r\n}\r\n\r\ninline BOOL MAccel::CreateAcceleratorTable(LPACCEL pAccel, INT cEntries)\r\n{\r\n    return Attach(::CreateAcceleratorTable(pAccel, cEntries));\r\n}\r\n\r\ninline BOOL MAccel::LoadAccelerators(LPCTSTR pszResourceName)\r\n{\r\n    return Attach(::LoadAccelerators(::GetModuleHandle(NULL), pszResourceName));\r\n}\r\n\r\ninline BOOL MAccel::LoadAccelerators(INT nResourceID)\r\n{\r\n    assert(nResourceID != 0);\r\n    return LoadAccelerators(MAKEINTRESOURCE(nResourceID));\r\n}\r\n\r\ninline BOOL MAccel::DestroyAcceleratorTable()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DestroyAcceleratorTable(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MAccel::TranslateAccelerator(HWND hWnd, MSG *pMsg)\r\n{\r\n    return (Handle() != NULL &&\r\n            ::TranslateAccelerator(hWnd, Handle(), pMsg));\r\n}\r\n\r\ninline /*static*/ HACCEL MAccel::CloneHandleDx(HACCEL hAccel)\r\n{\r\n    if (hAccel == NULL)\r\n        return NULL;\r\n    INT nCount = ::CopyAcceleratorTable(hAccel, NULL, 0);\r\n    if (nCount == 0)\r\n        return NULL;\r\n    LPACCEL pAccel = new ACCEL[nCount];\r\n    ::CopyAcceleratorTable(hAccel, pAccel, nCount);\r\n    hAccel = ::CreateAcceleratorTable(pAccel, nCount);\r\n    delete[] pAccel;\r\n    return hAccel;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MACCEL_HPP_\r\n
MAnimateCtrl.hpp<>MAnimateCtrl.hpp<>// MAnimateCtrl.hpp -- Win32API animate control wrapper    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MANIMATECTRL_HPP_\r\n#define MZC4_MANIMATECTRL_HPP_      2   /* Version 2 */\r\n\r\nclass MAnimateCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MAnimateCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MAnimateCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    BOOL Open(LPCTSTR pszFileName);\r\n    BOOL Open(UINT nAVIResourceID);\r\n    BOOL Play(UINT nFrom, UINT nTo, UINT nRep);\r\n    BOOL Stop();\r\n    BOOL Close();\r\n    BOOL Seek(UINT nTo);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MAnimateCtrl::MAnimateCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MAnimateCtrl::GetWndClassNameDx() const\r\n{\r\n    return ANIMATE_CLASS;\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Open(LPCTSTR pszFileName)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Open(m_hwnd, pszFileName);\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Open(UINT nAVIResourceID)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Open(m_hwnd, MAKEINTRESOURCE(nAVIResourceID));\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Play(UINT nFrom, UINT nTo, UINT nRep)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Play(m_hwnd, nFrom, nTo, nRep);\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Stop()\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Stop(m_hwnd);\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Close()\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Close(m_hwnd);\r\n}\r\n\r\ninline BOOL MAnimateCtrl::Seek(UINT nTo)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    return Animate_Seek(m_hwnd, nTo);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MANIMATECTRL_HPP_\r\n
MAppBar.hpp<>MAppBar.hpp<>// MAppBar.hpp -- Win32API appbar wrapper                       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MAPPBAR_HPP_\r\n#define MZC4_MAPPBAR_HPP_       2       /* Version 2 */\r\n\r\nclass MAppBar;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_SHELLAPI\r\n    #include <shellapi.h>\r\n#endif\r\n\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MPointSizeRect.hpp"\r\n\r\nclass MAppBar : public APPBARDATA\r\n{\r\npublic:\r\n    BOOL fAppRegistered;\r\n\r\n    MAppBar();\r\n    MAppBar(HWND hwnd, UINT uCallbackMsg);\r\n\r\n    BOOL Register(HWND hwnd, UINT uCallbackMsg);\r\n    BOOL Unregister();\r\n    BOOL IsRegistered() const;\r\n\r\n    HWND GetWindow() const;\r\n    UINT GetCallbackMessage() const;\r\n    UINT GetEdge() const;\r\n          MRect& GetRect();\r\n    const MRect& GetRect() const;\r\n    LPARAM GetData() const;\r\n    LPVOID GetDataPtr() const;\r\n    VOID SetData(LPARAM lData);\r\n    VOID SetDataPtr(LPVOID pData);\r\n\r\npublic:\r\n    BOOL Activate();\r\n\r\n    HWND GetAutoHideBar();\r\n    HWND GetAutoHideBar(UINT uABE_);\r\n    BOOL SetAutoHideBar(UINT uABE_, BOOL bRegister = TRUE);\r\n\r\n    BOOL QueryPos();\r\n    BOOL QueryPos(UINT uABE_);\r\n    BOOL QueryPos(UINT uABE_, LPRECT prc);\r\n    BOOL SetPos();\r\n    BOOL SetPos(UINT uABE_);\r\n    BOOL SetPos(UINT uABE_, LPRECT prc);\r\n    BOOL QuerySetPos(UINT uABE_, INT width_or_height, LPRECT prc = NULL);\r\n\r\n    UINT GetState();\r\n    BOOL GetTaskBarPos(LPRECT prc);\r\n\r\n    BOOL WindowPosChanged();\r\n\r\n    // call back messages\r\n    BOOL OnAppBarCallbackMessage(WPARAM wParam, LPARAM lParam);\r\n    virtual VOID OnFullScreenPos(BOOL fOpen);\r\n    virtual VOID OnPosChanged();\r\n    virtual VOID OnStateChange();\r\n    virtual VOID OnWindowArrange(BOOL fBeginning);\r\n\r\n    UINT_PTR SHAppBarMessage(DWORD dwMessage);\r\n};\r\n\r\n#define DO_APPBAR_MESSAGE(AppBar) \\\r\n    DO_MESSAGE((AppBar).uCallbackMessage, (AppBar).OnAppBarCallbackMessage)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MAppBar::MAppBar()\r\n{\r\n    cbSize = sizeof(APPBARDATA);\r\n    hWnd = NULL;\r\n    uCallbackMessage = 0;\r\n    uEdge = 0;\r\n    fAppRegistered = FALSE;\r\n}\r\n\r\ninline MAppBar::MAppBar(HWND hwnd, UINT uCallbackMsg)\r\n{\r\n    cbSize = sizeof(APPBARDATA);\r\n    hWnd = NULL;\r\n    uCallbackMessage = 0;\r\n    uEdge = 0;\r\n    fAppRegistered = FALSE;\r\n    Register(hwnd, uCallbackMsg);\r\n}\r\n\r\ninline BOOL MAppBar::Register(HWND hwnd, UINT uCallbackMsg)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    assert(!fAppRegistered);\r\n    assert((WM_USER <= uCallbackMsg && uCallbackMsg <= 0x7FFF) ||\r\n           (0xC000 <= uCallbackMsg && uCallbackMsg <= 0xFFFF));\r\n    hWnd = hwnd;\r\n    uCallbackMessage = uCallbackMsg;\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_NEW);\r\n    if (bOK)\r\n        fAppRegistered = TRUE;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::Unregister()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_REMOVE);\r\n    if (bOK)\r\n        fAppRegistered = FALSE;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::IsRegistered() const\r\n{\r\n    return fAppRegistered;\r\n}\r\n\r\ninline HWND MAppBar::GetWindow() const\r\n{\r\n    return hWnd;\r\n}\r\n\r\ninline UINT MAppBar::GetCallbackMessage() const\r\n{\r\n    return uCallbackMessage;\r\n}\r\n\r\ninline UINT MAppBar::GetEdge() const\r\n{\r\n    return uEdge;\r\n}\r\n\r\ninline MRect& MAppBar::GetRect()\r\n{\r\n    return *reinterpret_cast<MRect *>(&rc);\r\n}\r\n\r\ninline const MRect& MAppBar::GetRect() const\r\n{\r\n    return *reinterpret_cast<const MRect *>(&rc);\r\n}\r\n\r\ninline LPARAM MAppBar::GetData() const\r\n{\r\n    return lParam;\r\n}\r\n\r\ninline LPVOID MAppBar::GetDataPtr() const\r\n{\r\n    return reinterpret_cast<LPVOID>(lParam);\r\n}\r\n\r\ninline VOID MAppBar::SetData(LPARAM lData)\r\n{\r\n    lParam = lData;\r\n}\r\n\r\ninline VOID MAppBar::SetDataPtr(LPVOID pData)\r\n{\r\n    lParam = (LPARAM)pData;\r\n}\r\n\r\ninline BOOL MAppBar::Activate()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    return SHAppBarMessage(ABM_ACTIVATE);\r\n}\r\n\r\ninline HWND MAppBar::GetAutoHideBar()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    return (HWND)SHAppBarMessage(ABM_GETAUTOHIDEBAR);\r\n}\r\n\r\ninline HWND MAppBar::GetAutoHideBar(UINT uABE_)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n        uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    return (HWND)SHAppBarMessage(ABM_GETAUTOHIDEBAR);\r\n}\r\n\r\ninline BOOL MAppBar::SetAutoHideBar(UINT uABE_, BOOL bRegister/* = TRUE*/)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n        uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    lParam = bRegister;\r\n    return (BOOL)SHAppBarMessage(ABM_SETAUTOHIDEBAR);\r\n}\r\n\r\ninline BOOL MAppBar::QueryPos()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_QUERYPOS);\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::QueryPos(UINT uABE_)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n           uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_QUERYPOS);\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::SetPos()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_SETPOS);\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::SetPos(UINT uABE_)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n           uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_SETPOS);\r\n    return bOK;\r\n}\r\n\r\ninline UINT MAppBar::GetState()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    return (UINT)SHAppBarMessage(ABM_GETSTATE);\r\n}\r\n\r\ninline BOOL MAppBar::GetTaskBarPos(LPRECT prc)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    BOOL bOK = SHAppBarMessage(ABM_GETTASKBARPOS);\r\n    *prc = rc;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::WindowPosChanged()\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    return SHAppBarMessage(ABM_WINDOWPOSCHANGED);\r\n}\r\n\r\ninline /*virtual*/ VOID MAppBar::OnStateChange()\r\n{\r\n    assert(fAppRegistered);\r\n    UINT uState = GetState();\r\n    ::SetWindowPos(hWnd, (ABS_ALWAYSONTOP & uState) ? HWND_TOPMOST : HWND_BOTTOM,\r\n        0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);\r\n}\r\n\r\ninline /*virtual*/ VOID MAppBar::OnWindowArrange(BOOL fBeginning)\r\n{\r\n}\r\n\r\ninline UINT_PTR MAppBar::SHAppBarMessage(DWORD dwMessage)\r\n{\r\n    return ::SHAppBarMessage(dwMessage, this);\r\n}\r\n\r\ninline BOOL MAppBar::QueryPos(UINT uABE_, LPRECT prc)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n        uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    rc = *prc;\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_QUERYPOS);\r\n    *prc = rc;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL MAppBar::SetPos(UINT uABE_, LPRECT prc)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n        uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(::IsWindow(hWnd));\r\n    uEdge = uABE_;\r\n    rc = *prc;\r\n    BOOL bOK = (BOOL)SHAppBarMessage(ABM_SETPOS);\r\n    *prc = rc;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL\r\nMAppBar::QuerySetPos(UINT uABE_, INT width_or_height, LPRECT prc/* = NULL*/)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(uABE_ == ABE_LEFT || uABE_ == ABE_TOP ||\r\n           uABE_ == ABE_RIGHT || uABE_ == ABE_BOTTOM);\r\n    assert(width_or_height >= 0);\r\n\r\n    GetScreenRectDx(&rc);\r\n\r\n    INT cx = 0, cy = 0;\r\n    if (uABE_ == ABE_LEFT || uABE_ == ABE_RIGHT)\r\n        cx = width_or_height;\r\n    else\r\n        cy = width_or_height;\r\n\r\n    if (!QueryPos(uABE_))\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    switch (uABE_)\r\n    {\r\n    case ABE_LEFT:\r\n        rc.right = rc.left + cx;\r\n        break;\r\n    case ABE_TOP:\r\n        rc.bottom = rc.top + cy;\r\n        break;\r\n    case ABE_RIGHT:\r\n        rc.left = rc.right - cx;\r\n        break;\r\n    case ABE_BOTTOM:\r\n        rc.top = rc.bottom - cy;\r\n        break;\r\n    }\r\n\r\n    if (SetPos())\r\n    {\r\n        ::MoveWindow(hWnd, rc.left, rc.top,\r\n            rc.right - rc.left, rc.bottom - rc.top, TRUE);\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MAppBar::OnAppBarCallbackMessage(WPARAM wParam, LPARAM lParam)\r\n{\r\n    assert(fAppRegistered);\r\n    switch (wParam)\r\n    {\r\n    case ABN_FULLSCREENAPP:\r\n        OnFullScreenPos((BOOL)lParam);\r\n        return TRUE;\r\n    case ABN_POSCHANGED:\r\n        OnPosChanged();\r\n        return TRUE;\r\n    case ABN_STATECHANGE:\r\n        OnStateChange();\r\n        return TRUE;\r\n    case ABN_WINDOWARRANGE:\r\n        OnWindowArrange((BOOL)lParam);\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline /*virtual*/ VOID MAppBar::OnFullScreenPos(BOOL fOpen)\r\n{\r\n    assert(fAppRegistered);\r\n    assert(::IsWindow(hWnd));\r\n    UINT uState = GetState();\r\n    if (fOpen)\r\n    {\r\n        ::SetWindowPos(hWnd,\r\n            (ABS_ALWAYSONTOP & uState) ? HWND_TOPMOST : HWND_BOTTOM,\r\n            0, 0, 0, 0,\r\n            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);\r\n    }\r\n    else\r\n    {\r\n        if (uState & ABS_ALWAYSONTOP)\r\n            ::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0,\r\n                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);\r\n    }\r\n}\r\n\r\ninline /*virtual*/ VOID MAppBar::OnPosChanged()\r\n{\r\n    assert(fAppRegistered);\r\n    RECT rcWindow;\r\n    ::GetWindowRect(hWnd, &rcWindow);\r\n\r\n    switch (uEdge)\r\n    {\r\n    case ABE_LEFT:\r\n        QuerySetPos(uEdge, rcWindow.right - rcWindow.left);\r\n        break;\r\n    case ABE_TOP:\r\n        QuerySetPos(uEdge, rcWindow.bottom - rcWindow.top);\r\n        break;\r\n    case ABE_RIGHT:\r\n        QuerySetPos(uEdge, rcWindow.right - rcWindow.left);\r\n        break;\r\n    case ABE_BOTTOM:\r\n        QuerySetPos(uEdge, rcWindow.bottom - rcWindow.top);\r\n        break;\r\n    default:\r\n        assert(false);\r\n        break;\r\n    }\r\n}\r\n\r\n#endif  // ndef MZC4_MAPPBAR_HPP_\r\n
MBitmap.hpp<>MBitmap.hpp<>// MBitmap.hpp -- Win32API bitmap object wrapper                -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MBITMAP_HPP_\r\n#define MZC4_MBITMAP_HPP_       5       /* Version 5 */\r\n\r\nclass MBitmap;\r\nunion BITMAPINFODX;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_COMMCTRL\r\n    #include <commctrl.h>   // for COLORMAP\r\n#endif\r\n#include <algorithm>        // for std::min\r\n#include <cmath>            // for RotateBitmapTo32BppDx\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n\r\nclass MBitmap : public MGdiObject\r\n{\r\npublic:\r\n    MBitmap();\r\n    MBitmap(HBITMAP hbm);\r\n    MBitmap(UINT nResourceID, HINSTANCE hInstance = NULL);\r\n    MBitmap(LPCTSTR pszFileName, FLOAT *dpi = NULL);\r\n    MBitmap(const MBitmap& bmp);\r\n    MBitmap& operator=(HBITMAP hBitmap);\r\n    MBitmap& operator=(const MBitmap& bmp);\r\n\r\n    operator HBITMAP() const;\r\n    HBITMAP Handle() const;\r\n\r\n    BOOL GetBitmap(BITMAP *pbm) const;\r\n    BOOL GetDIBSection(DIBSECTION *pds) const;\r\n    BOOL GetSize(SIZE *psiz) const;\r\n    BOOL Attach(HBITMAP hBitmap);\r\n    HBITMAP Detach(VOID);\r\n\r\n    BOOL LoadBitmap(UINT nResourceID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadBitmap(LPCTSTR pszResourceName, HINSTANCE hInstance = NULL);\r\n    BOOL LoadDIBSection(UINT nResourceID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadDIBSection(LPCTSTR pszResourceName, HINSTANCE hInstance = NULL);\r\n    BOOL LoadImage(UINT nResourceID, UINT fuLoad = LR_CREATEDIBSECTION,\r\n        INT cxDesired = 0, INT cyDesired = 0, HINSTANCE hInstance = NULL);\r\n    BOOL LoadImage(LPCTSTR pszResourceName, UINT fuLoad = LR_CREATEDIBSECTION,\r\n        INT cxDesired = 0, INT cyDesired = 0, HINSTANCE hInstance = NULL);\r\n\r\n    BOOL LoadMappedBitmap(INT_PTR nResourceID, LPCOLORMAP lpColorMap, INT iNumMap,\r\n                          HINSTANCE hInstance = NULL);\r\n    BOOL CreateBitmap(INT cx, INT cy, INT cBitsPerPixel = 1,\r\n        LPCVOID pvBits = NULL);\r\n\r\n    BOOL CreateDIBSection(CONST BITMAPINFO *pbi, VOID **ppvBits);\r\n    BOOL CreateDIBSection(HDC hDC, CONST BITMAPINFO *pbi, VOID **ppvBits);\r\n\r\n    BOOL CreateCompatibleBitmap(HDC hDC, INT cx, INT cy);\r\n    INT GetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines,\r\n        LPVOID lpvBits, LPBITMAPINFO lpbi, UINT uUsage) const;\r\n    INT SetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines, LPCVOID lpvBits,\r\n        CONST BITMAPINFO* lpbi, UINT uUsage);\r\n\r\n    static HBITMAP CloneHandleDx(HBITMAP hBitmap);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef RGBA\r\n    #define RGBA(r,g,b,a)       MAKELONG(MAKEWORD(r, g), MAKEWORD(b, a))\r\n#endif\r\n#ifndef GetAValue\r\n    #define GetAValue(rgba)     HIBYTE(HIWORD(rgba))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nHBITMAP LoadBitmapCommonDx(HANDLE hFile, HBITMAP hbm, FLOAT *dpi = NULL);\r\nBOOL    SaveBitmapCommonDx(HANDLE hFile, HBITMAP hbm, FLOAT dpi = 0.0);\r\n\r\nHBITMAP LoadBitmapFromFileDx(LPCTSTR pszFileName, FLOAT* dpi = NULL);\r\nBOOL    SaveBitmapToFileDx(LPCTSTR pszFileName, HBITMAP hbm, FLOAT dpi = 0.0);\r\nHBITMAP RotateBitmapTo32BppDx(HBITMAP hbmSrc, DOUBLE angle, BOOL fGrow = TRUE);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// BITMAPINFODX\r\n\r\n#include <pshpack1.h>\r\nunion BITMAPINFODX\r\n{\r\n    DWORD biSize;\r\n    BITMAPINFOHEADER bmiHeader;\r\n    BITMAPINFO bi;\r\n    BITMAPV4HEADER bV4;\r\n#if (WINVER >= 0x0500)\r\n    BITMAPV5HEADER bV5;\r\n#endif\r\n\r\n    LPBITMAPINFO operator&()           { return &bi; }\r\n    operator       BITMAPINFO&()       { return bi; }\r\n    operator const BITMAPINFO&() const { return bi; }\r\n};\r\ntypedef BITMAPINFODX *LPBITMAPINFODX;\r\n\r\n#define WidthBytesDx(widthbits) (((widthbits) + 31) / 32 * 4)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MBitmap::MBitmap()\r\n{\r\n}\r\n\r\ninline MBitmap::MBitmap(const MBitmap& bmp) : MGdiObject(CloneHandleDx(bmp))\r\n{\r\n}\r\n\r\ninline MBitmap::MBitmap(HBITMAP hbm) : MGdiObject(hbm)\r\n{\r\n}\r\n\r\ninline MBitmap::MBitmap(UINT nResourceID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    LoadDIBSection(nResourceID, hInstance);\r\n}\r\n\r\ninline MBitmap::MBitmap(LPCTSTR pszFileName, FLOAT *dpi/* = NULL*/)\r\n{\r\n    LoadBitmapFromFileDx(pszFileName, dpi);\r\n}\r\n\r\ninline HBITMAP MBitmap::Handle() const\r\n{\r\n    return (this ? (HBITMAP)m_hGdiObj : NULL);\r\n}\r\n\r\ninline MBitmap::operator HBITMAP() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline BOOL MBitmap::GetBitmap(BITMAP *pbm) const\r\n{\r\n    assert(Handle());\r\n    return ::GetObject(Handle(), sizeof(BITMAP), pbm) == sizeof(BITMAP);\r\n}\r\n\r\ninline BOOL MBitmap::GetDIBSection(DIBSECTION *pds) const\r\n{\r\n    assert(Handle());\r\n    return ::GetObject(Handle(), sizeof(DIBSECTION), pds) ==\r\n           sizeof(DIBSECTION);\r\n}\r\n\r\ninline MBitmap& MBitmap::operator=(HBITMAP hBitmap)\r\n{\r\n    assert(hBitmap == NULL || ::GetObjectType(hBitmap) == OBJ_BITMAP);\r\n    if (Handle() != hBitmap)\r\n    {\r\n        Attach(hBitmap);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MBitmap& MBitmap::operator=(const MBitmap& bmp)\r\n{\r\n    if (Handle() != bmp.Handle())\r\n    {\r\n        HBITMAP hbm = CloneHandleDx(bmp);\r\n        Attach(hbm);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MBitmap::Attach(HBITMAP hBitmap)\r\n{\r\n    assert(::GetObjectType(hBitmap) == OBJ_BITMAP);\r\n    return MGdiObject::Attach(hBitmap);\r\n}\r\n\r\ninline HBITMAP MBitmap::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HBITMAP>(MGdiObject::Detach());\r\n}\r\n\r\ninline BOOL MBitmap::GetSize(SIZE *psiz) const\r\n{\r\n    BITMAP bm;\r\n    if (GetBitmap(&bm))\r\n    {\r\n        psiz->cx = bm.bmWidth;\r\n        psiz->cy = bm.bmHeight;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MBitmap::LoadBitmap(LPCTSTR pszResourceName, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    return Attach(::LoadBitmap(hInstance, pszResourceName));\r\n}\r\n\r\ninline BOOL MBitmap::LoadBitmap(UINT nResourceID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    assert(nResourceID != 0);\r\n    return LoadBitmap(MAKEINTRESOURCE(nResourceID), hInstance);\r\n}\r\n\r\ninline BOOL MBitmap::LoadDIBSection(LPCTSTR pszResourceName, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    HBITMAP hbm;\r\n    hbm = reinterpret_cast<HBITMAP>(::LoadImage(hInstance, pszResourceName, IMAGE_BITMAP,\r\n                                                0, 0, LR_CREATEDIBSECTION));\r\n    return Attach(hbm);\r\n}\r\n\r\ninline BOOL MBitmap::LoadDIBSection(UINT nResourceID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    assert(Handle() == NULL);\r\n    assert(nResourceID != 0);\r\n    return LoadDIBSection(MAKEINTRESOURCE(nResourceID), hInstance);\r\n}\r\n\r\ninline BOOL MBitmap::LoadImage(LPCTSTR pszResourceName,\r\n    UINT fuLoad/* = LR_CREATEDIBSECTION*/,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    HBITMAP hbm;\r\n    hbm = reinterpret_cast<HBITMAP>(::LoadImage(hInstance, pszResourceName, IMAGE_BITMAP,\r\n                                                cxDesired, cyDesired, fuLoad));\r\n    return Attach(hbm);\r\n}\r\n\r\ninline BOOL MBitmap::LoadImage(UINT nResourceID,\r\n    UINT fuLoad/* = LR_CREATEDIBSECTION*/,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    assert(nResourceID != 0);\r\n    return LoadImage(MAKEINTRESOURCE(nResourceID), fuLoad, cxDesired, cyDesired, hInstance);\r\n}\r\n\r\ninline BOOL MBitmap::LoadMappedBitmap(\r\n    INT_PTR nResourceID, LPCOLORMAP lpColorMap, INT iNumMap, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n#ifndef NDEBUG\r\n    BITMAP bm;\r\n    HBITMAP hbm = ::LoadBitmap(\r\n        ::GetModuleHandle(NULL), MAKEINTRESOURCE(nResourceID));\r\n    assert(::GetObject(hbm, sizeof(BITMAP), &bm) != 0);\r\n    assert(bm.bmBitsPixel <= 8);\r\n    assert(::DeleteObject(hbm));\r\n#endif\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    return Attach(::CreateMappedBitmap(hInstance, nResourceID, 0, lpColorMap, iNumMap));\r\n}\r\n\r\ninline BOOL MBitmap::CreateBitmap(INT cx, INT cy,\r\n    INT cBitsPerPixel/* = 1*/, LPCVOID pvBits/* = NULL*/)\r\n{\r\n    return Attach(::CreateBitmap(cx, cy, (UINT) 1, (UINT) cBitsPerPixel, pvBits));\r\n}\r\n\r\ninline BOOL MBitmap::CreateDIBSection(\r\n    CONST BITMAPINFO *pbi, VOID **ppvBits)\r\n{\r\n    return Attach(::CreateDIBSection(NULL, pbi, DIB_RGB_COLORS, ppvBits, NULL, 0));\r\n}\r\n\r\ninline BOOL MBitmap::CreateDIBSection(\r\n    HDC hDC, CONST BITMAPINFO *pbi, VOID **ppvBits)\r\n{\r\n    return Attach(::CreateDIBSection(hDC, pbi, DIB_PAL_COLORS, ppvBits, NULL, 0));\r\n}\r\n\r\ninline BOOL MBitmap::CreateCompatibleBitmap(HDC hDC, INT cx, INT cy)\r\n{\r\n    return Attach(::CreateCompatibleBitmap(hDC, cx, cy));\r\n}\r\n\r\ninline INT MBitmap::GetDIBits(\r\n    HDC hDC, UINT uStartScan, UINT cScanLines,  LPVOID lpvBits,\r\n    LPBITMAPINFO lpbi, UINT uUsage) const\r\n{\r\n    assert(Handle());\r\n    return ::GetDIBits(hDC, Handle(), uStartScan, cScanLines,\r\n                       lpvBits, lpbi, uUsage);\r\n}\r\n\r\ninline INT MBitmap::SetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines,\r\n    LPCVOID lpvBits, CONST BITMAPINFO* lpbi, UINT uUsage)\r\n{\r\n    assert(Handle());\r\n    return ::SetDIBits(hDC, Handle(), uStartScan, cScanLines,\r\n                       lpvBits, lpbi, uUsage);\r\n}\r\n\r\ninline /*static*/ HBITMAP MBitmap::CloneHandleDx(HBITMAP hBitmap)\r\n{\r\n    if (hBitmap == NULL)\r\n        return NULL;\r\n    return (HBITMAP)::CopyImage(hBitmap, IMAGE_BITMAP, 0, 0,\r\n                                LR_COPYRETURNORG | LR_CREATEDIBSECTION);\r\n}\r\n\r\ninline HBITMAP\r\nLoadBitmapCommonDx(HANDLE hFile, HBITMAP hbm, FLOAT *dpi/* = NULL*/)\r\n{\r\n    BITMAPFILEHEADER bf;\r\n    BITMAPINFODX bi;\r\n    DWORD cb, cbImage;\r\n    LPVOID pBits, pBits2;\r\n    HDC hDC, hMemDC;\r\n\r\n    if (!ReadFile(hFile, &bf, sizeof(BITMAPFILEHEADER), &cb, NULL))\r\n    {\r\n        CloseHandle(hFile);\r\n        return hbm;\r\n    }\r\n\r\n    pBits = NULL;\r\n    if (bf.bfType == 0x4D42 && bf.bfReserved1 == 0 && bf.bfReserved2 == 0 &&\r\n        bf.bfSize > bf.bfOffBits && bf.bfOffBits > sizeof(BITMAPFILEHEADER) &&\r\n        bf.bfOffBits <= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFODX))\r\n    {\r\n        if (ReadFile(hFile, &bi, bf.bfOffBits -\r\n                     sizeof(BITMAPFILEHEADER), &cb, NULL))\r\n        {\r\n            if (dpi)\r\n                *dpi = (float)(bi.bmiHeader.biXPelsPerMeter * 2.54 / 100.0);\r\n\r\n            cbImage = bf.bfSize - bf.bfOffBits;\r\n            pBits = malloc(cbImage);\r\n            if (pBits)\r\n            {\r\n                if (ReadFile(hFile, pBits, cbImage, &cb, NULL))\r\n                {\r\n                    ;\r\n                }\r\n                else\r\n                {\r\n                    free(pBits);\r\n                    pBits = NULL;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    CloseHandle(hFile);\r\n\r\n    if (hbm)\r\n    {\r\n        free(pBits);\r\n        return hbm;\r\n    }\r\n\r\n    hDC = CreateCompatibleDC(NULL);\r\n    hMemDC = CreateCompatibleDC(hDC);\r\n    hbm = CreateDIBSection(hMemDC, (BITMAPINFO*)&bi, DIB_RGB_COLORS,\r\n                           &pBits2, NULL, 0);\r\n    if (hbm)\r\n    {\r\n        if (SetDIBits(hMemDC, hbm, 0, abs(bi.bmiHeader.biHeight),\r\n                      pBits, (BITMAPINFO*)&bi, DIB_RGB_COLORS))\r\n        {\r\n            ;\r\n        }\r\n        else\r\n        {\r\n            DeleteObject(hbm);\r\n            hbm = NULL;\r\n        }\r\n    }\r\n    DeleteDC(hMemDC);\r\n    DeleteDC(hDC);\r\n\r\n    free(pBits);\r\n    return hbm;\r\n}\r\n\r\ninline HBITMAP\r\nLoadBitmapFromFileDx(LPCTSTR pszFileName, FLOAT* dpi/* = NULL*/)\r\n{\r\n    HANDLE hFile;\r\n    HBITMAP hbm;\r\n\r\n    hbm = (HBITMAP)LoadImage(NULL, pszFileName, IMAGE_BITMAP,\r\n        0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);\r\n\r\n    hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL,\r\n                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n    if (hFile != INVALID_HANDLE_VALUE)\r\n        return LoadBitmapCommonDx(hFile, hbm, dpi);\r\n    return NULL;\r\n}\r\n\r\ninline BOOL\r\nSaveBitmapCommonDx(HANDLE hFile, HBITMAP hbm, FLOAT dpi/* = 0.0*/)\r\n{\r\n    BITMAPFILEHEADER bf;\r\n    BITMAPINFODX bi;\r\n    BITMAPINFOHEADER *pbmih;\r\n    DWORD cb;\r\n    UINT cColors, cbColors;\r\n    HDC hDC;\r\n    LPVOID pvBits;\r\n    BITMAP bm;\r\n    BOOL bOK;\r\n\r\n    if (!::GetObject(hbm, sizeof(bm), &bm))\r\n    {\r\n        CloseHandle(hFile);\r\n        return FALSE;\r\n    }\r\n\r\n    pbmih = &bi.bmiHeader;\r\n    ZeroMemory(pbmih, sizeof(BITMAPINFOHEADER));\r\n    pbmih->biSize             = sizeof(BITMAPINFOHEADER);\r\n    pbmih->biWidth            = bm.bmWidth;\r\n    pbmih->biHeight           = bm.bmHeight;\r\n    pbmih->biPlanes           = 1;\r\n    pbmih->biBitCount         = bm.bmBitsPixel;\r\n    pbmih->biCompression      = BI_RGB;\r\n    pbmih->biSizeImage        = bm.bmWidthBytes * bm.bmHeight;\r\n    if (dpi != 0.0)\r\n    {\r\n        pbmih->biXPelsPerMeter = (LONG)(dpi * 100 / 2.54 + 0.5);\r\n        pbmih->biYPelsPerMeter = (LONG)(dpi * 100 / 2.54 + 0.5);\r\n    }\r\n\r\n    if (bm.bmBitsPixel < 16)\r\n        cColors = 1 << bm.bmBitsPixel;\r\n    else\r\n        cColors = 0;\r\n\r\n    cbColors = cColors * sizeof(RGBQUAD);\r\n    bf.bfType = 0x4d42;\r\n    bf.bfReserved1 = 0;\r\n    bf.bfReserved2 = 0;\r\n    cb = sizeof(BITMAPFILEHEADER) + pbmih->biSize + cbColors;\r\n    bf.bfOffBits = cb;\r\n    bf.bfSize = cb + pbmih->biSizeImage;\r\n\r\n    pvBits = malloc(pbmih->biSizeImage);\r\n    if (pvBits == NULL)\r\n    {\r\n        CloseHandle(hFile);\r\n        return FALSE;\r\n    }\r\n\r\n    bOK = FALSE;\r\n    hDC = CreateCompatibleDC(NULL);\r\n    if (GetDIBits(hDC, hbm, 0, bm.bmHeight, pvBits, (BITMAPINFO*)&bi,\r\n                  DIB_RGB_COLORS))\r\n    {\r\n        bOK = WriteFile(hFile, &bf, sizeof(BITMAPFILEHEADER), &cb, NULL) &&\r\n              WriteFile(hFile, &bi, sizeof(BITMAPINFOHEADER), &cb, NULL) &&\r\n              WriteFile(hFile, bi.bi.bmiColors, cbColors, &cb, NULL) &&\r\n              WriteFile(hFile, pvBits, pbmih->biSizeImage, &cb, NULL);\r\n    }\r\n    DeleteDC(hDC);\r\n    free(pvBits);\r\n    if (!CloseHandle(hFile))\r\n        bOK = FALSE;\r\n    return bOK;\r\n}\r\n\r\ninline BOOL\r\nSaveBitmapToFileDx(LPCTSTR pszFileName, HBITMAP hbm, FLOAT dpi/* = 0.0*/)\r\n{\r\n    HANDLE hFile;\r\n    hFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,\r\n                       CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL |\r\n                       FILE_FLAG_WRITE_THROUGH, NULL);\r\n    if (hFile != INVALID_HANDLE_VALUE)\r\n    {\r\n        if (SaveBitmapCommonDx(hFile, hbm, dpi))\r\n        {\r\n            return TRUE;\r\n        }\r\n        DeleteFile(pszFileName);\r\n    }\r\n    return false;\r\n}\r\n\r\ninline HBITMAP\r\nRotateBitmapTo32BppDx(HBITMAP hbmSrc, DOUBLE angle, BOOL fGrow/* = TRUE*/)\r\n{\r\n    HDC hdc;\r\n    HBITMAP hbm;\r\n    BITMAP bm;\r\n    BITMAPINFO bi;\r\n    LPBYTE pbBits, pbBitsSrc;\r\n    UINT widthbytes, widthbytesSrc;\r\n    INT cost, sint;\r\n    INT cx, cy, x0, x1, y0, y1, px, py, qx, qy;\r\n    BYTE r0, g0, b0, a0, r1, g1, b1, a1;\r\n    INT mx, my;\r\n    INT x, y, ex0, ey0, ex1, ey1;\r\n    using namespace std;\r\n\r\n    if (!GetObject(hbmSrc, sizeof(bm), &bm))\r\n        return NULL;\r\n\r\n    if (fGrow)\r\n    {\r\n        cx = (INT)(fabs(bm.bmWidth * cos(angle)) + fabs(bm.bmHeight * sin(angle)) + 0.5);\r\n        cy = (INT)(fabs(bm.bmWidth * sin(angle)) + fabs(bm.bmHeight * cos(angle)) + 0.5);\r\n    }\r\n    else\r\n    {\r\n        cx = bm.bmWidth;\r\n        cy = bm.bmHeight;\r\n    }\r\n\r\n    ZeroMemory(&bi.bmiHeader, sizeof(BITMAPINFOHEADER));\r\n    bi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);\r\n    bi.bmiHeader.biWidth    = cx;\r\n    bi.bmiHeader.biHeight   = cy;\r\n    bi.bmiHeader.biPlanes   = 1;\r\n    bi.bmiHeader.biBitCount = 32;\r\n\r\n    widthbytesSrc = (bm.bmWidth << 2);\r\n    widthbytes = (cx << 2);\r\n\r\n    do\r\n    {\r\n        hdc = CreateCompatibleDC(NULL);\r\n        if (hdc != NULL)\r\n        {\r\n            hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (VOID **)&pbBits,\r\n                                   NULL, 0);\r\n            if (hbm != NULL)\r\n            {\r\n                pbBitsSrc = (LPBYTE)malloc(widthbytesSrc * bm.bmHeight);\r\n                if (pbBitsSrc != NULL)\r\n                    break;\r\n                DeleteObject(hbm);\r\n            }\r\n            DeleteDC(hdc);\r\n        }\r\n        return NULL;\r\n    } while (0);\r\n\r\n    px = (bm.bmWidth - 1) << 15;\r\n    py = (bm.bmHeight - 1) << 15;\r\n    qx = (cx - 1) << 7;\r\n    qy = (cy - 1) << 7;\r\n    cost = (INT)(cos(angle) * 256);\r\n    sint = (INT)(sin(angle) * 256);\r\n    bi.bmiHeader.biWidth    = bm.bmWidth;\r\n    bi.bmiHeader.biHeight   = bm.bmHeight;\r\n    GetDIBits(hdc, hbmSrc, 0, bm.bmHeight, pbBitsSrc, &bi, DIB_RGB_COLORS);\r\n    if (bm.bmBitsPixel < 32)\r\n    {\r\n        UINT cdw = bm.bmWidth * bm.bmHeight;\r\n        LPBYTE pb = pbBitsSrc;\r\n        while (cdw--)\r\n        {\r\n            pb++;\r\n            pb++;\r\n            pb++;\r\n            *pb++ = 0xFF;\r\n        }\r\n    }\r\n    ZeroMemory(pbBits, widthbytes * cy);\r\n\r\n    x = (0 - qx) * cost + (0 - qy) * sint + px;\r\n    y = -(0 - qx) * sint + (0 - qy) * cost + py;\r\n    for (my = 0; my < cy; my++)\r\n    {\r\n        /* x = (0 - qx) * cost + ((my << 8) - qy) * sint + px; */\r\n        /* y = -(0 - qx) * sint + ((my << 8) - qy) * cost + py; */\r\n        for (mx = 0; mx < cx; mx++)\r\n        {\r\n            /* x = ((mx << 8) - qx) * cost + ((my << 8) - qy) * sint + px; */\r\n            /* y = -((mx << 8) - qx) * sint + ((my << 8) - qy) * cost + py; */\r\n            x0 = x >> 16;\r\n            x1 = std::min(x0 + 1, (INT)bm.bmWidth - 1);\r\n            ex1 = x & 0xFFFF;\r\n            ex0 = 0x10000 - ex1;\r\n            y0 = y >> 16;\r\n            y1 = std::min(y0 + 1, (INT)bm.bmHeight - 1);\r\n            ey1 = y & 0xFFFF;\r\n            ey0 = 0x10000 - ey1;\r\n            if (0 <= x0 && x0 < bm.bmWidth && 0 <= y0 && y0 < bm.bmHeight)\r\n            {\r\n                DWORD c00 = *(DWORD *)&pbBitsSrc[(x0 << 2) + y0 * widthbytesSrc];\r\n                DWORD c01 = *(DWORD *)&pbBitsSrc[(x0 << 2) + y1 * widthbytesSrc];\r\n                DWORD c10 = *(DWORD *)&pbBitsSrc[(x1 << 2) + y0 * widthbytesSrc];\r\n                DWORD c11 = *(DWORD *)&pbBitsSrc[(x1 << 2) + y1 * widthbytesSrc];\r\n                b0 = (BYTE)(((ex0 * (c00 & 0xFF)) + (ex1 * (c10 & 0xFF))) >> 16);\r\n                b1 = (BYTE)(((ex0 * (c01 & 0xFF)) + (ex1 * (c11 & 0xFF))) >> 16);\r\n                g0 = (BYTE)(((ex0 * ((c00 >> 8) & 0xFF)) + (ex1 * ((c10 >> 8) & 0xFF))) >> 16);\r\n                g1 = (BYTE)(((ex0 * ((c01 >> 8) & 0xFF)) + (ex1 * ((c11 >> 8) & 0xFF))) >> 16);\r\n                r0 = (BYTE)(((ex0 * ((c00 >> 16) & 0xFF)) + (ex1 * ((c10 >> 16) & 0xFF))) >> 16);\r\n                r1 = (BYTE)(((ex0 * ((c01 >> 16) & 0xFF)) + (ex1 * ((c11 >> 16) & 0xFF))) >> 16);\r\n                a0 = (BYTE)(((ex0 * ((c00 >> 24) & 0xFF)) + (ex1 * ((c10 >> 24) & 0xFF))) >> 16);\r\n                a1 = (BYTE)(((ex0 * ((c01 >> 24) & 0xFF)) + (ex1 * ((c11 >> 24) & 0xFF))) >> 16);\r\n                b0 = (ey0 * b0 + ey1 * b1) >> 16;\r\n                g0 = (ey0 * g0 + ey1 * g1) >> 16;\r\n                r0 = (ey0 * r0 + ey1 * r1) >> 16;\r\n                a0 = (ey0 * a0 + ey1 * a1) >> 16;\r\n                *(DWORD *)&pbBits[(mx << 2) + my * widthbytes] =\r\n                    MAKELONG(MAKEWORD(b0, g0), MAKEWORD(r0, a0));\r\n            }\r\n            x += cost << 8;\r\n            y -= sint << 8;\r\n        }\r\n        x -= cx * cost << 8;\r\n        x += sint << 8;\r\n        y -= -cx * sint << 8;\r\n        y += cost << 8;\r\n    }\r\n    free(pbBitsSrc);\r\n    DeleteDC(hdc);\r\n    return hbm;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MBITMAP_HPP_\r\n
MBrush.hpp<>MBrush.hpp<>// MBrush.hpp -- Win32API brush object wrapper                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MBRUSH_HPP_\r\n#define MZC4_MBRUSH_HPP_        4   /* Version 4 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n\r\nclass MBrush : public MGdiObject\r\n{\r\npublic:\r\n    MBrush();\r\n    MBrush(HBRUSH hBrush);\r\n    MBrush(COLORREF crColor);\r\n    MBrush(const MBrush& br);\r\n    MBrush& operator=(HBRUSH hBrush);\r\n    MBrush& operator=(const MBrush& brush);\r\n\r\n    operator HBRUSH() const;\r\n    HBRUSH Handle() const;\r\n\r\n    INT GetLogBrush(LOGBRUSH *lplb) const;\r\n\r\n    BOOL Attach(HBRUSH hBrush);\r\n    HBRUSH Detach(VOID);\r\n\r\n    BOOL CreateBrushIndirect(CONST LOGBRUSH *lplb);\r\n    BOOL CreateSolidBrush(COLORREF crColor);\r\n    BOOL CreatePatternBrush(HBITMAP hbm8x8);\r\n    BOOL CreateHatchBrush(INT fnHS_Style, COLORREF crColor = RGB(0, 0, 0));\r\n    BOOL CreateDIBPatternBrushPt(CONST VOID *lpPackedDIB,\r\n        UINT iUsage = DIB_RGB_COLORS);\r\n    BOOL CreateSysColorBrush(INT nCOLOR_index);\r\n    BOOL CreateHalftoneBrush();\r\n    BOOL CreateBlackBrush();\r\n    BOOL CreateDkGrayBrush();\r\n    BOOL CreateGrayBrush();\r\n    BOOL CreateLtGrayBrush();\r\n    BOOL CreateWhiteBrush();\r\n    BOOL CreateNullBrush();\r\n\r\n    static HBRUSH CloneHandleDx(HBRUSH hBrush);\r\n};\r\n\r\nHBRUSH CreateHalftoneBrushDx(VOID);\r\nHBRUSH CreateBlackBrushDx();\r\nHBRUSH CreateWhiteBrushDx();\r\nHBRUSH CreateNullBrushDx();\r\nHBRUSH CreateDkGrayBrushDx();\r\nHBRUSH CreateGrayBrushDx();\r\nHBRUSH CreateLtGrayBrushDx();\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ HBRUSH MBrush::CloneHandleDx(HBRUSH hBrush)\r\n{\r\n    if (hBrush == NULL)\r\n        return NULL;\r\n\r\n    LOGBRUSH lb;\r\n    ::GetObject(hBrush, sizeof(LOGBRUSH), &lb);\r\n    return ::CreateBrushIndirect(&lb);\r\n}\r\n\r\ninline MBrush::MBrush()\r\n{\r\n}\r\n\r\ninline MBrush::MBrush(HBRUSH hBrush) : MGdiObject(hBrush)\r\n{\r\n}\r\n\r\ninline MBrush::MBrush(COLORREF crColor)\r\n{\r\n    CreateSolidBrush(crColor);\r\n}\r\n\r\ninline MBrush::MBrush(const MBrush& br) : MGdiObject(CloneHandleDx(br))\r\n{\r\n}\r\n\r\ninline MBrush::operator HBRUSH() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline HBRUSH MBrush::Handle() const\r\n{\r\n    return (this ? (HBRUSH)m_hGdiObj : NULL);\r\n}\r\n\r\ninline INT MBrush::GetLogBrush(LOGBRUSH *lplb) const\r\n{\r\n    assert(Handle());\r\n    return ::GetObject(Handle(), sizeof(LOGBRUSH), lplb);\r\n}\r\n\r\ninline MBrush& MBrush::operator=(HBRUSH hBrush)\r\n{\r\n    assert(::GetObjectType(hBrush) == OBJ_BRUSH);\r\n    if (Handle() != hBrush)\r\n    {\r\n        Attach(hBrush);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MBrush& MBrush::operator=(const MBrush& brush)\r\n{\r\n    assert(::GetObjectType(brush.Handle()) == OBJ_BRUSH);\r\n    if (Handle() != brush.Handle())\r\n    {\r\n        HBRUSH hbr = CloneHandleDx(brush);\r\n        Attach(hbr);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MBrush::Attach(HBRUSH hBrush)\r\n{\r\n    assert(::GetObjectType(hBrush) == OBJ_BRUSH);\r\n    return MGdiObject::Attach(hBrush);\r\n}\r\n\r\ninline HBRUSH MBrush::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HBRUSH>(MGdiObject::Detach());\r\n}\r\n\r\ninline BOOL MBrush::CreateBrushIndirect(CONST LOGBRUSH *lplb)\r\n{\r\n    return Attach(::CreateBrushIndirect(lplb));\r\n}\r\n\r\ninline BOOL MBrush::CreateSolidBrush(COLORREF crColor)\r\n{\r\n    return Attach(::CreateSolidBrush(crColor));\r\n}\r\n\r\ninline BOOL MBrush::CreatePatternBrush(HBITMAP hbm8x8)\r\n{\r\n    return Attach(::CreatePatternBrush(hbm8x8));\r\n}\r\n\r\ninline BOOL MBrush::CreateHatchBrush(\r\n    INT fnHS_Style, COLORREF crColor/* = RGB(0, 0, 0)*/)\r\n{\r\n    return Attach(::CreateHatchBrush(fnHS_Style, crColor));\r\n}\r\n\r\ninline BOOL MBrush::CreateDIBPatternBrushPt(\r\n    CONST VOID *lpPackedDIB, UINT iUsage/* = DIB_RGB_COLORS*/)\r\n{\r\n    return Attach(::CreateDIBPatternBrushPt(lpPackedDIB, iUsage));\r\n}\r\n\r\ninline BOOL MBrush::CreateSysColorBrush(INT nCOLOR_index)\r\n{\r\n    return Attach(::GetSysColorBrush(nCOLOR_index));\r\n}\r\n\r\ninline BOOL MBrush::CreateHalftoneBrush()\r\n{\r\n    return Attach(CreateHalftoneBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateBlackBrush()\r\n{\r\n    return Attach(CreateBlackBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateDkGrayBrush()\r\n{\r\n    return Attach(CreateDkGrayBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateGrayBrush()\r\n{\r\n    return Attach(CreateGrayBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateLtGrayBrush()\r\n{\r\n    return Attach(CreateLtGrayBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateWhiteBrush()\r\n{\r\n    return Attach(CreateWhiteBrushDx());\r\n}\r\n\r\ninline BOOL MBrush::CreateNullBrush()\r\n{\r\n    return Attach(CreateNullBrushDx());\r\n}\r\n\r\ninline HBRUSH CreateHalftoneBrushDx(VOID)\r\n{\r\n    WORD grayPattern[8];\r\n    for (INT i = 0; i < 8; i++)\r\n        grayPattern[i] = (WORD)(0x5555 << (i & 1));\r\n\r\n    HBRUSH hbr = NULL;\r\n    HBITMAP grayBitmap = ::CreateBitmap(8, 8, 1, 1, &grayPattern);\r\n    if (grayBitmap != NULL)\r\n    {\r\n        hbr = ::CreatePatternBrush(grayBitmap);\r\n        ::DeleteObject(grayBitmap);\r\n    }\r\n\r\n    assert(hbr);\r\n    return hbr;\r\n}\r\n\r\ninline HBRUSH CreateBlackBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(BLACK_BRUSH);\r\n}\r\n\r\ninline HBRUSH CreateWhiteBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(WHITE_BRUSH);\r\n}\r\n\r\ninline HBRUSH CreateNullBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(NULL_BRUSH);\r\n}\r\n\r\ninline HBRUSH CreateDkGrayBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(DKGRAY_BRUSH);\r\n}\r\n\r\ninline HBRUSH CreateGrayBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(GRAY_BRUSH);\r\n}\r\n\r\ninline HBRUSH CreateLtGrayBrushDx()\r\n{\r\n    return (HBRUSH)::GetStockObject(LTGRAY_BRUSH);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MBRUSH_HPP_\r\n
MButton.hpp<>MButton.hpp<>// MAccel.hpp -- Win32API button wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MBUTTON_HPP_\r\n#define MZC4_MBUTTON_HPP_       2   /* Version 2 */\r\n\r\nclass MButton;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MButton : public MWindowBase\r\n{\r\npublic:\r\n    MButton();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    UINT GetState() const;\r\n    VOID SetState(BOOL bHighlight);\r\n\r\n    INT  GetCheck() const;\r\n    VOID SetCheck(INT nBST_);\r\n\r\n    UINT GetButtonStyle() const;\r\n    VOID SetButtonStyle(UINT nBS_flags, BOOL bRedraw = TRUE);\r\n\r\n    HICON GetIcon() const;\r\n    HICON SetIcon(HICON hIcon);\r\n\r\n    HBITMAP GetBitmap() const;\r\n    HBITMAP SetBitmap(HBITMAP hBitmap);\r\n\r\n    HCURSOR GetCursor();\r\n    HCURSOR SetCursor(HCURSOR hCursor);\r\n};\r\ntypedef MButton MRadioButton;\r\ntypedef MButton MGroupBox;\r\ntypedef MButton MCheckButton;\r\ntypedef MButton MPushButton;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MButton::MButton()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MButton::GetWndClassNameDx() const\r\n{\r\n    return TEXT("BUTTON");\r\n}\r\n\r\ninline UINT MButton::GetState() const\r\n{\r\n    return (UINT)SendMessageDx(BM_GETSTATE);\r\n}\r\n\r\ninline VOID MButton::SetState(BOOL bHighlight)\r\n{\r\n    SendMessageDx(BM_SETSTATE, (WPARAM)bHighlight);\r\n}\r\n\r\ninline INT MButton::GetCheck() const\r\n{\r\n    return (INT)SendMessageDx(BM_GETCHECK);\r\n}\r\n\r\ninline VOID MButton::SetCheck(INT nBST_)\r\n{\r\n    SendMessageDx(BM_SETCHECK, (WPARAM)nBST_);\r\n}\r\n\r\ninline UINT MButton::GetButtonStyle() const\r\n{\r\n    return (UINT)(GetStyleDx() & 0xFFFF);\r\n}\r\n\r\ninline VOID MButton::SetButtonStyle(UINT nBS_flags, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(BM_SETSTYLE, nBS_flags, bRedraw);\r\n}\r\n\r\ninline HICON MButton::SetIcon(HICON hIcon)\r\n{\r\n    return (HICON)SendMessageDx(BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);\r\n}\r\n\r\ninline HICON MButton::GetIcon() const\r\n{\r\n    return (HICON)SendMessageDx(BM_GETIMAGE, IMAGE_ICON);\r\n}\r\n\r\ninline HBITMAP MButton::SetBitmap(HBITMAP hBitmap)\r\n{\r\n    return (HBITMAP)SendMessageDx(BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);\r\n}\r\n\r\ninline HBITMAP MButton::GetBitmap() const\r\n{\r\n    return (HBITMAP)SendMessageDx(BM_GETIMAGE, IMAGE_BITMAP);\r\n}\r\n\r\ninline HCURSOR MButton::SetCursor(HCURSOR hCursor)\r\n{\r\n    return (HCURSOR)SendMessageDx(BM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);\r\n}\r\n\r\ninline HCURSOR MButton::GetCursor()\r\n{\r\n    return (HCURSOR)SendMessageDx(BM_GETIMAGE, IMAGE_CURSOR);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MBUTTON_HPP_\r\n
MByteStream.hpp<>MByteStream.hpp<>// MByteStream.hpp -- MZC4 byte stream                          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MBYTESTREAM_HPP_\r\n#define MZC4_MBYTESTREAM_HPP_       8       /* Version 8 */\r\n\r\nclass MByteStream;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    #ifndef _INC_WINDOWS\r\n        #include <windows.h>\r\n    #endif\r\n#else\r\n    #include "wondef.h"         // Wonders API\r\n    #define _unlink     unlink\r\n#endif\r\n\r\n#if __cplusplus >= 201103L          /* C++11 */\r\n    #include <cstdint>\r\n#else\r\n    #include "pstdint.h"\r\n#endif\r\n\r\n#ifndef _WIN32\r\n    #include <unistd.h>     // for unlink\r\n#endif\r\n\r\n#include "MString.hpp"\r\n\r\n#include <cstdlib>          // C standard library\r\n#include <cstdio>           // C standard I/O\r\n#include <cstring>          // C string\r\n#include <cassert>          // assert\r\n#include <vector>           // for std::vector\r\n#include <string>           // for std::string and std::wstring\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MByteStream\r\n{\r\npublic:\r\n    typedef std::vector<uint8_t> data_type;\r\n    typedef std::size_t size_type;\r\n\r\n    MByteStream() : m_pos(0)\r\n    {\r\n    }\r\n\r\n    MByteStream(size_t size) : m_pos(0)\r\n    {\r\n        m_data.resize(size);\r\n    }\r\n\r\n    MByteStream(const data_type& data) : m_pos(0), m_data(data)\r\n    {\r\n    }\r\n\r\n    MByteStream(const void *ptr, size_t size) :\r\n        m_pos(0), m_data((const uint8_t *)ptr, (const uint8_t *)ptr + size)\r\n    {\r\n    }\r\n\r\n    virtual ~MByteStream()\r\n    {\r\n    }\r\n\r\n    void assign(const void *ptr, size_t size)\r\n    {\r\n        m_data.assign((const uint8_t *)ptr, (const uint8_t *)ptr + size);\r\n    }\r\n\r\n    void assign(const void *ptr1, const void *ptr2)\r\n    {\r\n        m_data.assign((const uint8_t *)ptr1, (const uint8_t *)ptr2);\r\n    }\r\n\r\n    void clear()\r\n    {\r\n        m_pos = 0;\r\n        m_data.clear();\r\n    }\r\n\r\n    data_type& data()\r\n    {\r\n        return m_data;\r\n    }\r\n\r\n    const data_type& data() const\r\n    {\r\n        return m_data;\r\n    }\r\n\r\n    void *ptr(size_t index = 0)\r\n    {\r\n        return &m_data[index];\r\n    }\r\n    const void *ptr(size_t index = 0) const\r\n    {\r\n        return &m_data[index];\r\n    }\r\n\r\n    size_t size() const\r\n    {\r\n        return m_data.size();\r\n    }\r\n\r\n    size_t remainder() const\r\n    {\r\n        if (m_pos <= size())\r\n            return size() - m_pos;\r\n        return 0;\r\n    }\r\n\r\n    size_t pos() const\r\n    {\r\n        return m_pos;\r\n    }\r\n    void pos(size_t pos_) const\r\n    {\r\n        m_pos = pos_;\r\n    }\r\n\r\n    bool seek(int16_t delta) const\r\n    {\r\n        if (delta > 0)\r\n        {\r\n            if (m_pos + delta <= size())\r\n            {\r\n                m_pos += delta;\r\n                return true;\r\n            }\r\n        }\r\n        else if (delta < 0)\r\n        {\r\n            if (m_pos + delta >= 0)\r\n            {\r\n                m_pos += delta;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    template <typename T>\r\n    bool WriteRaw(const T& data)\r\n    {\r\n        return WriteData(&data, sizeof(T));\r\n    }\r\n\r\n    bool WriteData(const void *data, size_t nSize)\r\n    {\r\n        if (data && nSize)\r\n        {\r\n            size_t old_size = size();\r\n            m_data.resize(old_size + nSize);\r\n            memcpy(&m_data[old_size], data, nSize);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool WriteByte(uint8_t value)\r\n    {\r\n        uint8_t b = value;\r\n        return WriteData(&b, sizeof(b));\r\n    }\r\n\r\n    bool WriteWord(uint16_t value)\r\n    {\r\n        uint16_t w = value;\r\n        return WriteData(&w, sizeof(w));\r\n    }\r\n\r\n    void WriteWordAlignment()\r\n    {\r\n        if (m_data.size() & 1)\r\n            m_data.resize(m_data.size() + 1);\r\n    }\r\n\r\n    bool WriteDword(uint32_t value)\r\n    {\r\n        uint32_t dw = value;\r\n        return WriteData(&dw, sizeof(dw));\r\n    }\r\n\r\n    void WriteDwordAlignment()\r\n    {\r\n        size_t n = (m_data.size() & 3);\r\n        if (n)\r\n        {\r\n            m_data.resize(m_data.size() + (4 - n));\r\n        }\r\n    }\r\n\r\n    template <typename T>\r\n    bool ReadRaw(T& value) const\r\n    {\r\n        return ReadData(&value, sizeof(T));\r\n    }\r\n\r\n    bool ReadData(void *data, size_t nSize) const\r\n    {\r\n        if (m_pos + nSize <= size())\r\n        {\r\n            if (nSize)\r\n            {\r\n                memcpy(data, &m_data[m_pos], nSize);\r\n                m_pos += nSize;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool ReadByte(uint8_t& b) const\r\n    {\r\n        return ReadData(&b, sizeof(b));\r\n    }\r\n\r\n    bool ReadByte(char& b) const\r\n    {\r\n        return ReadData(&b, sizeof(b));\r\n    }\r\n\r\n    bool ReadWord(uint16_t& w) const\r\n    {\r\n        return ReadData(&w, sizeof(w));\r\n    }\r\n\r\n    bool ReadWord(int16_t& w) const\r\n    {\r\n        return ReadData(&w, sizeof(w));\r\n    }\r\n\r\n    bool ReadDword(uint32_t& dw) const\r\n    {\r\n        return ReadData(&dw, sizeof(dw));\r\n    }\r\n\r\n    bool ReadDword(int32_t& n) const\r\n    {\r\n        return ReadData(&n, sizeof(n));\r\n    }\r\n\r\n    bool PeekWord(uint16_t& w) const\r\n    {\r\n        size_t nSize = sizeof(uint16_t);\r\n        if (m_pos + nSize <= size())\r\n        {\r\n            memcpy(&w, &m_data[m_pos], nSize);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool PeekByte(uint8_t& b) const\r\n    {\r\n        size_t nSize = sizeof(uint8_t);\r\n        if (m_pos + nSize <= size())\r\n        {\r\n            memcpy(&b, &m_data[m_pos], nSize);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    void ReadWordAlignment() const\r\n    {\r\n        if (m_pos & 1)\r\n            ++m_pos;\r\n    }\r\n\r\n    void ReadDwordAlignment() const\r\n    {\r\n        size_t mod = (m_pos & 3);\r\n        if (mod)\r\n            m_pos += 4 - mod;\r\n    }\r\n\r\n    bool LoadFromFile(const TCHAR *FileName)\r\n    {\r\n        m_pos = 0;\r\n        m_data.clear();\r\n\r\n        FILE *fp;\r\n#ifdef UNICODE\r\n        _wfopen_s(&fp, FileName, L"rb");\r\n#elif defined(_WIN32)\r\n        fopen_s(&fp, FileName, "rb");\r\n#else\r\n        fp = fopen(FileName, "rb");\r\n#endif\r\n        if (!fp)\r\n            return false;\r\n\r\n        bool ok = true;\r\n        uint8_t buf[512];\r\n        for (;;)\r\n        {\r\n            size_t size = fread(buf, 1, 512, fp);\r\n            if (size == 0)\r\n            {\r\n                if (ferror(fp))\r\n                    ok = false;\r\n                break;\r\n            }\r\n\r\n            m_data.insert(m_data.end(), &buf[0], &buf[size]);\r\n        }\r\n\r\n        fclose(fp);\r\n\r\n        return ok;\r\n    }\r\n\r\n    bool SaveToFile(const TCHAR *FileName) const\r\n    {\r\n        FILE *fp;\r\n#ifdef UNICODE\r\n        _wfopen_s(&fp, FileName, L"wb");\r\n#elif defined(_WIN32)\r\n        fopen_s(&fp, FileName, "wb");\r\n#else\r\n        fp = fopen(FileName, "wb");\r\n#endif\r\n        if (!fp)\r\n            return false;\r\n\r\n        size_t n = fwrite(&m_data[0], m_data.size(), 1, fp);\r\n        fclose(fp);\r\n\r\n        if (!n)\r\n        {\r\n#ifdef UNICODE\r\n            _wremove(FileName);\r\n#else\r\n            _unlink(FileName);\r\n#endif\r\n        }\r\n\r\n        return n != 0;\r\n    }\r\n\r\n    uint8_t& operator[](size_t index)\r\n    {\r\n        return m_data[index];\r\n    }\r\n    const uint8_t& operator[](size_t index) const\r\n    {\r\n        return m_data[index];\r\n    }\r\n\r\n    bool ReadSz(MStringA& str) const\r\n    {\r\n        str.clear();\r\n        uint8_t b;\r\n        while (ReadByte(b))\r\n        {\r\n            if (b == 0)\r\n                return true;\r\n            str += b;\r\n        }\r\n        return false;\r\n    }\r\n    bool WriteSz(const MStringA& str)\r\n    {\r\n        return WriteData(&str[0], (str.size() + 1) * sizeof(char));\r\n    }\r\n\r\n    bool ReadSz(MStringW& str) const\r\n    {\r\n        str.clear();\r\n        uint16_t w;\r\n        while (ReadWord(w))\r\n        {\r\n            if (w == 0)\r\n                return true;\r\n            str += (WCHAR)w;\r\n        }\r\n        return false;\r\n    }\r\n    bool WriteSz(const MStringW& str)\r\n    {\r\n        return WriteData(&str[0], (str.size() + 1) * sizeof(WCHAR));\r\n    }\r\n\r\nprotected:\r\n    mutable size_type   m_pos;\r\n    data_type           m_data;\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MBYTESTREAM_HPP_\r\n
MByteStreamEx.hpp<>MByteStreamEx.hpp<>// MByteStream.hpp -- MZC4 byte stream                          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MBYTESTREAMEX_HPP_\r\n#define MZC4_MBYTESTREAMEX_HPP_     3       /* Version 3 */\r\n\r\nclass MByteStreamEx;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MByteStream.hpp"\r\n#include "MIdOrString.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MByteStreamEx : public MByteStream\r\n{\r\npublic:\r\n    MByteStreamEx()\r\n    {\r\n    }\r\n\r\n    MByteStreamEx(size_t size) : MByteStream(size)\r\n    {\r\n        m_data.resize(size);\r\n    }\r\n\r\n    MByteStreamEx(const data_type& data) : MByteStream(data)\r\n    {\r\n    }\r\n\r\n    MByteStreamEx(const void *ptr, size_t size) : MByteStream(ptr, size)\r\n    {\r\n    }\r\n\r\n    BOOL ReadID(MIdOrString& id_or_str) const\r\n    {\r\n        WORD w;\r\n        if (!PeekWord(w))\r\n            return FALSE;\r\n\r\n        if (w == 0xFFFF)\r\n        {\r\n            ReadWord(w);\r\n            if (ReadWord(w))\r\n            {\r\n                id_or_str = w;\r\n                return TRUE;\r\n            }\r\n            return FALSE;\r\n        }\r\n\r\n        id_or_str.m_id = 0;\r\n        return ReadSz(id_or_str.m_str);\r\n    }\r\n\r\n    BOOL WriteID(const MIdOrString& id_or_str)\r\n    {\r\n        if (id_or_str.is_str())\r\n        {\r\n            return WriteSz(id_or_str.m_str);\r\n        }\r\n        return WriteWord(0xFFFF) && WriteWord(id_or_str.m_id);\r\n    }\r\n\r\n    BOOL ReadString(MIdOrString& id_or_str) const\r\n    {\r\n        WORD w;\r\n        if (!PeekWord(w))\r\n            return FALSE;\r\n\r\n        if (w == 0)\r\n        {\r\n            ReadWord(w);\r\n            id_or_str.clear();\r\n            return TRUE;\r\n        }\r\n\r\n        if (w == 0xFFFF)\r\n        {\r\n            WORD w;\r\n            if (!ReadWord(w) || !ReadWord(w))\r\n                return FALSE;\r\n            id_or_str = w;\r\n            return TRUE;\r\n        }\r\n\r\n        id_or_str.m_id = 0;\r\n        return ReadSz(id_or_str.m_str);\r\n    }\r\n\r\n    BOOL WriteString(const WCHAR *psz)\r\n    {\r\n        if (psz == NULL)\r\n        {\r\n            return WriteWord(0);\r\n        }\r\n        if (IS_INTRESOURCE(psz))\r\n        {\r\n            WORD aw[2];\r\n            aw[0] = 0xFFFF;\r\n            aw[1] = LOWORD(psz);\r\n            return WriteRaw(aw);\r\n        }\r\n        return WriteData(psz, (mstrlen(psz) + 1) * sizeof(WCHAR));\r\n    }\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MBYTESTREAMEX_HPP_\r\n
MColorDialog.hpp<>MColorDialog.hpp<>// MColorDialog.hpp -- MZC4 color dialog wrapper                -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOLORDIALOG_HPP_\r\n#define MZC4_MCOLORDIALOG_HPP_      2       /* Version 2 */\r\n\r\nclass MColorDialog;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCommonDialog.hpp"\r\n\r\nclass MColorDialog : public MCommonDialog\r\n{\r\npublic:\r\n    CHOOSECOLOR m_cc;\r\n\r\n    // before main\r\n    MColorDialog(HWND hwndOwner, COLORREF clrInit = RGB(0, 0, 0),\r\n                 DWORD dwCC_ = 0);\r\n\r\n    // main\r\n    BOOL ChooseColor();\r\n\r\n    // after main\r\n    COLORREF GetColor() const;\r\n\r\n    VOID SetColor(COLORREF clr);\r\n\r\n    static COLORREF *GetSavedCustomColors();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMColorDialog::MColorDialog(HWND hwndOwner,\r\n                           COLORREF clrInit/* = RGB(0, 0, 0)*/,\r\n                           DWORD dwCC_/* = 0*/)\r\n    : MCommonDialog(hwndOwner)\r\n{\r\n    m_bModal = TRUE;\r\n\r\n    ZeroMemory(&m_cc, sizeof(m_cc));\r\n    m_cc.lStructSize = sizeof(CHOOSECOLOR);\r\n    m_cc.hwndOwner = hwndOwner;\r\n    m_cc.rgbResult = clrInit;\r\n    m_cc.lpCustColors = GetSavedCustomColors();\r\n    m_cc.Flags = dwCC_ | CC_RGBINIT;\r\n}\r\n\r\ninline /*virtual*/ BOOL MColorDialog::ChooseColor()\r\n{\r\n    return ::ChooseColor(&m_cc);\r\n}\r\n\r\ninline COLORREF MColorDialog::GetColor() const\r\n{\r\n    return m_cc.rgbResult;\r\n}\r\n\r\ninline VOID MColorDialog::SetColor(COLORREF clr)\r\n{\r\n    m_cc.rgbResult = clr;\r\n}\r\n\r\ninline /*static*/ COLORREF *MColorDialog::GetSavedCustomColors()\r\n{\r\n    static COLORREF s_colors[16] =\r\n    {\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF),\r\n        RGB(0xFF, 0xFF, 0xFF)\r\n    };\r\n    return s_colors;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOLORDIALOG_HPP_\r\n
MComboBox.hpp<>MComboBox.hpp<>// MComboBox.hpp -- Win32API combo box wrapper                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOMBOBOX_HPP_\r\n#define MZC4_MCOMBOBOX_HPP_     2   /* Version 2 */\r\n\r\nclass MComboBox;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MComboBox : public MWindowBase\r\n{\r\npublic:\r\n    MComboBox();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetCount() const;\r\n    INT GetCurSel() const;\r\n    INT SetCurSel(INT nSelect);\r\n    LCID GetLocale() const;\r\n    LCID SetLocale(LCID nNewLocale);\r\n\r\n    INT  GetTopIndex() const;\r\n    INT  SetTopIndex(INT nIndex);\r\n    INT  InitStorage(INT nItems, UINT nBytes);\r\n    VOID SetHorizontalExtent(UINT nExtent);\r\n    UINT GetHorizontalExtent() const;\r\n\r\n    INT  SetDroppedWidth(UINT nWidth);\r\n    INT  GetDroppedWidth() const;\r\n\r\n    DWORD GetEditSel() const;\r\n    BOOL  LimitText(INT nMaxChars);\r\n    BOOL  SetEditSel(INT nStartChar, INT nEndChar);\r\n    VOID SelectAll();\r\n    VOID SelectNone();\r\n\r\n    DWORD GetItemData(INT nIndex) const;\r\n    INT   SetItemData(INT nIndex, DWORD dwItemData);\r\n    LPVOID GetItemDataPtr(INT nIndex) const;\r\n    INT    SetItemDataPtr(INT nIndex, LPVOID pData);\r\n\r\n    INT  GetLBText(INT nIndex, LPTSTR lpszText) const;\r\n    BOOL GetLBText(INT nIndex, MString& rString) const;\r\n    INT  GetLBTextLen(INT nIndex) const;\r\n\r\n    INT GetItemHeight(INT nIndex) const;\r\n    INT SetItemHeight(INT nIndex, UINT cyItemHeight);\r\n\r\n    INT FindString(INT nStartAfter, LPCTSTR lpszString) const;\r\n    INT FindStringExact(INT nIndexStart, LPCTSTR lpszFind) const;\r\n    INT SelectString(INT nStartAfter, LPCTSTR lpszString);\r\n\r\n    BOOL GetExtendedUI() const;\r\n    INT  SetExtendedUI(BOOL bExtended = TRUE);\r\n\r\n    VOID GetDroppedControlRect(LPRECT lprect) const;\r\n    BOOL GetDroppedState() const;\r\n\r\n    VOID ShowDropDown(BOOL bShowIt = TRUE);\r\n\r\n    INT  AddString(LPCTSTR lpszString);\r\n    INT  DeleteString(UINT nIndex);\r\n    INT  InsertString(INT nIndex, LPCTSTR lpszString);\r\n    VOID ResetContent();\r\n    INT  Dir(UINT attr, LPCTSTR lpszWildCard);\r\n\r\n    VOID Clear();\r\n    VOID Copy();\r\n    VOID Cut();\r\n    VOID Paste();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MComboBox::MComboBox()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MComboBox::GetWndClassNameDx() const\r\n{\r\n    return TEXT("COMBOBOX");\r\n}\r\n\r\ninline INT MComboBox::GetCount() const\r\n{\r\n    return (INT)SendMessageDx(CB_GETCOUNT);\r\n}\r\n\r\ninline INT MComboBox::GetCurSel() const\r\n{\r\n    return (INT)SendMessageDx(CB_GETCURSEL);\r\n}\r\n\r\ninline INT MComboBox::SetCurSel(INT nSelect)\r\n{\r\n    return (INT)SendMessageDx(CB_SETCURSEL, (WPARAM)nSelect);\r\n}\r\n\r\ninline LCID MComboBox::GetLocale() const\r\n{\r\n    return (LCID)SendMessageDx(CB_GETLOCALE);\r\n}\r\n\r\ninline LCID MComboBox::SetLocale(LCID nNewLocale)\r\n{\r\n    return (LCID)SendMessageDx(CB_SETLOCALE, nNewLocale);\r\n}\r\n\r\ninline INT MComboBox::GetTopIndex() const\r\n{\r\n    return (INT)SendMessageDx(CB_GETTOPINDEX);\r\n}\r\n\r\ninline INT MComboBox::SetTopIndex(INT nIndex)\r\n{\r\n    return (INT)SendMessageDx(CB_SETTOPINDEX, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::InitStorage(INT nItems, UINT nBytes)\r\n{\r\n    return (INT)SendMessageDx(CB_INITSTORAGE, (WPARAM)nItems, (LPARAM)nBytes);\r\n}\r\n\r\ninline VOID MComboBox::SetHorizontalExtent(UINT nExtent)\r\n{\r\n    SendMessageDx(CB_SETHORIZONTALEXTENT, nExtent);\r\n}\r\n\r\ninline UINT MComboBox::GetHorizontalExtent() const\r\n{\r\n    return (UINT)SendMessageDx(CB_GETHORIZONTALEXTENT);\r\n}\r\n\r\ninline INT MComboBox::SetDroppedWidth(UINT nWidth)\r\n{\r\n    return (INT)SendMessageDx(CB_SETDROPPEDWIDTH, nWidth);\r\n}\r\n\r\ninline INT MComboBox::GetDroppedWidth() const\r\n{\r\n    return (INT)SendMessageDx(CB_GETDROPPEDWIDTH);\r\n}\r\n\r\ninline DWORD MComboBox::GetEditSel() const\r\n{\r\n    return (DWORD)SendMessageDx(CB_GETEDITSEL);\r\n}\r\n\r\ninline BOOL MComboBox::LimitText(INT nMaxChars)\r\n{\r\n    return (BOOL)SendMessageDx(CB_LIMITTEXT, (WPARAM)nMaxChars);\r\n}\r\n\r\ninline BOOL MComboBox::SetEditSel(INT nStartChar, INT nEndChar)\r\n{\r\n    return (BOOL)SendMessageDx(CB_SETEDITSEL, 0,\r\n                                MAKELPARAM(nStartChar, nEndChar));\r\n}\r\n\r\ninline VOID MComboBox::SelectAll()\r\n{\r\n    SetEditSel(0, -1);\r\n}\r\n\r\ninline VOID MComboBox::SelectNone()\r\n{\r\n    SetEditSel(-1, -1);\r\n}\r\n\r\ninline DWORD MComboBox::GetItemData(INT nIndex) const\r\n{\r\n    return (DWORD)SendMessageDx(CB_GETITEMDATA, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::SetItemData(INT nIndex, DWORD dwItemData)\r\n{\r\n    return (INT)SendMessageDx(CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)dwItemData);\r\n}\r\n\r\ninline LPVOID MComboBox::GetItemDataPtr(INT nIndex) const\r\n{\r\n    return (LPVOID)SendMessageDx(CB_GETITEMDATA, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::SetItemDataPtr(INT nIndex, LPVOID pData)\r\n{\r\n    return (INT)SendMessageDx(CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pData);\r\n}\r\n\r\ninline INT MComboBox::GetLBText(INT nIndex, LPTSTR lpszText) const\r\n{\r\n    return (INT)SendMessageDx(CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)lpszText);\r\n}\r\n\r\ninline INT MComboBox::GetLBTextLen(INT nIndex) const\r\n{\r\n    return (INT)SendMessageDx(CB_GETLBTEXTLEN, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::SetItemHeight(INT nIndex, UINT cyItemHeight)\r\n{\r\n    return (INT)SendMessageDx(CB_SETITEMHEIGHT, (WPARAM)nIndex, (LPARAM)cyItemHeight);\r\n}\r\n\r\ninline INT MComboBox::GetItemHeight(INT nIndex) const\r\n{\r\n    return (INT)SendMessageDx(CB_GETITEMHEIGHT, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::FindStringExact(\r\n    INT nIndexStart, LPCTSTR lpszFind) const\r\n{\r\n    return (INT)SendMessageDx(CB_FINDSTRINGEXACT, (WPARAM)nIndexStart, (LPARAM)lpszFind);\r\n}\r\n\r\ninline INT MComboBox::SetExtendedUI(BOOL bExtended/* = TRUE*/)\r\n{\r\n    return (INT)SendMessageDx(CB_SETEXTENDEDUI, (WPARAM)bExtended);\r\n}\r\n\r\ninline BOOL MComboBox::GetExtendedUI() const\r\n{\r\n    return (BOOL)SendMessageDx(CB_GETEXTENDEDUI);\r\n}\r\n\r\ninline VOID MComboBox::GetDroppedControlRect(LPRECT lprect) const\r\n{\r\n    SendMessageDx(CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);\r\n}\r\n\r\ninline BOOL MComboBox::GetDroppedState() const\r\n{\r\n    return (BOOL)SendMessageDx(CB_GETDROPPEDSTATE);\r\n}\r\n\r\ninline VOID MComboBox::ShowDropDown(BOOL bShowIt/* = TRUE*/)\r\n{\r\n    SendMessageDx(CB_SHOWDROPDOWN, (WPARAM)bShowIt);\r\n}\r\n\r\ninline INT MComboBox::AddString(LPCTSTR lpszString)\r\n{\r\n    return (INT)SendMessageDx(CB_ADDSTRING, 0, (LPARAM)lpszString);\r\n}\r\n\r\ninline INT MComboBox::DeleteString(UINT nIndex)\r\n{\r\n    return (INT)SendMessageDx(CB_DELETESTRING, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MComboBox::InsertString(INT nIndex, LPCTSTR lpszString)\r\n{\r\n    return (INT)SendMessageDx(CB_INSERTSTRING, (WPARAM)nIndex, (LPARAM)lpszString);\r\n}\r\n\r\ninline VOID MComboBox::ResetContent()\r\n{\r\n    SendMessageDx(CB_RESETCONTENT);\r\n}\r\n\r\ninline INT MComboBox::Dir(UINT attr, LPCTSTR lpszWildCard)\r\n{\r\n    return (INT)SendMessageDx(CB_DIR, (WPARAM)attr, (LPARAM)lpszWildCard);\r\n}\r\n\r\ninline INT MComboBox::FindString(INT nStartAfter, LPCTSTR lpszString) const\r\n{\r\n    return (INT)SendMessageDx(CB_FINDSTRING, (WPARAM)nStartAfter, (LPARAM)lpszString);\r\n}\r\n\r\ninline INT MComboBox::SelectString(INT nStartAfter, LPCTSTR lpszString)\r\n{\r\n    return (INT)SendMessageDx(CB_SELECTSTRING, (WPARAM)nStartAfter, (LPARAM)lpszString);\r\n}\r\n\r\ninline VOID MComboBox::Clear()\r\n{\r\n    SendMessageDx(WM_CLEAR);\r\n}\r\n\r\ninline VOID MComboBox::Copy()\r\n{\r\n    SendMessageDx(WM_COPY);\r\n}\r\n\r\ninline VOID MComboBox::Cut()\r\n{\r\n    SendMessageDx(WM_CUT);\r\n}\r\n\r\ninline VOID MComboBox::Paste()\r\n{\r\n    SendMessageDx(WM_PASTE);\r\n}\r\n\r\ninline BOOL MComboBox::GetLBText(INT nIndex, MString& rString) const\r\n{\r\n    rString.clear();\r\n\r\n    INT cch = GetLBTextLen(nIndex);\r\n    if (cch == CB_ERR)\r\n        return FALSE;\r\n\r\n    rString.resize(cch);\r\n    cch = GetLBText(nIndex, &rString[0]);\r\n    if (cch == CB_ERR)\r\n        rString.clear();\r\n    return cch != CB_ERR;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOMBOBOX_HPP_\r\n
MComboBoxAutoComplete.hpp<>MComboBoxAutoComplete.hpp<>// MComboBoxAutoComplete.hpp -- Win32API autocomplete combo box -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOMBOBOXAUTOCOMP_HPP_\r\n#define MZC4_MCOMBOBOXAUTOCOMP_HPP_     0   /* Version 0 */\r\n\r\nclass MComboBoxAutoComplete;\r\n\r\n#include "MEditCtrl.hpp"\r\n#include "MComboBox.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MComboBoxEditAutoComplete : public MEditCtrl\r\n{\r\npublic:\r\n    MComboBoxEditAutoComplete() : m_bAutoComplete(FALSE)\r\n    {\r\n    }\r\n\r\n    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)\r\n    {\r\n        if (vk == VK_DELETE || vk == VK_BACK)\r\n            m_bAutoComplete = FALSE;\r\n        else\r\n            m_bAutoComplete = TRUE;\r\n\r\n        if (fDown)\r\n        {\r\n            FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, DefaultProcDx);\r\n        }\r\n        else\r\n        {\r\n            FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, DefaultProcDx);\r\n        }\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n            HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);\r\n            HANDLE_MSG(hwnd, WM_KEYUP, OnKey);\r\n        }\r\n        return DefaultProcDx();\r\n    }\r\n\r\npublic:\r\n    BOOL m_bAutoComplete;\r\n};\r\n\r\nclass MComboBoxAutoComplete : public MComboBox\r\n{\r\npublic:\r\n    MComboBoxAutoComplete()\r\n    {\r\n    }\r\n\r\n    virtual void PostSubclassDx(HWND hwnd)\r\n    {\r\n        HWND hEdit = FindWindowEx(hwnd, NULL, TEXT("EDIT"), NULL);\r\n        m_edit.SubclassDx(hEdit);\r\n    }\r\n\r\n    void OnEditChange()\r\n    {\r\n        DWORD dwPos;\r\n        OnEditChange(dwPos);\r\n    }\r\n\r\n    void OnEditChange(DWORD& dwPos)\r\n    {\r\n        if (!m_edit.m_bAutoComplete)\r\n        {\r\n            return;\r\n        }\r\n\r\n        MString strInput = GetWindowText();\r\n\r\n        dwPos = GetEditSel();\r\n        MString strRight = strInput.substr(HIWORD(dwPos));\r\n        mstr_trim(strRight);\r\n        if (!strRight.empty())\r\n            return;\r\n\r\n        mstr_trim(strInput);\r\n        MString strInputUpper = strInput;\r\n        _wcsupr(&strInputUpper[0]);\r\n\r\n        INT iItem = FindString(-1, strInput.c_str());\r\n        if (iItem == CB_ERR)\r\n            return;\r\n\r\n        TCHAR szText[128];\r\n        GetLBText(iItem, szText);\r\n        MString strCandidate = szText;\r\n\r\n        INT nCount = GetCount();\r\n        for (INT i = iItem + 1; i < nCount; ++i)\r\n        {\r\n            GetLBText(i, szText);\r\n            MString strText = szText;\r\n            _wcsupr(&strText[0]);\r\n            if (strText.find(strInputUpper) == 0)\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        m_edit.m_bAutoComplete = FALSE;\r\n        SetWindowText(strCandidate.c_str());\r\n        SetEditSel(INT(strInput.size()), INT(strCandidate.size()));\r\n        dwPos = MAKELONG(INT(strInput.size()), INT(strCandidate.size()));\r\n    }\r\n\r\npublic:\r\n    MComboBoxEditAutoComplete m_edit;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOMBOBOXAUTOCOMP_HPP_\r\n
MComboBoxEx.hpp<>MComboBoxEx.hpp<>// MComboBoxEx.hpp -- Win32API extended combo box wrapper       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOMBOBOXEX_HPP_\r\n#define MZC4_MCOMBOBOXEX_HPP_       2   /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MComboBox.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MComboBoxEx : public MComboBox\r\n    {\r\n    public:\r\n        MComboBoxEx();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        HIMAGELIST GetImageList();\r\n        HIMAGELIST SetImageList(HIMAGELIST hImageList);\r\n\r\n        INT InsertItem(const COMBOBOXEXITEM* lpcCBItem);\r\n        INT InsertItem(UINT nMask, INT nIndex, LPCTSTR lpszItem, INT nImage,\r\n            INT nSelImage, INT iIndent, INT iOverlay, LPARAM lParam);\r\n        INT InsertItem(INT nIndex, LPCTSTR lpszItem, INT nImage, INT nSelImage,\r\n            INT iIndent, LPARAM lParam = 0);\r\n        INT AddItem(UINT nMask, LPCTSTR lpszItem, INT nImage, INT nSelImage,\r\n            INT iIndent, INT iOverlay, LPARAM lParam);\r\n        INT AddItem(LPCTSTR lpszItem, INT nImage, INT nSelImage, INT iIndent,\r\n            LPARAM lParam = 0);\r\n\r\n        INT DeleteItem(INT nIndex);\r\n\r\n        BOOL GetItem(PCOMBOBOXEXITEM pCBItem) const;\r\n        BOOL SetItem(const COMBOBOXEXITEM* lpcCBItem);\r\n        INT SetItem(INT nIndex, UINT nMask, LPCTSTR lpszItem, INT nImage,\r\n            INT nSelImage, INT iIndent, INT iOverlay, LPARAM lParam);\r\n        BOOL GetItemText(INT nIndex, LPTSTR lpszItem, INT nLen) const;\r\n        BOOL SetItemText(INT nIndex, LPCTSTR lpszItem);\r\n        HWND GetComboCtrl() const;\r\n        HWND GetEditCtrl() const;\r\n        BOOL HasEditChanged() const;\r\n\r\n        INT AddString(LPCTSTR);\r\n        INT InsertString(INT, LPCTSTR);\r\n        INT Dir(UINT, LPCTSTR);\r\n        INT FindString(INT, LPCTSTR) const;\r\n\r\n        #if (_WIN32_IE >= 0x0400)\r\n            DWORD GetExtendedStyle() const;\r\n            DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle);\r\n            BOOL GetUnicodeFormat() const;\r\n            BOOL SetUnicodeFormat(BOOL bUnicode = TRUE);\r\n        #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n        #if (_WIN32_WINNT >= 0x0501)\r\n            VOID SetWindowTheme(LPCWSTR lpstrTheme);\r\n        #endif  // (_WIN32_WINNT >= 0x0501)\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline MComboBoxEx::MComboBoxEx()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MComboBoxEx::GetWndClassNameDx() const\r\n    {\r\n        return WC_COMBOBOXEX;\r\n    }\r\n\r\n    inline HIMAGELIST MComboBoxEx::GetImageList()\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(CBEM_GETIMAGELIST);\r\n    }\r\n\r\n    inline HIMAGELIST MComboBoxEx::SetImageList(HIMAGELIST hImageList)\r\n    {\r\n        return (HIMAGELIST)\r\n            SendMessageDx(CBEM_SETIMAGELIST, 0, (LPARAM)hImageList);\r\n    }\r\n\r\n    inline INT MComboBoxEx::InsertItem(const COMBOBOXEXITEM* lpcCBItem)\r\n    {\r\n        return (INT)SendMessageDx(CBEM_INSERTITEM, 0, (LPARAM)lpcCBItem);\r\n    }\r\n\r\n    inline INT MComboBoxEx::AddItem(\r\n        UINT nMask, LPCTSTR lpszItem, INT nImage, INT nSelImage,\r\n        INT iIndent, INT iOverlay, LPARAM lParam)\r\n    {\r\n        return InsertItem(nMask, -1, lpszItem, nImage, nSelImage,\r\n            iIndent, iOverlay, lParam);\r\n    }\r\n\r\n    inline INT MComboBoxEx::AddItem(LPCTSTR lpszItem, INT nImage,\r\n        INT nSelImage, INT iIndent, LPARAM lParam/* = 0*/)\r\n    {\r\n        return InsertItem(-1, lpszItem, nImage, nSelImage, iIndent, lParam);\r\n    }\r\n\r\n    inline INT MComboBoxEx::DeleteItem(INT nIndex)\r\n    {\r\n        return (INT)SendMessageDx(CBEM_DELETEITEM, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::GetItem(PCOMBOBOXEXITEM pCBItem) const\r\n    {\r\n        return (BOOL)SendMessageDx(CBEM_GETITEM, 0, (LPARAM)pCBItem);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::SetItem(const COMBOBOXEXITEM* lpcCBItem)\r\n    {\r\n        return (BOOL)SendMessageDx(CBEM_SETITEM, 0, (LPARAM)lpcCBItem);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::SetItemText(INT nIndex, LPCTSTR lpszItem)\r\n    {\r\n        return SetItem(nIndex, CBEIF_TEXT, lpszItem, 0, 0, 0, 0, 0);\r\n    }\r\n\r\n    inline HWND MComboBoxEx::GetComboCtrl() const\r\n    {\r\n        return (HWND)SendMessageDx(CBEM_GETCOMBOCONTROL);\r\n    }\r\n\r\n    inline HWND MComboBoxEx::GetEditCtrl() const\r\n    {\r\n        return (HWND)SendMessageDx(CBEM_GETEDITCONTROL);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::HasEditChanged() const\r\n    {\r\n        return (BOOL)SendMessageDx(CBEM_HASEDITCHANGED);\r\n    }\r\n\r\n    inline INT MComboBoxEx::AddString(LPCTSTR)\r\n    {\r\n        DebugPrintDx(TEXT("WARNING: You shouldn't call AddString for MComboBoxEx!\\n"));\r\n        assert(FALSE);\r\n        return 0;\r\n    }\r\n\r\n    inline INT MComboBoxEx::InsertString(INT, LPCTSTR)\r\n    {\r\n        DebugPrintDx(TEXT("WARNING: You shouldn't call InsertString for MComboBoxEx!\\n"));\r\n        assert(FALSE);\r\n        return 0;\r\n    }\r\n\r\n    inline INT MComboBoxEx::Dir(UINT, LPCTSTR)\r\n    {\r\n        DebugPrintDx(TEXT("WARNING: You shouldn't call Dir for MComboBoxEx!\\n"));\r\n        assert(FALSE);\r\n        return 0;\r\n    }\r\n\r\n    inline INT MComboBoxEx::FindString(INT, LPCTSTR) const\r\n    {\r\n        DebugPrintDx(TEXT("WARNING: You shouldn't call FindString for MComboBoxEx!\\n"));\r\n        assert(FALSE);\r\n        return 0;\r\n    }\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline DWORD MComboBoxEx::GetExtendedStyle() const\r\n    {\r\n        return (DWORD)SendMessageDx(CBEM_GETEXTENDEDSTYLE);\r\n    }\r\n\r\n    inline DWORD MComboBoxEx::SetExtendedStyle(\r\n        DWORD dwExMask, DWORD dwExStyle)\r\n    {\r\n        return (DWORD)SendMessageDx(CBEM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwExStyle);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::GetUnicodeFormat() const\r\n    {\r\n        return (BOOL)SendMessageDx(CBEM_GETUNICODEFORMAT);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::SetUnicodeFormat(BOOL bUnicode/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(CBEM_SETUNICODEFORMAT, (WPARAM)bUnicode);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n#if (_WIN32_WINNT >= 0x0501)\r\n    inline VOID MComboBoxEx::SetWindowTheme(LPCWSTR lpstrTheme)\r\n    {\r\n        SendMessageDx(CBEM_SETWINDOWTHEME, 0, (LPARAM)lpstrTheme);\r\n    }\r\n#endif  // (_WIN32_WINNT >= 0x0501)\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline INT MComboBoxEx::InsertItem(UINT nMask, INT nIndex,\r\n        LPCTSTR lpszItem, INT nImage, INT nSelImage, INT iIndent,\r\n        INT iOverlay, LPARAM lParam)\r\n    {\r\n        COMBOBOXEXITEM cbex;\r\n        ZeroMemory(&cbex, sizeof(cbex));\r\n        cbex.mask = nMask;\r\n        cbex.iItem = nIndex;\r\n        cbex.pszText = const_cast<LPTSTR>(lpszItem);\r\n        cbex.iImage = nImage;\r\n        cbex.iSelectedImage = nSelImage;\r\n        cbex.iIndent = iIndent;\r\n        cbex.iOverlay = iOverlay;\r\n        cbex.lParam = lParam;\r\n        return (INT)SendMessageDx(CBEM_INSERTITEM, 0, (LPARAM)&cbex);\r\n    }\r\n\r\n    inline INT MComboBoxEx::InsertItem(\r\n        INT nIndex, LPCTSTR lpszItem, INT nImage, INT nSelImage,\r\n        INT iIndent, LPARAM lParam/* = 0*/)\r\n    {\r\n        COMBOBOXEXITEM cbex;\r\n        ZeroMemory(&cbex, sizeof(cbex));\r\n        cbex.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE |\r\n                    CBEIF_INDENT | CBEIF_LPARAM;\r\n        cbex.iItem = nIndex;\r\n        cbex.pszText = const_cast<LPTSTR>(lpszItem);\r\n        cbex.iImage = nImage;\r\n        cbex.iSelectedImage = nSelImage;\r\n        cbex.iIndent = iIndent;\r\n        cbex.lParam = lParam;\r\n        return (INT)SendMessageDx(CBEM_INSERTITEM, 0, (LPARAM)&cbex);\r\n    }\r\n\r\n    inline INT MComboBoxEx::SetItem(INT nIndex, UINT nMask,\r\n        LPCTSTR lpszItem, INT nImage, INT nSelImage, INT iIndent,\r\n        INT iOverlay, LPARAM lParam)\r\n    {\r\n        COMBOBOXEXITEM cbex;\r\n        ZeroMemory(&cbex, sizeof(cbex));\r\n        cbex.mask = nMask;\r\n        cbex.iItem = nIndex;\r\n        cbex.pszText = const_cast<LPTSTR>(lpszItem);\r\n        cbex.iImage = nImage;\r\n        cbex.iSelectedImage = nSelImage;\r\n        cbex.iIndent = iIndent;\r\n        cbex.iOverlay = iOverlay;\r\n        cbex.lParam = lParam;\r\n        return (INT)SendMessageDx(CBEM_SETITEM, 0, (LPARAM)&cbex);\r\n    }\r\n\r\n    inline BOOL MComboBoxEx::GetItemText(\r\n        INT nIndex, LPTSTR lpszItem, INT nLen) const\r\n    {\r\n        COMBOBOXEXITEM cbex;\r\n        ZeroMemory(&cbex, sizeof(cbex));\r\n        cbex.mask = CBEIF_TEXT;\r\n        cbex.iItem = nIndex;\r\n        cbex.pszText = lpszItem;\r\n        cbex.cchTextMax = nLen;\r\n        return (BOOL)SendMessageDx(CBEM_GETITEM, 0, (LPARAM)&cbex);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOMBOBOXEX_HPP_\r\n
MComboBoxExAutoComplete.hpp<>MComboBoxExAutoComplete.hpp<>// MComboBoxExAutoComplete.hpp -- autocomplete combobox extended -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOMBOBOXEXAUTOCOMP_HPP_\r\n#define MZC4_MCOMBOBOXEXAUTOCOMP_HPP_     0   /* Version 0 */\r\n\r\nclass MComboBoxExAutoComplete;\r\n\r\n#include "MEditCtrl.hpp"\r\n#include "MComboBoxEx.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MComboBoxExEditAutoComplete : public MEditCtrl\r\n{\r\npublic:\r\n    MComboBoxExEditAutoComplete() : m_bAutoComplete(FALSE)\r\n    {\r\n    }\r\n\r\n    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)\r\n    {\r\n        if (vk == VK_DELETE || vk == VK_BACK)\r\n            m_bAutoComplete = FALSE;\r\n        else\r\n            m_bAutoComplete = TRUE;\r\n\r\n        if (fDown)\r\n        {\r\n            FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, DefaultProcDx);\r\n        }\r\n        else\r\n        {\r\n            FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, DefaultProcDx);\r\n        }\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n            HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);\r\n            HANDLE_MSG(hwnd, WM_KEYUP, OnKey);\r\n        }\r\n        return DefaultProcDx();\r\n    }\r\n\r\npublic:\r\n    BOOL m_bAutoComplete;\r\n};\r\n\r\nclass MComboBoxExAutoComplete : public MComboBoxEx\r\n{\r\npublic:\r\n    MComboBoxExAutoComplete()\r\n    {\r\n    }\r\n\r\n    virtual void PostSubclassDx(HWND hwnd)\r\n    {\r\n        HWND hEdit = FindWindowEx(hwnd, NULL, TEXT("EDIT"), NULL);\r\n        m_edit.SubclassDx(hEdit);\r\n    }\r\n\r\n    void OnEditChange()\r\n    {\r\n        DWORD dwPos;\r\n        OnEditChange(dwPos);\r\n    }\r\n\r\n    void OnEditChange(DWORD& dwPos)\r\n    {\r\n        if (!m_edit.m_bAutoComplete)\r\n        {\r\n            return;\r\n        }\r\n\r\n        MString strInput = GetWindowText();\r\n\r\n        dwPos = GetEditSel();\r\n        MString strRight = strInput.substr(HIWORD(dwPos));\r\n        mstr_trim(strRight);\r\n        if (!strRight.empty())\r\n            return;\r\n\r\n        mstr_trim(strInput);\r\n        MString strInputUpper = strInput;\r\n        _wcsupr(&strInputUpper[0]);\r\n\r\n        INT iItem = FindString(-1, strInput.c_str());\r\n        if (iItem == CB_ERR)\r\n            return;\r\n\r\n        TCHAR szText[128];\r\n        GetLBText(iItem, szText);\r\n        MString strCandidate = szText;\r\n\r\n        INT nCount = GetCount();\r\n        for (INT i = iItem + 1; i < nCount; ++i)\r\n        {\r\n            GetLBText(i, szText);\r\n            MString strText = szText;\r\n            _wcsupr(&strText[0]);\r\n            if (strText.find(strInputUpper) == 0)\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        m_edit.m_bAutoComplete = FALSE;\r\n        SetWindowText(strCandidate.c_str());\r\n        SetEditSel(INT(strInput.size()), INT(strCandidate.size()));\r\n        dwPos = MAKELONG(INT(strInput.size()), INT(strCandidate.size()));\r\n    }\r\n\r\npublic:\r\n    MComboBoxExEditAutoComplete m_edit;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOMBOBOXEXAUTOCOMP_HPP_\r\n
MCommonDialog.hpp<>MCommonDialog.hpp<>// MCommonDialog.hpp -- MZC4 common dialog base                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCOMMONDIALOG_HPP_\r\n#define MZC4_MCOMMONDIALOG_HPP_     2       /* Version 2 */\r\n\r\nclass MCommonDialog;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MDialogBase.hpp"\r\n\r\n#ifndef _INC_COMMDLG\r\n    #include <commdlg.h>\r\n#endif\r\n\r\n#pragma comment(lib, "comdlg32.lib")\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MCommonDialog : public MDialogBase\r\n{\r\npublic:\r\n    MCommonDialog()\r\n    {\r\n    }\r\n\r\n    MCommonDialog(HWND hwndOwner) : MDialogBase(hwndOwner)\r\n    {\r\n    }\r\n\r\n    static DWORD GetError()\r\n    {\r\n        return ::CommDlgExtendedError();\r\n    }\r\n\r\n    static LPCTSTR ErrorToText(DWORD dwError);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ LPCTSTR MCommonDialog::ErrorToText(DWORD dwError)\r\n{\r\n    switch (dwError)\r\n    {\r\n        case CDERR_DIALOGFAILURE: return TEXT("CDERR_DIALOGFAILURE");\r\n        case CDERR_GENERALCODES: return TEXT("CDERR_GENERALCODES");\r\n        case CDERR_STRUCTSIZE: return TEXT("CDERR_STRUCTSIZE");\r\n        case CDERR_INITIALIZATION: return TEXT("CDERR_INITIALIZATION");\r\n        case CDERR_NOTEMPLATE: return TEXT("CDERR_NOTEMPLATE");\r\n        case CDERR_NOHINSTANCE: return TEXT("CDERR_NOHINSTANCE");\r\n        case CDERR_LOADSTRFAILURE: return TEXT("CDERR_LOADSTRFAILURE");\r\n        case CDERR_FINDRESFAILURE: return TEXT("CDERR_FINDRESFAILURE");\r\n        case CDERR_LOADRESFAILURE: return TEXT("CDERR_LOADRESFAILURE");\r\n        case CDERR_LOCKRESFAILURE: return TEXT("CDERR_LOCKRESFAILURE");\r\n        case CDERR_MEMALLOCFAILURE: return TEXT("CDERR_MEMALLOCFAILURE");\r\n        case CDERR_MEMLOCKFAILURE: return TEXT("CDERR_MEMLOCKFAILURE");\r\n        case CDERR_NOHOOK: return TEXT("CDERR_NOHOOK");\r\n        case CDERR_REGISTERMSGFAIL: return TEXT("CDERR_REGISTERMSGFAIL");\r\n        case PDERR_PRINTERCODES: return TEXT("PDERR_PRINTERCODES");\r\n        case PDERR_SETUPFAILURE: return TEXT("PDERR_SETUPFAILURE");\r\n        case PDERR_PARSEFAILURE: return TEXT("PDERR_PARSEFAILURE");\r\n        case PDERR_RETDEFFAILURE: return TEXT("PDERR_RETDEFFAILURE");\r\n        case PDERR_LOADDRVFAILURE: return TEXT("PDERR_LOADDRVFAILURE");\r\n        case PDERR_GETDEVMODEFAIL: return TEXT("PDERR_GETDEVMODEFAIL");\r\n        case PDERR_INITFAILURE: return TEXT("PDERR_INITFAILURE");\r\n        case PDERR_NODEVICES: return TEXT("PDERR_NODEVICES");\r\n        case PDERR_NODEFAULTPRN: return TEXT("PDERR_NODEFAULTPRN");\r\n        case PDERR_DNDMMISMATCH: return TEXT("PDERR_DNDMMISMATCH");\r\n        case PDERR_CREATEICFAILURE: return TEXT("PDERR_CREATEICFAILURE");\r\n        case PDERR_PRINTERNOTFOUND: return TEXT("PDERR_PRINTERNOTFOUND");\r\n        case PDERR_DEFAULTDIFFERENT: return TEXT("PDERR_DEFAULTDIFFERENT");\r\n        case CFERR_CHOOSEFONTCODES: return TEXT("CFERR_CHOOSEFONTCODES");\r\n        case CFERR_NOFONTS: return TEXT("CFERR_NOFONTS");\r\n        case CFERR_MAXLESSTHANMIN: return TEXT("CFERR_MAXLESSTHANMIN");\r\n        case FNERR_FILENAMECODES: return TEXT("FNERR_FILENAMECODES");\r\n        case FNERR_SUBCLASSFAILURE: return TEXT("FNERR_SUBCLASSFAILURE");\r\n        case FNERR_INVALIDFILENAME: return TEXT("FNERR_INVALIDFILENAME");\r\n        case FNERR_BUFFERTOOSMALL: return TEXT("FNERR_BUFFERTOOSMALL");\r\n        case FRERR_FINDREPLACECODES: return TEXT("FRERR_FINDREPLACECODES");\r\n        case FRERR_BUFFERLENGTHZERO: return TEXT("FRERR_BUFFERLENGTHZERO");\r\n        case CCERR_CHOOSECOLORCODES: return TEXT("CCERR_CHOOSECOLORCODES");\r\n        default:\r\n            break;\r\n    }\r\n    return TEXT("(Unknown)");\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCOMMONDIALOG_HPP_\r\n
MCriticalSection.hpp<>MCriticalSection.hpp<>// MCriticalSection.hpp -- Win32API critical section wrapper -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCRITICALSECTION_HPP_\r\n#define MZC4_MCRITICALSECTION_HPP_  3   /* Version 3 */\r\n\r\nclass MCriticalSection;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MSyncBase.hpp"\r\n\r\nclass MCriticalSection : public MSyncBase\r\n{\r\npublic:\r\n    MCriticalSection();\r\n    MCriticalSection(DWORD dwSpinCount);\r\n    virtual ~MCriticalSection();\r\n    operator LPCRITICAL_SECTION();\r\n    virtual BOOL Lock();\r\n    virtual BOOL Lock(DWORD dwTimeout);\r\n    virtual BOOL Unlock();\r\n\r\nprotected:\r\n    CRITICAL_SECTION m_cs;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MCriticalSection::MCriticalSection()\r\n{\r\n    ::InitializeCriticalSection(&m_cs);\r\n}\r\n\r\n#if (_WIN32_WINNT >= 0x0403)\r\ninline MCriticalSection::MCriticalSection(DWORD dwSpinCount)\r\n#else\r\ninline MCriticalSection::MCriticalSection(DWORD)\r\n#endif\r\n{\r\n#if (_WIN32_WINNT >= 0x0403)\r\n    ::InitializeCriticalSectionAndSpinCount(&m_cs, dwSpinCount);\r\n#else\r\n    ::InitializeCriticalSection(&m_cs);\r\n#endif\r\n}\r\n\r\ninline /*virtual*/ MCriticalSection::~MCriticalSection()\r\n{\r\n    ::DeleteCriticalSection(&m_cs);\r\n}\r\n\r\ninline /*virtual*/ BOOL MCriticalSection::Lock()\r\n{\r\n    ::EnterCriticalSection(&m_cs);\r\n    return TRUE;\r\n}\r\n\r\ninline /*virtual*/ BOOL MCriticalSection::Lock(DWORD dwTimeout)\r\n{\r\n#if (_WIN32_WINNT >= 0x0400)\r\n    return ::TryEnterCriticalSection(&m_cs);\r\n#else\r\n    return FALSE;\r\n#endif\r\n}\r\n\r\ninline /*virtual*/ BOOL MCriticalSection::Unlock()\r\n{\r\n    ::LeaveCriticalSection(&m_cs);\r\n    return TRUE;\r\n}\r\n\r\ninline MCriticalSection::operator LPCRITICAL_SECTION()\r\n{\r\n    return &m_cs;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCRITICALSECTION_HPP_\r\n
MCursor.hpp<>MCursor.hpp<>// MAccel.hpp -- Win32API cursor wrapper                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MCURSOR_HPP_\r\n#define MZC4_MCURSOR_HPP_       4   /* Version 4 */\r\n\r\nclass MCursor;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\ninline HCURSOR CopyCursorDx(HCURSOR hCursor)\r\n{\r\n    return ::CopyIcon(hCursor);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MCursor\r\n{\r\npublic:\r\n    MCursor();\r\n    MCursor(HCURSOR hCursor);\r\n    MCursor(const MCursor& cur);\r\n    MCursor& operator=(HCURSOR hCursor);\r\n    MCursor& operator=(const MCursor& cur);\r\n    virtual ~MCursor();\r\n\r\n    bool operator!() const;\r\n    bool operator==(HCURSOR hCursor) const;\r\n    bool operator!=(HCURSOR hCursor) const;\r\n    HCURSOR Handle() const;\r\n    operator HCURSOR() const;\r\n\r\n    BOOL Attach(HCURSOR hCursor);\r\n    HCURSOR Detach();\r\n\r\n    BOOL CopyCursorDx(HCURSOR hCursor);\r\n    BOOL CreateCursor(HINSTANCE hInstance, INT xHotSpot, INT yHotSpot,\r\n                      INT width, INT height,\r\n                      const BYTE *pbANDbits, const BYTE *pbXORbits);\r\n    BOOL CreateIconFromResource(PBYTE presbits, DWORD dwResSize,\r\n                                BOOL fIcon = FALSE,\r\n                                DWORD dwVer = 0x00030000);\r\n    BOOL CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize,\r\n                                  BOOL fIcon = FALSE,\r\n                                  DWORD dwVer = 0x00030000,\r\n                                  INT cxDesired = 0, INT cyDesired = 0,\r\n                                  UINT uFlags = LR_DEFAULTCOLOR);\r\n    BOOL LoadCursor(LPCTSTR pszResourceName, HINSTANCE hInstance = NULL);\r\n    BOOL LoadCursor(UINT nCursorID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadCursorFromFile(LPCTSTR pszFileName);\r\n    BOOL LoadImage(HINSTANCE hInstance, LPCTSTR pszName,\r\n                   INT cxDesired = 0, INT cyDesired = 0, UINT fuLoad = 0);\r\n    BOOL LoadImageFromFile(HINSTANCE hInstance, LPCTSTR pszName,\r\n                           INT cxDesired = 0, INT cyDesired = 0,\r\n                           UINT fuLoad = 0);\r\n    BOOL CreateIconIndirect(PICONINFO pIconInfo);\r\n    BOOL DestroyCursor();\r\n\r\n    BOOL DrawIcon(HDC hDC, INT x, INT y);\r\n    BOOL DrawIconEx(HDC hDC, INT x, INT y, INT cx, INT cy,\r\n                    UINT index = 0, HBRUSH hbr = NULL,\r\n                    UINT uDI_flags = DI_NORMAL);\r\n    BOOL GetIconInfo(PICONINFO pIconInfo) const;\r\n\r\n    static HCURSOR CloneHandleDx(HCURSOR hCursor);\r\n\r\nprotected:\r\n    HCURSOR m_hCursor;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MCursor::MCursor() : m_hCursor(NULL)\r\n{\r\n}\r\n\r\ninline MCursor::MCursor(HCURSOR hCursor) : m_hCursor(hCursor)\r\n{\r\n}\r\n\r\ninline MCursor::MCursor(const MCursor& cur)\r\n    : m_hCursor(CloneHandleDx(cur))\r\n{\r\n}\r\n\r\ninline /*virtual*/ MCursor::~MCursor()\r\n{\r\n    DestroyCursor();\r\n}\r\n\r\ninline bool MCursor::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline bool MCursor::operator==(HCURSOR hCursor) const\r\n{\r\n    return Handle() == hCursor;\r\n}\r\n\r\ninline bool MCursor::operator!=(HCURSOR hCursor) const\r\n{\r\n    return Handle() != hCursor;\r\n}\r\n\r\ninline HCURSOR MCursor::Handle() const\r\n{\r\n    return (this ? m_hCursor : NULL);\r\n}\r\n\r\ninline MCursor::operator HCURSOR() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline MCursor& MCursor::operator=(HCURSOR hCursor)\r\n{\r\n    if (Handle() != hCursor)\r\n    {\r\n        Attach(hCursor);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MCursor& MCursor::operator=(const MCursor& cur)\r\n{\r\n    if (Handle() != cur.Handle())\r\n    {\r\n        HCURSOR hCursor = CloneHandleDx(cur);\r\n        Attach(hCursor);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MCursor::Attach(HCURSOR hCursor)\r\n{\r\n    DestroyCursor();\r\n    assert(m_hCursor == NULL);\r\n    m_hCursor = hCursor;\r\n    return m_hCursor != NULL;\r\n}\r\n\r\ninline HCURSOR MCursor::Detach()\r\n{\r\n    HCURSOR hCursor = m_hCursor;\r\n    m_hCursor = NULL;\r\n    return hCursor;\r\n}\r\n\r\ninline BOOL MCursor::CopyCursorDx(HCURSOR hCursor)\r\n{\r\n    return Attach(::CopyCursorDx(hCursor));\r\n}\r\n\r\ninline BOOL MCursor::CreateCursor(HINSTANCE hInstance, INT xHotSpot, INT yHotSpot,\r\n    INT width, INT height, const BYTE *pbANDbits, const BYTE *pbXORbits)\r\n{\r\n    HCURSOR hCursor = ::CreateCursor(hInstance, xHotSpot, yHotSpot,\r\n                                     width, height, pbANDbits, pbXORbits);\r\n    if (hCursor == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hCursor = ::CreateCursor(hInstance, xHotSpot, yHotSpot,\r\n                                 width, height, pbANDbits, pbXORbits);\r\n    }\r\n    return Attach(hCursor);\r\n}\r\n\r\ninline BOOL MCursor::CreateIconFromResource(PBYTE presbits, DWORD dwResSize,\r\n    BOOL fIcon/* = FALSE*/, DWORD dwVer/* = 0x00030000*/)\r\n{\r\n    HCURSOR hCursor = ::CreateIconFromResource(presbits, dwResSize, fIcon, dwVer);\r\n    return Attach(hCursor);\r\n}\r\n\r\ninline BOOL MCursor::CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize,\r\n    BOOL fIcon/* = FALSE*/, DWORD dwVer/* = 0x00030000*/,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT uFlags/* = LR_DEFAULTCOLOR*/)\r\n{\r\n    return Attach(::CreateIconFromResourceEx(presbits, dwResSize, fIcon, dwVer,\r\n                                             cxDesired, cyDesired, uFlags));\r\n}\r\n\r\ninline BOOL MCursor::LoadCursor(\r\n    LPCTSTR pszResourceName, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    HCURSOR hCursor = ::LoadCursor(hInstance, pszResourceName);\r\n    if (hCursor == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hCursor = ::LoadCursor(hInstance, pszResourceName);\r\n    }\r\n    return Attach(hCursor);\r\n}\r\n\r\ninline BOOL MCursor::LoadCursor(UINT nCursorID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    return LoadCursor(MAKEINTRESOURCE(nCursorID), hInstance);\r\n}\r\n\r\ninline BOOL MCursor::LoadCursorFromFile(LPCTSTR pszFileName)\r\n{\r\n    return Attach(::LoadCursorFromFile(pszFileName));\r\n}\r\n\r\ninline BOOL MCursor::LoadImage(HINSTANCE hInstance, LPCTSTR pszName,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    HCURSOR hCursor = reinterpret_cast<HCURSOR>(\r\n        ::LoadImage(hInstance, pszName, IMAGE_ICON,\r\n                    cxDesired, cyDesired, fuLoad));\r\n    if (hCursor == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hCursor = reinterpret_cast<HCURSOR>(\r\n            ::LoadImage(hInstance, pszName, IMAGE_ICON,\r\n                        cxDesired, cyDesired, fuLoad));\r\n    }\r\n    return Attach(hCursor);\r\n}\r\n\r\ninline BOOL MCursor::LoadImageFromFile(HINSTANCE hInstance, LPCTSTR pszName,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    return LoadImage(hInstance, pszName, cxDesired, cyDesired,\r\n        fuLoad | LR_LOADFROMFILE);\r\n}\r\n\r\ninline BOOL MCursor::CreateIconIndirect(PICONINFO pIconInfo)\r\n{\r\n    assert(pIconInfo);\r\n    assert(pIconInfo->fIcon == FALSE);\r\n    return Attach(reinterpret_cast<HCURSOR>(::CreateIconIndirect(pIconInfo)));\r\n}\r\n\r\ninline BOOL MCursor::DestroyCursor()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DestroyCursor(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MCursor::DrawIcon(HDC hDC, INT x, INT y)\r\n{\r\n    assert(m_hCursor);\r\n    assert(hDC);\r\n    return ::DrawIcon(hDC, x, y, m_hCursor);\r\n}\r\n\r\ninline BOOL MCursor::DrawIconEx(HDC hDC, INT x, INT y,\r\n    INT cx, INT cy, UINT index/* = 0*/, HBRUSH hbr/* = NULL*/,\r\n    UINT uDI_flags/* = DI_NORMAL*/)\r\n{\r\n    assert(m_hCursor);\r\n    assert(hDC);\r\n    return ::DrawIconEx(hDC, x, y, m_hCursor, cx, cy,\r\n        index, hbr, uDI_flags);\r\n}\r\n\r\ninline BOOL MCursor::GetIconInfo(PICONINFO pIconInfo) const\r\n{\r\n    assert(m_hCursor);\r\n    return ::GetIconInfo(m_hCursor, pIconInfo);\r\n}\r\n\r\ninline /*static*/ HCURSOR MCursor::CloneHandleDx(HCURSOR hCursor)\r\n{\r\n    if (hCursor == NULL)\r\n        return NULL;\r\n    return ::CopyCursorDx(hCursor);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MCURSOR_HPP_\r\n
MDC.hpp<>MDC.hpp<>// MDC.hpp -- Win32API DC wrapper                               -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MDC_HPP_\r\n#define MZC4_MDC_HPP_       3       /* Version 3 */\r\n\r\nclass MDC;\r\n    class MMemoryDC;\r\n    class MClientDC;\r\n    class MPaintDC;\r\n    class MWindowDC;\r\n\r\n    class MMetaDC;\r\n    class MEnhMetaDC;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef HIMETRIC_INCH\r\n    #define HIMETRIC_INCH   2540  // HIMETRIC units per inch\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#pragma comment(lib, "gdi32.lib")\r\n#if (WINVER >= 0x0400)\r\n    #pragma comment(lib, "msimg32.lib")\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MBitmap.hpp"\r\n#include "MPointSizeRect.hpp"\r\n\r\nVOID GetDpiDx(FLOAT *xdpi, FLOAT *ydpi);\r\nFLOAT GetXDpiDx(VOID);\r\nFLOAT GetYDpiDx(VOID);\r\nFLOAT XDpiScaleDx(FLOAT xPixels, FLOAT base_xdpi = 96.0f);\r\nFLOAT YDpiScaleDx(FLOAT yPixels, FLOAT base_ydpi = 96.0f);\r\n\r\nclass MDC\r\n{\r\npublic:\r\n    HDC m_hDC;\r\n\r\npublic:\r\n    MDC();\r\n    MDC(HDC hDC);\r\n    MDC& operator=(HDC hDC);\r\n    virtual ~MDC();\r\n\r\n    BOOL Attach(HDC hDC);\r\n    HDC Detach(VOID);\r\n    HDC Handle() const;\r\n\r\n    operator HDC() const;\r\n    bool operator!() const;\r\n\r\n    HWND WindowFromDC() const;\r\n    BOOL DeleteDC();\r\n\r\npublic:\r\n    BOOL CreateDC(LPCTSTR pszDriver = NULL, LPCTSTR pszDevice = NULL,\r\n        LPCTSTR pszOutput = NULL, CONST DEVMODE *lpInitData = NULL);\r\n    BOOL CreateCompatibleDC(HDC hBaseDC = NULL);\r\n\r\n    HPEN        GetCurrentPen() const;\r\n    HBRUSH      GetCurrentBrush() const;\r\n    HPALETTE    GetCurrentPalette() const;\r\n    HFONT       GetCurrentFont() const;\r\n    HBITMAP     GetCurrentBitmap() const;\r\n\r\n    INT     SaveDC(VOID);\r\n    BOOL    RestoreDC(INT nSavedDC);\r\n\r\n    INT GetDeviceCaps(INT nIndex) const;\r\n    UINT GetBoundsRect(LPRECT lpRectBounds, UINT uDCB_flags) const;\r\n    UINT SetBoundsRect(LPCRECT lpRectBounds, UINT uDCB_flags);\r\n    BOOL ResetDC(CONST DEVMODE *lpDevMode);\r\n    BOOL GetBrushOrg(LPPOINT ppt) const;\r\n    BOOL SetBrushOrg(INT x, INT y, LPPOINT ppt = NULL);\r\n    BOOL SetBrushOrg(POINT pt, LPPOINT lpPointRet = NULL);\r\n\r\n    INT EnumObjects(INT nObjectType, INT (CALLBACK* lpfn)(LPVOID, LPARAM),\r\n                    LPARAM lpData);\r\n\r\n    HGDIOBJ     SelectStockObject(INT nIndex);\r\n    HPEN        SelectObject(HPEN hPen);\r\n    HBRUSH      SelectObject(HBRUSH hBrush);\r\n    HFONT       SelectObject(HFONT hFont);\r\n    HBITMAP     SelectObject(HBITMAP hBitmap);\r\n    INT         SelectObject(HRGN hRgn);\r\n    HGDIOBJ     SelectObject(HGDIOBJ hGdiObj);\r\n    HPALETTE    SelectPalette(HPALETTE hPal, BOOL bForceBackground = FALSE);\r\n\r\n    COLORREF    GetNearestColor(COLORREF crColor) const;\r\n    UINT        RealizePalette(VOID);\r\n    VOID        UpdateColors(VOID);\r\n\r\n    COLORREF GetBkColor() const;\r\n    COLORREF SetBkColor(COLORREF crColor);\r\n\r\n    COLORREF GetTextColor() const;\r\n    COLORREF SetTextColor(COLORREF crColor);\r\n\r\n#if (_WIN32_WINNT >= 0x0500)\r\n    COLORREF GetDCBrushColor();\r\n    COLORREF GetDCPenColor();\r\n#endif  //  (_WIN32_WINNT >= 0x0500)\r\n\r\n    INT GetBkMode() const;\r\n    INT SetBkMode(INT nBkMode);\r\n    INT GetPolyFillMode() const;\r\n    INT SetPolyFillMode(INT nPolyFillMode);\r\n    INT GetROP2() const;\r\n    INT SetROP2(INT nR2_);\r\n    INT GetStretchBltMode() const;\r\n    INT SetStretchBltMode(INT nSTRETCH_);\r\n    BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;\r\n    BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);\r\n    INT GetMapMode() const;\r\n    INT SetMapMode(INT nMapMode);\r\n\r\n    BOOL GetViewportOrg(LPPOINT lpPoint) const;\r\n    BOOL SetViewportOrg(INT x, INT y, LPPOINT lpPoint = NULL);\r\n    BOOL SetViewportOrg(POINT pt, LPPOINT lpPointRet = NULL);\r\n    BOOL OffsetViewportOrg(INT nWidth, INT nHeight, LPPOINT lpPoint = NULL);\r\n    BOOL GetViewportExt(LPSIZE lpSize) const;\r\n    BOOL SetViewportExt(INT cx, INT cy, LPSIZE lpSize = NULL);\r\n    BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL);\r\n    BOOL ScaleViewportExt(INT xNum, INT xDenom, INT yNum, INT yDenom,\r\n        LPSIZE lpSize = NULL);\r\n\r\n    BOOL GetWindowOrg(LPPOINT lpPoint) const;\r\n    BOOL SetWindowOrg(INT x, INT y, LPPOINT lpPoint = NULL);\r\n    BOOL SetWindowOrg(POINT pt, LPPOINT lpPointRet = NULL);\r\n    BOOL OffsetWindowOrg(INT nWidth, INT nHeight, LPPOINT lpPoint = NULL);\r\n    BOOL GetWindowExt(LPSIZE lpSize) const;\r\n    BOOL SetWindowExt(INT x, INT y, LPSIZE lpSize = NULL);\r\n    BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet = NULL);\r\n    BOOL ScaleWindowExt(INT xNum, INT xDenom, INT yNum, INT yDenom,\r\n        LPSIZE lpSize = NULL);\r\n\r\n    BOOL DPtoLP(LPPOINT lpPoints, INT nCount = 1) const;\r\n    BOOL DPtoLP(LPRECT prc) const;\r\n    BOOL DPtoLP(LPSIZE lpSize) const;\r\n    BOOL LPtoDP(LPPOINT lpPoints, INT nCount = 1) const;\r\n    BOOL LPtoDP(LPRECT prc) const;\r\n    BOOL LPtoDP(LPSIZE lpSize) const;\r\n    VOID DPtoHIMETRIC(LPSIZE lpSize) const;\r\n    VOID HIMETRICtoDP(LPSIZE lpSize) const;\r\n    VOID LPtoHIMETRIC(LPSIZE lpSize) const;\r\n    VOID HIMETRICtoLP(LPSIZE lpSize) const;\r\n\r\n    BOOL FillRgn(HRGN hRgn, HBRUSH hBrush);\r\n    BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, INT nWidth, INT nHeight);\r\n    BOOL InvertRgn(HRGN hRgn);\r\n    BOOL PaintRgn(HRGN hRgn);\r\n\r\n    INT GetClipBox(LPRECT prc) const;\r\n    INT GetClipRgn(HRGN hRgn) const;\r\n    BOOL PtVisible(INT x, INT y) const;\r\n    BOOL PtVisible(POINT pt) const;\r\n    BOOL RectVisible(LPCRECT prc) const;\r\n    INT SelectClipRgn(HRGN hRgn);\r\n    INT ExcludeClipRect(INT x1, INT y1, INT x2, INT y2);\r\n    INT ExcludeClipRect(LPCRECT prc);\r\n    INT ExcludeUpdateRgn(HWND hWnd);\r\n    INT IntersectClipRect(INT x1, INT y1, INT x2, INT y2);\r\n    INT IntersectClipRect(LPCRECT prc);\r\n    INT OffsetClipRgn(INT x, INT y);\r\n    INT OffsetClipRgn(SIZE size);\r\n    INT SelectClipRgn(HRGN hRgn, INT nMode);\r\n\r\n    BOOL GetCurrentPosition(LPPOINT lpPoint) const;\r\n    BOOL MoveTo(INT x, INT y, LPPOINT lpPoint = NULL);\r\n    BOOL MoveTo(POINT pt, LPPOINT lpPointRet = NULL);\r\n    BOOL LineTo(INT x, INT y);\r\n    BOOL LineTo(POINT pt);\r\n    BOOL Line(INT x1, INT y1, INT x2, INT y2);\r\n    BOOL Line(POINT pt1, POINT pt2);\r\n    BOOL Arc(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);\r\n    BOOL Arc(LPCRECT prc, POINT ptStart, POINT ptEnd);\r\n    BOOL Polyline(LPPOINT lpPoints, INT nCount);\r\n    BOOL AngleArc(INT x, INT y, INT nRadius, FLOAT fStartAngle,\r\n        FLOAT fSweepAngle);\r\n    BOOL ArcTo(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);\r\n    BOOL ArcTo(LPCRECT prc, POINT ptStart, POINT ptEnd);\r\n    INT GetArcDirection() const;\r\n    INT SetArcDirection(INT nAD_);\r\n    BOOL PolyDraw(CONST POINT* lpPoints, CONST BYTE* lpTypes, INT nCount);\r\n    BOOL PolylineTo(CONST POINT* lpPoints, INT nCount);\r\n    BOOL PolyPolyline(CONST POINT* lpPoints, CONST DWORD* lpPolyPoints,\r\n        INT nCount);\r\n    BOOL PolyBezier(CONST POINT* lpPoints, INT nCount);\r\n    BOOL PolyBezierTo(CONST POINT* lpPoints, INT nCount);\r\n    BOOL FillRect(LPCRECT prc, HBRUSH hBrush);\r\n    BOOL FillRect(LPCRECT prc, INT nCOLOR_);\r\n    VOID FillSolidRect(LPCRECT prc, COLORREF crColor);\r\n    VOID FillSolidRect(INT x, INT y, INT cx, INT cy, COLORREF crColor);\r\n    VOID Draw3dRect(LPCRECT prc, COLORREF clrTopLeft,\r\n        COLORREF clrBottomRight);\r\n    VOID Draw3dRect(INT x, INT y, INT cx, INT cy, COLORREF clrTopLeft,\r\n        COLORREF clrBottomRight);\r\n    BOOL FrameRect(LPCRECT prc, HBRUSH hBrush);\r\n    BOOL InvertRect(LPCRECT prc);\r\n    BOOL DrawIcon(INT x, INT y, HICON hIcon);\r\n    BOOL DrawIcon(POINT pt, HICON hIcon);\r\n    BOOL DrawIconEx(INT x, INT y, HICON hIcon, INT cx, INT cy,\r\n        UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL,\r\n        UINT uDI_flags = DI_NORMAL);\r\n    BOOL DrawIconEx(POINT pt, HICON hIcon, SIZE size,\r\n        UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL,\r\n        UINT uDI_flags = DI_NORMAL);\r\n    BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nDST_flags,\r\n        HBRUSH hBrush = NULL);\r\n    BOOL DrawState(POINT pt, SIZE size, HICON hIcon, UINT nDST_flags,\r\n        HBRUSH hBrush = NULL);\r\n    BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nDST_flags,\r\n        BOOL bPrefixText = TRUE, INT nTextLen = 0, HBRUSH hBrush = NULL);\r\n    BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc,\r\n        LPARAM lData, UINT nDST_flags, HBRUSH hBrush = NULL);\r\n    BOOL Chord(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);\r\n    BOOL Chord(LPCRECT prc, POINT ptStart, POINT ptEnd);\r\n    VOID DrawFocusRect(LPCRECT prc);\r\n    BOOL Ellipse(INT x1, INT y1, INT x2, INT y2);\r\n    BOOL Ellipse(POINT pt1, POINT pt2);\r\n    BOOL Ellipse(LPCRECT prc);\r\n    BOOL Circle(INT x, INT y, INT nRadius);\r\n    BOOL Circle(POINT pt, INT nRadius);\r\n    BOOL Pie(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);\r\n    BOOL Pie(LPCRECT prc, POINT ptStart, POINT ptEnd);\r\n    BOOL Polygon(LPPOINT lpPoints, INT nCount);\r\n    BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, INT nCount);\r\n    BOOL Rectangle(INT x1, INT y1, INT x2, INT y2);\r\n    BOOL Rectangle(LPCRECT prc);\r\n    BOOL RoundRect(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3);\r\n    BOOL RoundRect(LPCRECT prc, POINT pt);\r\n    BOOL PatBlt(INT x, INT y, INT cx, INT cy, DWORD dwRop = PATCOPY);\r\n    BOOL PatBlt(LPCRECT prc, DWORD dwRop = PATCOPY);\r\n    BOOL BitBlt(INT x, INT y, INT cx, INT cy, HDC hSrcDC,\r\n        INT xSrc = 0, INT ySrc = 0, DWORD dwRop = SRCCOPY);\r\n    BOOL BitBlt(LPCRECT prc, HDC hSrcDC, POINT ptSrc, DWORD dwRop = SRCCOPY);\r\n    BOOL StretchBlt(INT x, INT y, INT cx, INT cy,\r\n        HDC hSrcDC, INT xSrc, INT ySrc, INT cxSrc, INT cySrc, DWORD dwRop);\r\n    BOOL StretchBlt(LPCRECT prc, HDC hSrcDC, LPCRECT prcSrc, DWORD dwRop);\r\n\r\n    COLORREF GetPixel(INT x, INT y) const;\r\n    COLORREF GetPixel(POINT pt) const;\r\n    COLORREF SetPixel(INT x, INT y, COLORREF crColor);\r\n    COLORREF SetPixel(POINT pt, COLORREF crColor);\r\n    BOOL SetPixelV(INT x, INT y, COLORREF crColor);\r\n    BOOL SetPixelV(POINT pt, COLORREF crColor);\r\n\r\n    BOOL FloodFill(INT x, INT y, COLORREF crColor);\r\n    BOOL ExtFloodFill(INT x, INT y, COLORREF crColor, UINT nFillType);\r\n    BOOL MaskBlt(INT x, INT y, INT cx, INT cy, HDC hSrcDC, INT xSrc, INT ySrc,\r\n        HBITMAP hMaskBitmap, INT xMask, INT yMask, DWORD dwRop);\r\n    BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, INT xSrc, INT ySrc,\r\n        INT cxSrc, INT cySrc, HBITMAP hMaskBitmap, INT xMask, INT yMask);\r\n    BOOL DitherBlt(INT x, INT y, INT nWidth, INT nHeight, HDC hSrcDC,\r\n        HBITMAP hBitmap, INT xSrc, INT ySrc,\r\n        HBRUSH hBrushBackground = ::GetSysColorBrush(COLOR_3DFACE),\r\n        HBRUSH hBrush3DEffect = ::GetSysColorBrush(COLOR_3DHILIGHT),\r\n        HBRUSH hBrushDisabledImage = ::GetSysColorBrush(COLOR_3DSHADOW));\r\n    VOID GradientFill(COLORREF Color1, COLORREF Color2, LPRECT pRc,\r\n        BOOL bVertical);\r\n\r\n    BOOL TextOut(INT x, INT y, LPCTSTR lpsz, INT cch = -1);\r\n    BOOL ExtTextOut(INT x, INT y, UINT nOptions, LPCRECT prc,\r\n        LPCTSTR lpsz, UINT cch = (UINT)-1, LPINT lpDxWidths = NULL);\r\n    SIZE TabbedTextOut(INT x, INT y, LPCTSTR lpsz, INT cch = -1,\r\n        INT nTabPositions = 0, LPINT lpnTabStopPositions = NULL,\r\n        INT nTabOrigin = 0);\r\n    INT DrawText(LPCTSTR lpstrText, INT cchText, LPRECT prc, UINT uFormat);\r\n    INT DrawText(LPTSTR lpstrText, INT cchText, LPRECT prc, UINT uFormat);\r\n    INT DrawTextEx(LPTSTR lpstrText, INT cchText, LPRECT prc,\r\n        UINT uFormat, LPDRAWTEXTPARAMS lpDTParams = NULL);\r\n    MSize GetTextExtent(LPCTSTR lpszString) const;\r\n    MSize GetTextExtent(LPCTSTR lpszString, INT nCount) const;\r\n    BOOL GetTextExtent(LPCTSTR lpszString, INT nCount, LPSIZE lpSize) const;\r\n    BOOL GetTextExtentExPoint(LPCTSTR lpszString, INT cchString,\r\n        LPSIZE lpSize, INT nMaxExtent, LPINT lpnFit = NULL,\r\n        LPINT alpDx = NULL);\r\n    DWORD GetTabbedTextExtent(LPCTSTR lpszString, INT nCount = -1,\r\n        INT nTabPositions = 0, LPINT lpnTabStopPositions = NULL) const;\r\n    BOOL GrayString(HBRUSH hBrush,\r\n        BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, INT),\r\n        LPARAM lpData, INT nCount, INT x, INT y, INT nWidth, INT nHeight);\r\n    UINT GetTextAlign(VOID) const;\r\n    UINT SetTextAlign(UINT uTA_flags);\r\n    INT GetTextFace(LPTSTR lpszFacename, INT nCount) const;\r\n    INT GetTextFaceLen() const;\r\n    BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;\r\n    INT SetTextJustification(INT nBreakExtra, INT nBreakCount);\r\n    INT GetTextCharacterExtra() const;\r\n    INT SetTextCharacterExtra(INT nCharExtra);\r\n\r\n    BOOL DrawEdge(LPRECT prc, UINT nEdge, UINT nFlags);\r\n    BOOL DrawFrameControl(LPRECT prc, UINT nType, UINT nState);\r\n\r\n    BOOL ScrollDC(INT dx, INT dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,\r\n        HRGN hRgnUpdate, LPRECT lpRectUpdate);\r\n\r\n    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;\r\n    BOOL GetCharWidth32(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;\r\n    DWORD SetMapperFlags(DWORD dwFlag);\r\n    BOOL GetAspectRatioFilter(LPSIZE lpSize) const;\r\n    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const;\r\n    DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData,\r\n        DWORD cbData) const;\r\n    INT GetKerningPairs(INT nPairs, LPKERNINGPAIR lpkrnpair) const;\r\n    UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const;\r\n    DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,\r\n        DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const;\r\n    BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABCFLOAT lpABCF) const;\r\n    BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, PFLOAT lpFloatBuffer) const;\r\n#if (_WIN32_WINNT >= 0x0500)\r\n    DWORD GetFontUnicodeRanges(LPGLYPHSET lpgs) const;\r\n    DWORD GetGlyphIndices(LPCTSTR lpstr, INT cch, LPWORD pgi, DWORD dwFlags) const;\r\n    BOOL GetTextExtentPointI(LPWORD pgiIn, INT cgi, LPSIZE lpSize) const;\r\n    BOOL GetTextExtentExPointI(LPWORD pgiIn, INT cgi, INT nMaxExtent,\r\n        LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const;\r\n    BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const;\r\n    BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const;\r\n#endif  // (_WIN32_WINNT >= 0x0500)\r\n\r\n    INT Escape(INT nEscape, INT nCount, LPCSTR lpszInData, LPVOID lpOutData);\r\n    INT Escape(INT nEscape, INT nInputSize, LPCSTR lpszInputData,\r\n        INT nOutputSize, LPSTR lpszOutputData);\r\n    INT DrawEscape(INT nEscape, INT nInputSize, LPCSTR lpszInputData);\r\n    INT StartDoc(LPCTSTR lpszDocName);\r\n    INT StartDoc(LPDOCINFO lpDocInfo);\r\n    INT StartPage(VOID);\r\n    INT EndPage(VOID);\r\n    INT SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, INT));\r\n    INT AbortDoc(VOID);\r\n    INT EndDoc(VOID);\r\n\r\n    BOOL PlayMetaFile(HMETAFILE hMF);\r\n    BOOL PlayEnhMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds);\r\n    BOOL GdiComment(UINT nDataSize, CONST BYTE* pCommentData);\r\n\r\n    BOOL BeginPath();\r\n    BOOL EndPath();\r\n    BOOL CloseFigure();\r\n    BOOL AbortPath();\r\n    BOOL FillPath();\r\n    BOOL FlattenPath();\r\n    BOOL StrokeAndFillPath();\r\n    BOOL StrokePath();\r\n    BOOL WidenPath();\r\n\r\n    BOOL GetMiterLimit(PFLOAT pfMiterLimit) const;\r\n    BOOL SetMiterLimit(FLOAT fMiterLimit, PFLOAT peOldLimit = NULL);\r\n    INT GetPath(LPPOINT lpPoints, LPBYTE lpTypes, INT nCount) const;\r\n    BOOL SelectClipPath(INT nRGN_);\r\n\r\n    INT SetDIBitsToDevice(INT x, INT y, DWORD dwWidth, DWORD dwHeight,\r\n        INT xSrc, INT ySrc, UINT uStartScan, UINT cScanLines, LPCVOID lpvBits,\r\n        CONST BITMAPINFO* lpbmi, UINT uColorUse);\r\n    INT StretchDIBits(INT x, INT y, INT nWidth, INT nHeight,\r\n        INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, LPCVOID lpvBits,\r\n        CONST BITMAPINFO* lpbmi, UINT uColorUse, DWORD dwRop);\r\n    UINT GetDIBColorTable(UINT uStartIndex, UINT cEntries,\r\n        RGBQUAD* pColors) const;\r\n    UINT SetDIBColorTable(UINT uStartIndex, UINT cEntries,\r\n        CONST RGBQUAD* pColors);\r\n\r\nprivate:\r\n    // NOTE: MDC is not copyable.\r\n    MDC(const MDC& dc);\r\n    MDC& operator=(const MDC& dc);\r\n};\r\n\r\nINT CALLBACK EnumMetaFileProcDx(HDC hDC, HANDLETABLE* pHandleTable,\r\n    METARECORD* pMetaRec, INT nHandles, LPARAM lParam);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MMemoryDC : public MDC\r\n{\r\npublic:\r\n    MMemoryDC();\r\n    MMemoryDC(HDC hBaseDC);\r\n    BOOL CreateCompatibleDC(HDC hBaseDC = NULL);\r\n\r\nprivate:\r\n    // NOTE: MMemoryDC is not copyable.\r\n    MMemoryDC(const MMemoryDC& mdc);\r\n    MMemoryDC& operator=(const MMemoryDC& mdc);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MClientDC : public MDC\r\n{\r\npublic:\r\n    MClientDC();\r\n    MClientDC(HWND hWnd);\r\n    virtual ~MClientDC();\r\n\r\n    BOOL GetDC(HWND hWnd);\r\n    INT ReleaseDC();\r\n\r\npublic:\r\n    HWND m_hWnd;\r\n\r\nprivate:\r\n    // NOTE: MClientDC is not copyable.\r\n    MClientDC(const MClientDC& cdc);\r\n    MClientDC& operator=(const MClientDC& cdc);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MPaintDC : public MDC\r\n{\r\npublic:\r\n    MPaintDC();\r\n    MPaintDC(HWND hwnd);\r\n    virtual ~MPaintDC();\r\n\r\n    BOOL BeginPaint(HWND hWnd);\r\n    BOOL EndPaint();\r\n\r\npublic:\r\n    HWND m_hWnd;\r\n    PAINTSTRUCT m_ps;\r\n\r\nprivate:\r\n    // NOTE: MPaintDC is not copyable.\r\n    MPaintDC(const MPaintDC& pdc);\r\n    MPaintDC& operator=(const MPaintDC& pdc);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MWindowDC : public MDC\r\n{\r\npublic:\r\n    MWindowDC();\r\n    MWindowDC(HWND hWnd);\r\n    virtual ~MWindowDC();\r\n\r\n    BOOL GetWindowDC(HWND hWnd);\r\n    INT ReleaseDC();\r\n\r\npublic:\r\n    HWND m_hWnd;\r\n\r\nprivate:\r\n    // NOTE: MWindowDC is not copyable.\r\n    MWindowDC(const MWindowDC& wdc);\r\n    MWindowDC& operator=(const MWindowDC& wdc);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MMetaDC : public MDC\r\n{\r\npublic:\r\n    MMetaDC();\r\n    MMetaDC(HDC hDC);\r\n    MMetaDC(LPCTSTR pszFile);\r\n    virtual ~MMetaDC();\r\n\r\n    MMetaDC& operator=(HDC hDC);\r\n\r\n    BOOL CreateMetaFile(LPCTSTR pszFile = NULL);\r\n    HMETAFILE CloseMetaFile();\r\n    BOOL DeleteMetaFile();\r\n\r\nprivate:\r\n    // NOTE: MMetaDC is not copyable.\r\n    MMetaDC(const MMetaDC& mdc);\r\n    MMetaDC& operator=(const MMetaDC& mdc);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MEnhMetaDC : public MDC\r\n{\r\npublic:\r\n    MEnhMetaDC();\r\n    MEnhMetaDC(HDC hDC);\r\n    MEnhMetaDC(HDC hdcRef, LPCRECT prc, LPCTSTR pszFileName = NULL,\r\n        LPCTSTR pszDescription = NULL);\r\n    virtual ~MEnhMetaDC();\r\n\r\n    MEnhMetaDC& operator=(HDC hDC);\r\n\r\n    BOOL CreateEnhMetaFile(HDC hdcRef, LPCRECT prc, LPCTSTR pszFileName = NULL,\r\n        LPCTSTR pszDescription = NULL);\r\n    HENHMETAFILE CloseEnhMetaFile();\r\n    BOOL DeleteEnhMetaFile();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline FLOAT GetXDpiDx(VOID)\r\n{\r\n    FLOAT xdpi;\r\n    GetDpiDx(&xdpi, NULL);\r\n    return xdpi;\r\n}\r\n\r\ninline FLOAT GetYDpiDx(VOID)\r\n{\r\n    FLOAT ydpi;\r\n    GetDpiDx(NULL, &ydpi);\r\n    return ydpi;\r\n}\r\n\r\ninline FLOAT XDpiScaleDx(FLOAT xPixels, FLOAT base_xdpi/* = 96.0f*/)\r\n{\r\n    return xPixels * GetXDpiDx() / base_xdpi;\r\n}\r\n\r\ninline FLOAT YDpiScaleDx(FLOAT yPixels, FLOAT base_ydpi/* = 96.0f*/)\r\n{\r\n    return yPixels * GetYDpiDx() / base_ydpi;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MDC::MDC() : m_hDC(NULL)\r\n{\r\n}\r\n\r\ninline MDC::MDC(HDC hDC) : m_hDC(hDC)\r\n{\r\n}\r\n\r\ninline /*virtual*/ MDC::~MDC()\r\n{\r\n    DeleteDC();\r\n}\r\n\r\ninline MDC& MDC::operator=(HDC hDC)\r\n{\r\n    assert(hDC == NULL ||\r\n           ::GetObjectType(hDC) == OBJ_DC ||\r\n           ::GetObjectType(hDC) == OBJ_METADC ||\r\n           ::GetObjectType(hDC) == OBJ_ENHMETADC);\r\n    if (Handle() != hDC)\r\n    {\r\n        Attach(hDC);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MDC::Attach(HDC hDC)\r\n{\r\n    DeleteDC();\r\n    assert(::GetObjectType(hDC) == OBJ_DC ||\r\n           ::GetObjectType(hDC) == OBJ_METADC ||\r\n           ::GetObjectType(hDC) == OBJ_ENHMETADC);\r\n    m_hDC = hDC;\r\n    return m_hDC != NULL;\r\n}\r\n\r\ninline HDC MDC::Detach()\r\n{\r\n    HDC hDC = m_hDC;\r\n    m_hDC = NULL;\r\n    return hDC;\r\n}\r\n\r\ninline HDC MDC::Handle() const\r\n{\r\n    return (this ? m_hDC : NULL);\r\n}\r\n\r\ninline BOOL MDC::CreateDC(LPCTSTR pszDriver/* = NULL*/,\r\n    LPCTSTR pszDevice/* = NULL*/, LPCTSTR pszOutput/* = NULL*/,\r\n    CONST DEVMODE *lpInitData/* = NULL*/)\r\n{\r\n    return Attach(::CreateDC(pszDriver, pszDevice, pszOutput, lpInitData));\r\n}\r\n\r\ninline BOOL MDC::CreateCompatibleDC(HDC hBaseDC/* = NULL*/)\r\n{\r\n    return Attach(::CreateCompatibleDC(hBaseDC));\r\n}\r\n\r\ninline MDC::operator HDC() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline bool MDC::operator!() const\r\n{\r\n    return (Handle() == NULL);\r\n}\r\n\r\ninline HWND MDC::WindowFromDC() const\r\n{\r\n    assert(Handle());\r\n    return ::WindowFromDC(Handle());\r\n}\r\n\r\ninline BOOL MDC::DeleteDC()\r\n{\r\n    if (Handle())\r\n    {\r\n        assert(Handle());\r\n        return ::DeleteDC(Detach());\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline HPEN MDC::GetCurrentPen() const\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HPEN>(::GetCurrentObject(Handle(), OBJ_PEN));\r\n}\r\n\r\ninline HBRUSH MDC::GetCurrentBrush() const\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HBRUSH>(::GetCurrentObject(Handle(), OBJ_BRUSH));\r\n}\r\n\r\ninline HPALETTE MDC::GetCurrentPalette() const\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HPALETTE>(::GetCurrentObject(Handle(), OBJ_PAL));\r\n}\r\n\r\ninline HFONT MDC::GetCurrentFont() const\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HFONT>(::GetCurrentObject(Handle(), OBJ_FONT));\r\n}\r\n\r\ninline HBITMAP MDC::GetCurrentBitmap() const\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HBITMAP>(::GetCurrentObject(Handle(), OBJ_BITMAP));\r\n}\r\n\r\ninline INT MDC::SaveDC(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::SaveDC(Handle());\r\n}\r\n\r\ninline BOOL MDC::RestoreDC(INT nSavedDC)\r\n{\r\n    assert(Handle());\r\n    return ::RestoreDC(Handle(), nSavedDC);\r\n}\r\n\r\ninline INT MDC::GetDeviceCaps(INT nIndex) const\r\n{\r\n    assert(Handle());\r\n    return ::GetDeviceCaps(Handle(), nIndex);\r\n}\r\n\r\ninline UINT MDC::GetBoundsRect(LPRECT lpRectBounds, UINT uDCB_flags) const\r\n{\r\n    assert(Handle());\r\n    return ::GetBoundsRect(Handle(), lpRectBounds, uDCB_flags);\r\n}\r\n\r\ninline UINT MDC::SetBoundsRect(LPCRECT lpRectBounds, UINT uDCB_flags)\r\n{\r\n    assert(Handle());\r\n    return ::SetBoundsRect(Handle(), lpRectBounds, uDCB_flags);\r\n}\r\n\r\ninline BOOL MDC::ResetDC(CONST DEVMODE *lpDevMode)\r\n{\r\n    assert(Handle());\r\n    return ::ResetDC(Handle(), lpDevMode) != NULL;\r\n}\r\n\r\ninline BOOL MDC::GetBrushOrg(LPPOINT ppt) const\r\n{\r\n    assert(Handle());\r\n    return ::GetBrushOrgEx(Handle(), ppt);\r\n}\r\n\r\ninline BOOL MDC::SetBrushOrg(INT x, INT y, LPPOINT ppt/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetBrushOrgEx(Handle(), x, y, ppt);\r\n}\r\n\r\ninline BOOL MDC::SetBrushOrg(POINT pt, LPPOINT lpPointRet/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetBrushOrgEx(Handle(), pt.x, pt.y, lpPointRet);\r\n}\r\n\r\ninline INT MDC::EnumObjects(\r\n    INT nObjectType, INT (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)\r\n{\r\n    assert(Handle());\r\n    return ::EnumObjects(Handle(), nObjectType, (GOBJENUMPROC) lpfn, lpData);\r\n}\r\n\r\ninline HGDIOBJ MDC::SelectStockObject(INT nIndex)\r\n{\r\n    assert(Handle());\r\n    return ::SelectObject(Handle(), ::GetStockObject(nIndex));\r\n}\r\n\r\ninline HPEN MDC::SelectObject(HPEN hPen)\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HPEN>(::SelectObject(Handle(), hPen));\r\n}\r\n\r\ninline HBRUSH MDC::SelectObject(HBRUSH hBrush)\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HBRUSH>(::SelectObject(Handle(), hBrush));\r\n}\r\n\r\ninline HFONT MDC::SelectObject(HFONT hFont) \r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HFONT>(::SelectObject(Handle(), hFont));\r\n}\r\n\r\ninline HBITMAP MDC::SelectObject(HBITMAP hBitmap)\r\n{\r\n    assert(Handle());\r\n    return reinterpret_cast<HBITMAP>(::SelectObject(Handle(), hBitmap));\r\n}\r\n\r\ninline INT MDC::SelectObject(HRGN hRgn)\r\n{\r\n    assert(Handle());\r\n    return static_cast<INT>(reinterpret_cast<INT_PTR>(::SelectObject(Handle(), hRgn)));\r\n}\r\n\r\ninline HGDIOBJ MDC::SelectObject(HGDIOBJ hGdiObj)\r\n{\r\n    assert(Handle());\r\n    return ::SelectObject(Handle(), hGdiObj);\r\n}\r\n\r\ninline HPALETTE MDC::SelectPalette(\r\n    HPALETTE hPal, BOOL bForceBackground/* = FALSE*/)\r\n{\r\n    assert(Handle());\r\n    return ::SelectPalette(Handle(), hPal, bForceBackground);\r\n}\r\n\r\ninline COLORREF MDC::GetNearestColor(COLORREF crColor) const\r\n{\r\n    assert(Handle());\r\n    return ::GetNearestColor(Handle(), crColor);\r\n}\r\n\r\ninline UINT MDC::RealizePalette(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::RealizePalette(Handle());\r\n}\r\n\r\ninline VOID MDC::UpdateColors(VOID)\r\n{\r\n    assert(Handle());\r\n    ::UpdateColors(Handle());\r\n}\r\n\r\ninline COLORREF MDC::GetBkColor() const\r\n{\r\n    assert(Handle());\r\n    return ::GetBkColor(Handle());\r\n}\r\n\r\ninline INT MDC::GetBkMode() const\r\n{\r\n    assert(Handle());\r\n    return ::GetBkMode(Handle());\r\n}\r\n\r\ninline INT MDC::GetPolyFillMode() const\r\n{\r\n    assert(Handle());\r\n    return ::GetPolyFillMode(Handle());\r\n}\r\n\r\ninline INT MDC::GetROP2() const\r\n{\r\n    assert(Handle());\r\n    return ::GetROP2(Handle());\r\n}\r\n\r\ninline INT MDC::GetStretchBltMode() const\r\n{\r\n    assert(Handle());\r\n    return ::GetStretchBltMode(Handle());\r\n}\r\n\r\ninline COLORREF MDC::GetTextColor() const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextColor(Handle());\r\n}\r\n\r\ninline COLORREF MDC::SetBkColor(COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetBkColor(Handle(), crColor);\r\n}\r\n\r\ninline INT MDC::SetBkMode(INT nBkMode)\r\n{\r\n    assert(Handle());\r\n    return ::SetBkMode(Handle(), nBkMode);\r\n}\r\n\r\ninline INT MDC::SetPolyFillMode(INT nPolyFillMode)\r\n{\r\n    assert(Handle());\r\n    return ::SetPolyFillMode(Handle(), nPolyFillMode);\r\n}\r\n\r\ninline INT MDC::SetROP2(INT nR2_)\r\n{\r\n    assert(Handle());\r\n    return ::SetROP2(Handle(), nR2_);\r\n}\r\n\r\ninline INT MDC::SetStretchBltMode(INT nSTRETCH_)\r\n{\r\n    assert(Handle());\r\n    return ::SetStretchBltMode(Handle(), nSTRETCH_);\r\n}\r\n\r\ninline COLORREF MDC::SetTextColor(COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetTextColor(Handle(), crColor);\r\n}\r\n\r\n#if (_WIN32_WINNT >= 0x0500)\r\n    inline COLORREF MDC::GetDCBrushColor()\r\n    {\r\n        assert(Handle());\r\n        return ::GetDCBrushColor(Handle());\r\n    }\r\n\r\n    inline COLORREF MDC::GetDCPenColor()\r\n    {\r\n        assert(Handle());\r\n        return ::GetDCPenColor(Handle());\r\n    }\r\n#endif  //  (_WIN32_WINNT >= 0x0500)\r\n\r\ninline BOOL MDC::GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const\r\n{\r\n    assert(Handle());\r\n    return ::GetColorAdjustment(Handle(), lpColorAdjust);\r\n}\r\n\r\ninline BOOL MDC::SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)\r\n{\r\n    assert(Handle());\r\n    return ::SetColorAdjustment(Handle(), lpColorAdjust);\r\n}\r\n\r\ninline INT MDC::GetMapMode() const\r\n{\r\n    assert(Handle());\r\n    return ::GetMapMode(Handle());\r\n}\r\n\r\ninline BOOL MDC::GetViewportOrg(LPPOINT lpPoint) const\r\n{\r\n    assert(Handle());\r\n    return ::GetViewportOrgEx(Handle(), lpPoint);\r\n}\r\n\r\ninline INT MDC::SetMapMode(INT nMapMode)\r\n{\r\n    assert(Handle());\r\n    return ::SetMapMode(Handle(), nMapMode);\r\n}\r\n\r\ninline BOOL MDC::SetViewportOrg(POINT pt, LPPOINT lpPointRet/* = NULL*/)\r\n{\r\n    return SetViewportOrg(pt.x, pt.y, lpPointRet);\r\n}\r\n\r\ninline BOOL MDC::GetViewportExt(LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    return ::GetViewportExtEx(Handle(), lpSize);\r\n}\r\n\r\ninline BOOL MDC::SetViewportExt(SIZE size, LPSIZE lpSizeRet/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return SetViewportExt(size.cx, size.cy, lpSizeRet);\r\n}\r\n\r\ninline BOOL MDC::ScaleViewportExt(\r\n    INT xNum, INT xDenom, INT yNum, INT yDenom, LPSIZE lpSize/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::ScaleViewportExtEx(Handle(), xNum, xDenom, yNum, yDenom, lpSize);\r\n}\r\n\r\ninline BOOL MDC::GetWindowOrg(LPPOINT lpPoint) const\r\n{\r\n    assert(Handle());\r\n    return ::GetWindowOrgEx(Handle(), lpPoint);\r\n}\r\n\r\ninline BOOL MDC::SetWindowOrg(POINT pt, LPPOINT lpPointRet/* = NULL*/)\r\n{\r\n    return SetWindowOrg(pt.x, pt.y, lpPointRet);\r\n}\r\n\r\ninline BOOL MDC::OffsetWindowOrg(\r\n    INT nWidth, INT nHeight, LPPOINT lpPoint/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetWindowOrgEx(Handle(), nWidth, nHeight, lpPoint);\r\n}\r\n\r\ninline BOOL MDC::GetWindowExt(LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    return ::GetWindowExtEx(Handle(), lpSize);\r\n}\r\n\r\ninline BOOL MDC::SetWindowExt(SIZE size, LPSIZE lpSizeRet/* = NULL*/)\r\n{\r\n    return SetWindowExt(size.cx, size.cy, lpSizeRet);\r\n}\r\n\r\ninline BOOL MDC::ScaleWindowExt(INT xNum, INT xDenom,\r\n    INT yNum, INT yDenom, LPSIZE lpSize/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::ScaleWindowExtEx(Handle(), xNum, xDenom, yNum, yDenom, lpSize);\r\n}\r\n\r\ninline BOOL MDC::DPtoLP(LPPOINT lpPoints, INT nCount/* = 1*/) const\r\n{\r\n    assert(Handle());\r\n    return ::DPtoLP(Handle(), lpPoints, nCount);\r\n}\r\n\r\ninline BOOL MDC::DPtoLP(LPRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::DPtoLP(Handle(), (LPPOINT) prc, 2);\r\n}\r\n\r\ninline BOOL MDC::DPtoLP(LPSIZE lpSize) const\r\n{\r\n    SIZE sizeWinExt;\r\n    sizeWinExt.cx = sizeWinExt.cy = 0;\r\n    if (!GetWindowExt(&sizeWinExt))\r\n        return FALSE;\r\n    SIZE sizeVpExt;\r\n    sizeVpExt.cx = sizeVpExt.cy = 0;\r\n    if (!GetViewportExt(&sizeVpExt))\r\n        return FALSE;\r\n    lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));\r\n    lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MDC::LPtoDP(LPPOINT lpPoints, INT nCount/* = 1*/) const\r\n{\r\n    assert(Handle());\r\n    return ::LPtoDP(Handle(), lpPoints, nCount);\r\n}\r\n\r\ninline BOOL MDC::LPtoDP(LPRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::LPtoDP(Handle(), (LPPOINT) prc, 2);\r\n}\r\n\r\ninline BOOL MDC::LPtoDP(LPSIZE lpSize) const\r\n{\r\n    SIZE sizeWinExt;\r\n    sizeWinExt.cx = sizeWinExt.cy = 0;\r\n    if (!GetWindowExt(&sizeWinExt))\r\n        return FALSE;\r\n    SIZE sizeVpExt;\r\n    sizeVpExt.cx = sizeVpExt.cy = 0;\r\n    if (!GetViewportExt(&sizeVpExt))\r\n        return FALSE;\r\n    lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));\r\n    lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));\r\n    return TRUE;\r\n}\r\n\r\ninline VOID MDC::DPtoHIMETRIC(LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    INT nMapMode;\r\n    if ((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)\r\n    {\r\n        // when using a constrained map mode, map against physical inch\r\n        ::SetMapMode(Handle(), MM_HIMETRIC);\r\n        DPtoLP(lpSize);\r\n        ::SetMapMode(Handle(), nMapMode);\r\n    }\r\n    else\r\n    {\r\n        // map against logical inch for non-constrained mapping modes\r\n        INT cxPerInch = GetDeviceCaps(LOGPIXELSX);\r\n        INT cyPerInch = GetDeviceCaps(LOGPIXELSY);\r\n        assert(cxPerInch != 0 && cyPerInch != 0);\r\n        lpSize->cx = ::MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);\r\n        lpSize->cy = ::MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);\r\n    }\r\n}\r\n\r\ninline VOID MDC::HIMETRICtoDP(LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    INT nMapMode;\r\n    if ((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)\r\n    {\r\n        // when using a constrained map mode, map against physical inch\r\n        ::SetMapMode(Handle(), MM_HIMETRIC);\r\n        LPtoDP(lpSize);\r\n        ::SetMapMode(Handle(), nMapMode);\r\n    }\r\n    else\r\n    {\r\n        // map against logical inch for non-constrained mapping modes\r\n        INT cxPerInch = GetDeviceCaps(LOGPIXELSX);\r\n        INT cyPerInch = GetDeviceCaps(LOGPIXELSY);\r\n        assert(cxPerInch != 0 && cyPerInch != 0);\r\n        lpSize->cx = ::MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);\r\n        lpSize->cy = ::MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);\r\n    }\r\n}\r\n\r\ninline VOID MDC::LPtoHIMETRIC(LPSIZE lpSize) const\r\n{\r\n    LPtoDP(lpSize);\r\n    DPtoHIMETRIC(lpSize);\r\n}\r\n\r\ninline VOID MDC::HIMETRICtoLP(LPSIZE lpSize) const\r\n{\r\n    HIMETRICtoDP(lpSize);\r\n    DPtoLP(lpSize);\r\n}\r\n\r\ninline BOOL MDC::FillRgn(HRGN hRgn, HBRUSH hBrush)\r\n{\r\n    assert(Handle());\r\n    return ::FillRgn(Handle(), hRgn, hBrush);\r\n}\r\n\r\ninline BOOL MDC::FrameRgn(\r\n    HRGN hRgn, HBRUSH hBrush, INT nWidth, INT nHeight)\r\n{\r\n    assert(Handle());\r\n    return ::FrameRgn(Handle(), hRgn, hBrush, nWidth, nHeight);\r\n}\r\n\r\ninline BOOL MDC::InvertRgn(HRGN hRgn)\r\n{\r\n    assert(Handle());\r\n    return ::InvertRgn(Handle(), hRgn);\r\n}\r\n\r\ninline BOOL MDC::PaintRgn(HRGN hRgn)\r\n{\r\n    assert(Handle());\r\n    return ::PaintRgn(Handle(), hRgn);\r\n}\r\n\r\ninline INT MDC::GetClipBox(LPRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::GetClipBox(Handle(), prc);\r\n}\r\n\r\ninline INT MDC::GetClipRgn(HRGN hRgn) const\r\n{\r\n    assert(Handle());\r\n    INT nRet = ::GetClipRgn(Handle(), hRgn);\r\n    return nRet;\r\n}\r\n\r\ninline BOOL MDC::PtVisible(INT x, INT y) const\r\n{\r\n    assert(Handle());\r\n    return ::PtVisible(Handle(), x, y);\r\n}\r\n\r\ninline BOOL MDC::PtVisible(POINT pt) const\r\n{\r\n    assert(Handle());\r\n    return ::PtVisible(Handle(), pt.x, pt.y);\r\n}\r\n\r\ninline BOOL MDC::RectVisible(LPCRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::RectVisible(Handle(), prc);\r\n}\r\n\r\ninline INT MDC::SelectClipRgn(HRGN hRgn)\r\n{\r\n    assert(Handle());\r\n    return ::SelectClipRgn(Handle(), (HRGN) hRgn);\r\n}\r\n\r\ninline INT MDC::ExcludeClipRect(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    assert(Handle());\r\n    return ::ExcludeClipRect(Handle(), x1, y1, x2, y2);\r\n}\r\n\r\ninline INT MDC::ExcludeClipRect(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    return ::ExcludeClipRect(Handle(),\r\n        prc->left, prc->top, prc->right, prc->bottom);\r\n}\r\n\r\ninline INT MDC::ExcludeUpdateRgn(HWND hWnd)\r\n{\r\n    assert(Handle());\r\n    return ::ExcludeUpdateRgn(Handle(), hWnd);\r\n}\r\n\r\ninline INT MDC::IntersectClipRect(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    assert(Handle());\r\n    return ::IntersectClipRect(Handle(), x1, y1, x2, y2);\r\n}\r\n\r\ninline INT MDC::IntersectClipRect(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    return ::IntersectClipRect(Handle(),\r\n        prc->left, prc->top, prc->right, prc->bottom);\r\n}\r\n\r\ninline INT MDC::OffsetClipRgn(INT x, INT y)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetClipRgn(Handle(), x, y);\r\n}\r\n\r\ninline INT MDC::OffsetClipRgn(SIZE size)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetClipRgn(Handle(), size.cx, size.cy);\r\n}\r\n\r\ninline INT MDC::SelectClipRgn(HRGN hRgn, INT nMode)\r\n{\r\n    assert(Handle());\r\n    return ::ExtSelectClipRgn(Handle(), hRgn, nMode);\r\n}\r\n\r\ninline BOOL MDC::GetCurrentPosition(LPPOINT lpPoint) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCurrentPositionEx(Handle(), lpPoint);\r\n}\r\n\r\ninline BOOL MDC::MoveTo(INT x, INT y, LPPOINT lpPoint/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::MoveToEx(Handle(), x, y, lpPoint);\r\n}\r\n\r\ninline BOOL MDC::MoveTo(POINT pt, LPPOINT lpPointRet/* = NULL*/)\r\n{\r\n    return MoveTo(pt.x, pt.y, lpPointRet);\r\n}\r\n\r\ninline BOOL MDC::LineTo(INT x, INT y)\r\n{\r\n    assert(Handle());\r\n    return ::LineTo(Handle(), x, y);\r\n}\r\n\r\ninline BOOL MDC::LineTo(POINT pt)\r\n{\r\n    assert(Handle());\r\n    return LineTo(pt.x, pt.y);\r\n}\r\n\r\ninline BOOL MDC::Line(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    return MoveTo(x1, y1) && LineTo(x2, y2);\r\n}\r\n\r\ninline BOOL MDC::Line(POINT pt1, POINT pt2)\r\n{\r\n    return MoveTo(pt1) && LineTo(pt2);\r\n}\r\n\r\ninline BOOL MDC::Arc(\r\n    INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4)\r\n{\r\n    assert(Handle());\r\n    return ::Arc(Handle(), x1, y1, x2, y2, x3, y3, x4, y4);\r\n}\r\n\r\ninline BOOL MDC::Arc(LPCRECT prc, POINT ptStart, POINT ptEnd)\r\n{\r\n    assert(Handle());\r\n    return ::Arc(Handle(), prc->left, prc->top,\r\n        prc->right, prc->bottom, ptStart.x, ptStart.y,\r\n        ptEnd.x, ptEnd.y);\r\n}\r\n\r\ninline BOOL MDC::Polyline(LPPOINT lpPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::Polyline(Handle(), lpPoints, nCount);\r\n}\r\n\r\ninline BOOL MDC::AngleArc(\r\n    INT x, INT y, INT nRadius, FLOAT fStartAngle, FLOAT fSweepAngle)\r\n{\r\n    assert(Handle());\r\n    return ::AngleArc(Handle(), x, y, (DWORD) nRadius, fStartAngle, fSweepAngle);\r\n}\r\n\r\ninline BOOL MDC::ArcTo(\r\n    INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4)\r\n{\r\n    assert(Handle());\r\n    return ::ArcTo(Handle(), x1, y1, x2, y2, x3, y3, x4, y4);\r\n}\r\n\r\ninline BOOL MDC::ArcTo(LPCRECT prc, POINT ptStart, POINT ptEnd)\r\n{\r\n    return ArcTo(prc->left, prc->top, prc->right,\r\n                 prc->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);\r\n}\r\n\r\ninline INT MDC::GetArcDirection() const\r\n{\r\n    assert(Handle());\r\n    return ::GetArcDirection(Handle());\r\n}\r\n\r\ninline INT MDC::SetArcDirection(INT nAD_)\r\n{\r\n    assert(Handle());\r\n    return ::SetArcDirection(Handle(), nAD_);\r\n}\r\n\r\ninline BOOL MDC::PolyDraw(\r\n    CONST POINT* lpPoints, CONST BYTE* lpTypes, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolyDraw(Handle(), lpPoints, lpTypes, nCount);\r\n}\r\n\r\ninline BOOL MDC::PolylineTo(CONST POINT* lpPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolylineTo(Handle(), lpPoints, static_cast<DWORD>(nCount));\r\n}\r\n\r\ninline BOOL MDC::PolyPolyline(\r\n    CONST POINT* lpPoints, CONST DWORD* lpPolyPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolyPolyline(Handle(), lpPoints, lpPolyPoints, static_cast<DWORD>(nCount));\r\n}\r\n\r\ninline BOOL MDC::PolyBezier(CONST POINT* lpPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolyBezier(Handle(), lpPoints, static_cast<DWORD>(nCount));\r\n}\r\n\r\ninline BOOL MDC::PolyBezierTo(CONST POINT* lpPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolyBezierTo(Handle(), lpPoints, static_cast<DWORD>(nCount));\r\n}\r\n\r\ninline BOOL MDC::FillRect(LPCRECT prc, HBRUSH hBrush)\r\n{\r\n    assert(Handle());\r\n    return ::FillRect(Handle(), prc, hBrush);\r\n}\r\n\r\ninline BOOL MDC::FillRect(LPCRECT prc, INT nCOLOR_)\r\n{\r\n    assert(Handle());\r\n    return ::FillRect(Handle(), prc, reinterpret_cast<HBRUSH>(static_cast<INT_PTR>(nCOLOR_ + 1)));\r\n}\r\n\r\ninline BOOL MDC::FrameRect(LPCRECT prc, HBRUSH hBrush)\r\n{\r\n    assert(Handle());\r\n    return ::FrameRect(Handle(), prc, hBrush);\r\n}\r\n\r\ninline BOOL MDC::InvertRect(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    return ::InvertRect(Handle(), prc);\r\n}\r\n\r\ninline BOOL MDC::DrawIcon(INT x, INT y, HICON hIcon)\r\n{\r\n    assert(Handle());\r\n    return ::DrawIcon(Handle(), x, y, hIcon);\r\n}\r\n\r\ninline BOOL MDC::DrawIcon(POINT pt, HICON hIcon)\r\n{\r\n    assert(Handle());\r\n    return ::DrawIcon(Handle(), pt.x, pt.y, hIcon);\r\n}\r\n\r\ninline BOOL MDC::DrawIconEx(INT x, INT y, HICON hIcon, INT cx, INT cy,\r\n    UINT uStepIfAniCur/* = 0*/, HBRUSH hbrFlickerFreeDraw/* = NULL*/,\r\n    UINT uDI_flags/* = DI_NORMAL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawIconEx(Handle(), x, y, hIcon, cx, cy,\r\n                        uStepIfAniCur, hbrFlickerFreeDraw, uDI_flags);\r\n}\r\n\r\ninline BOOL MDC::DrawIconEx(POINT pt, HICON hIcon, SIZE size,\r\n    UINT uStepIfAniCur/* = 0*/, HBRUSH hbrFlickerFreeDraw/* = NULL*/,\r\n    UINT uDI_flags/* = DI_NORMAL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawIconEx(Handle(), pt.x, pt.y, hIcon, size.cx, size.cy,\r\n                        uStepIfAniCur, hbrFlickerFreeDraw, uDI_flags);\r\n}\r\n\r\ninline BOOL MDC::DrawState(POINT pt, SIZE size, HBITMAP hBitmap,\r\n    UINT nDST_flags, HBRUSH hBrush/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawState(Handle(), hBrush, NULL, (LPARAM)hBitmap, 0,\r\n        pt.x, pt.y, size.cx, size.cy, nDST_flags | DST_BITMAP);\r\n}\r\n\r\ninline BOOL MDC::DrawState(POINT pt, SIZE size, HICON hIcon,\r\n    UINT nDST_flags, HBRUSH hBrush/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawState(Handle(), hBrush, NULL, (LPARAM)hIcon, 0,\r\n                       pt.x, pt.y, size.cx, size.cy, nDST_flags | DST_ICON);\r\n}\r\n\r\ninline BOOL MDC::DrawState(POINT pt, SIZE size, LPCTSTR lpszText,\r\n    UINT nDST_flags, BOOL bPrefixText/* = TRUE*/, INT nTextLen/* = 0*/,\r\n    HBRUSH hBrush/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawState(Handle(), hBrush, NULL, (LPARAM)lpszText,\r\n                       (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy,\r\n                       nDST_flags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));\r\n}\r\n\r\ninline BOOL MDC::DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc,\r\n    LPARAM lData, UINT nDST_flags, HBRUSH hBrush/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawState(Handle(), hBrush, lpDrawProc, lData, 0,\r\n                       pt.x, pt.y, size.cx, size.cy, nDST_flags | DST_COMPLEX);\r\n}\r\n\r\ninline BOOL MDC::Chord(\r\n    INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4)\r\n{\r\n    assert(Handle());\r\n    return ::Chord(Handle(), x1, y1, x2, y2, x3, y3, x4, y4);\r\n}\r\n\r\ninline BOOL MDC::Chord(LPCRECT prc, POINT ptStart, POINT ptEnd)\r\n{\r\n    assert(Handle());\r\n    return ::Chord(Handle(), prc->left, prc->top,\r\n        prc->right, prc->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);\r\n}\r\n\r\ninline VOID MDC::DrawFocusRect(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    ::DrawFocusRect(Handle(), prc);\r\n}\r\n\r\ninline BOOL MDC::Ellipse(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    assert(Handle());\r\n    return ::Ellipse(Handle(), x1, y1, x2, y2);\r\n}\r\n\r\ninline BOOL MDC::Ellipse(POINT pt1, POINT pt2)\r\n{\r\n    return MDC::Ellipse(pt1.x, pt1.y, pt2.x, pt2.y);\r\n}\r\n\r\ninline BOOL MDC::Ellipse(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    return ::Ellipse(Handle(),\r\n        prc->left, prc->top, prc->right, prc->bottom);\r\n}\r\n\r\ninline BOOL MDC::Circle(INT x, INT y, INT nRadius)\r\n{\r\n    return MDC::Ellipse(x - nRadius, y - nRadius, x + nRadius, y + nRadius);\r\n}\r\n\r\ninline BOOL MDC::Circle(POINT pt, INT nRadius)\r\n{\r\n    return MDC::Circle(pt.x, pt.y, nRadius);\r\n}\r\n\r\ninline BOOL MDC::Pie(\r\n    INT x1, INT y1, INT x2, INT y2, INT x3, INT y3, INT x4, INT y4)\r\n{\r\n    assert(Handle());\r\n    return ::Pie(Handle(), x1, y1, x2, y2, x3, y3, x4, y4);\r\n}\r\n\r\ninline BOOL MDC::Pie(LPCRECT prc, POINT ptStart, POINT ptEnd)\r\n{\r\n    assert(Handle());\r\n    return ::Pie(Handle(), prc->left, prc->top, prc->right,\r\n        prc->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);\r\n}\r\n\r\ninline BOOL MDC::Polygon(LPPOINT lpPoints, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::Polygon(Handle(), lpPoints, nCount);\r\n}\r\n\r\ninline BOOL MDC::PolyPolygon(\r\n    LPPOINT lpPoints, LPINT lpPolyCounts, INT nCount)\r\n{\r\n    assert(Handle());\r\n    return ::PolyPolygon(Handle(), lpPoints, lpPolyCounts, nCount);\r\n}\r\n\r\ninline BOOL MDC::Rectangle(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    assert(Handle());\r\n    return ::Rectangle(Handle(), x1, y1, x2, y2);\r\n}\r\n\r\ninline BOOL MDC::Rectangle(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    return ::Rectangle(Handle(),\r\n        prc->left, prc->top, prc->right, prc->bottom);\r\n}\r\n\r\ninline BOOL MDC::RoundRect(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3)\r\n{\r\n    assert(Handle());\r\n    return ::RoundRect(Handle(), x1, y1, x2, y2, x3, y3);\r\n}\r\n\r\ninline BOOL MDC::RoundRect(LPCRECT prc, POINT pt)\r\n{\r\n    assert(Handle());\r\n    return ::RoundRect(Handle(), prc->left, prc->top,\r\n        prc->right, prc->bottom, pt.x, pt.y);\r\n}\r\n\r\ninline BOOL MDC::PatBlt(INT x, INT y, INT cx, INT cy, DWORD dwRop/* = PATCOPY*/)\r\n{\r\n    assert(Handle());\r\n    return ::PatBlt(Handle(), x, y, cx, cy, dwRop);\r\n}\r\n\r\ninline BOOL MDC::BitBlt(INT x, INT y, INT cx, INT cy,\r\n    HDC hSrcDC, INT xSrc/* = 0*/, INT ySrc/* = 0*/, DWORD dwRop/* = SRCCOPY*/)\r\n{\r\n    assert(Handle());\r\n    return ::BitBlt(Handle(), x, y, cx, cy, hSrcDC, xSrc, ySrc, dwRop);\r\n}\r\n\r\ninline BOOL MDC::StretchBlt(INT x, INT y, INT cx, INT cy,\r\n    HDC hSrcDC, INT xSrc, INT ySrc, INT cxSrc, INT cySrc, DWORD dwRop)\r\n{\r\n    assert(Handle());\r\n    return ::StretchBlt(Handle(), x, y, cx, cy,\r\n        hSrcDC, xSrc, ySrc, cxSrc, cySrc, dwRop);\r\n}\r\n\r\ninline BOOL MDC::StretchBlt(\r\n    LPCRECT prc, HDC hSrcDC, LPCRECT prcSrc, DWORD dwRop)\r\n{\r\n    MRect rc(prc), rcSrc(prcSrc);\r\n    return StretchBlt(rc.left, rc.top, rc.Width(), rc.Height(),\r\n        hSrcDC, rcSrc.left, rcSrc.top, rcSrc.Width(), rcSrc.Height(), dwRop);\r\n}\r\n\r\ninline COLORREF MDC::GetPixel(INT x, INT y) const\r\n{\r\n    assert(Handle());\r\n    return ::GetPixel(Handle(), x, y);\r\n}\r\n\r\ninline COLORREF MDC::GetPixel(POINT pt) const\r\n{\r\n    assert(Handle());\r\n    return ::GetPixel(Handle(), pt.x, pt.y);\r\n}\r\n\r\ninline COLORREF MDC::SetPixel(INT x, INT y, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetPixel(Handle(), x, y, crColor);\r\n}\r\n\r\ninline COLORREF MDC::SetPixel(POINT pt, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetPixel(Handle(), pt.x, pt.y, crColor);\r\n}\r\n\r\ninline BOOL MDC::FloodFill(INT x, INT y, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::FloodFill(Handle(), x, y, crColor);\r\n}\r\n\r\ninline BOOL MDC::ExtFloodFill(INT x, INT y, COLORREF crColor, UINT nFillType)\r\n{\r\n    assert(Handle());\r\n    return ::ExtFloodFill(Handle(), x, y, crColor, nFillType);\r\n}\r\n\r\ninline BOOL MDC::MaskBlt(INT x, INT y, INT cx, INT cy,\r\n    HDC hSrcDC, INT xSrc, INT ySrc, HBITMAP hMaskBitmap,\r\n    INT xMask, INT yMask, DWORD dwRop)\r\n{\r\n    assert(Handle());\r\n    return ::MaskBlt(Handle(), x, y, cx, cy,\r\n                     hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);\r\n}\r\n\r\ninline BOOL MDC::PlgBlt(LPPOINT lpPoint, HDC hSrcDC, INT xSrc, INT ySrc,\r\n    INT cxSrc, INT cySrc, HBITMAP hMaskBitmap, INT xMask, INT yMask)\r\n{\r\n    assert(Handle());\r\n    return ::PlgBlt(Handle(), lpPoint, hSrcDC, xSrc, ySrc, cxSrc, cySrc,\r\n                    hMaskBitmap, xMask, yMask);\r\n}\r\n\r\ninline BOOL MDC::SetPixelV(INT x, INT y, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetPixelV(Handle(), x, y, crColor);\r\n}\r\n\r\ninline BOOL MDC::SetPixelV(POINT pt, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    return ::SetPixelV(Handle(), pt.x, pt.y, crColor);\r\n}\r\n\r\ninline BOOL MDC::TextOut(INT x, INT y, LPCTSTR lpsz, INT cch/* = -1*/)\r\n{\r\n    assert(Handle());\r\n    if(cch == -1)\r\n        cch = lstrlen(lpsz);\r\n    return ::TextOut(Handle(), x, y, lpsz, cch);\r\n}\r\n\r\ninline SIZE MDC::TabbedTextOut(INT x, INT y, LPCTSTR lpsz,\r\n    INT cch/* = -1*/, INT nTabPositions/* = 0*/,\r\n    LPINT lpnTabStopPositions/* = NULL*/, INT nTabOrigin/* = 0*/)\r\n{\r\n    assert(Handle());\r\n    if (cch == -1) cch = lstrlen(lpsz);\r\n    LONG lRes = ::TabbedTextOut(\r\n        Handle(), x, y, lpsz, cch, nTabPositions, lpnTabStopPositions, nTabOrigin);\r\n    SIZE size;\r\n    size.cx = (SHORT) LOWORD(lRes);\r\n    size.cy = (SHORT) HIWORD(lRes);\r\n    return size;\r\n}\r\n\r\ninline INT MDC::DrawText(\r\n    LPCTSTR lpstrText, INT cchText, LPRECT prc, UINT uFormat)\r\n{\r\n    assert(Handle());\r\n    assert((uFormat & DT_MODIFYSTRING) == 0);\r\n    return ::DrawText(Handle(), lpstrText, cchText, prc, uFormat);\r\n}\r\n\r\ninline INT MDC::DrawText(\r\n    LPTSTR lpstrText, INT cchText, LPRECT prc, UINT uFormat)\r\n{\r\n    assert(Handle());\r\n    return ::DrawText(Handle(), lpstrText, cchText, prc, uFormat);\r\n}\r\n\r\ninline INT MDC::DrawTextEx(LPTSTR lpstrText, INT cchText,\r\n    LPRECT prc, UINT uFormat, LPDRAWTEXTPARAMS lpDTParams/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::DrawTextEx(Handle(), lpstrText, cchText, prc, uFormat, lpDTParams);\r\n}\r\n\r\ninline MSize MDC::GetTextExtent(LPCTSTR lpszString, INT nCount) const\r\n{\r\n    MSize siz;\r\n    MDC::GetTextExtent(lpszString, nCount, &siz);\r\n    return siz;\r\n}\r\n\r\ninline BOOL MDC::GetTextExtent(\r\n    LPCTSTR lpszString, INT nCount, LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    if (nCount == -1) nCount = lstrlen(lpszString);\r\n    return ::GetTextExtentPoint32(Handle(), lpszString, nCount, lpSize);\r\n}\r\n\r\ninline BOOL MDC::GetTextExtentExPoint(LPCTSTR lpszString, INT cchString,\r\n    LPSIZE lpSize, INT nMaxExtent, LPINT lpnFit/* = NULL*/,\r\n    LPINT alpDx/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::GetTextExtentExPoint(Handle(), lpszString, cchString,\r\n        nMaxExtent, lpnFit, alpDx, lpSize);\r\n}\r\n\r\ninline DWORD MDC::GetTabbedTextExtent(LPCTSTR lpszString,\r\n    INT nCount/* = -1*/, INT nTabPositions/* = 0*/,\r\n    LPINT lpnTabStopPositions/* = NULL*/) const\r\n{\r\n    assert(Handle());\r\n    if (nCount == -1)\r\n        nCount = lstrlen(lpszString);\r\n    return ::GetTabbedTextExtent(Handle(), lpszString, nCount,\r\n                                 nTabPositions, lpnTabStopPositions);\r\n}\r\n\r\ninline BOOL MDC::GrayString(\r\n    HBRUSH hBrush, BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, INT),\r\n    LPARAM lpData, INT nCount, INT x, INT y, INT nWidth, INT nHeight)\r\n{\r\n    assert(Handle());\r\n    return ::GrayString(Handle(),\r\n        hBrush, reinterpret_cast<GRAYSTRINGPROC>(lpfnOutput), lpData, nCount,\r\n        x, y, nWidth, nHeight);\r\n}\r\n\r\ninline UINT MDC::GetTextAlign(VOID) const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextAlign(Handle());\r\n}\r\n\r\ninline UINT MDC::SetTextAlign(UINT uTA_flags)\r\n{\r\n    assert(Handle());\r\n    return ::SetTextAlign(Handle(), uTA_flags);\r\n}\r\n\r\ninline INT MDC::GetTextFace(LPTSTR lpszFacename, INT nCount) const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextFace(Handle(), nCount, lpszFacename);\r\n}\r\n\r\ninline INT MDC::GetTextFaceLen() const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextFace(Handle(), 0, NULL);\r\n}\r\n\r\ninline BOOL MDC::GetTextMetrics(LPTEXTMETRIC lpMetrics) const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextMetrics(Handle(), lpMetrics);\r\n}\r\n\r\ninline INT MDC::SetTextJustification(INT nBreakExtra, INT nBreakCount)\r\n{\r\n    assert(Handle());\r\n    return ::SetTextJustification(Handle(), nBreakExtra, nBreakCount);\r\n}\r\n\r\ninline INT MDC::GetTextCharacterExtra() const\r\n{\r\n    assert(Handle());\r\n    return ::GetTextCharacterExtra(Handle());\r\n}\r\n\r\ninline INT MDC::SetTextCharacterExtra(INT nCharExtra)\r\n{\r\n    assert(Handle());\r\n    return ::SetTextCharacterExtra(Handle(), nCharExtra);\r\n}\r\n\r\ninline BOOL MDC::DrawEdge(LPRECT prc, UINT nEdge, UINT nFlags)\r\n{\r\n    assert(Handle());\r\n    return ::DrawEdge(Handle(), prc, nEdge, nFlags);\r\n}\r\n\r\ninline BOOL MDC::DrawFrameControl(LPRECT prc, UINT nType, UINT nState)\r\n{\r\n    assert(Handle());\r\n    return ::DrawFrameControl(Handle(), prc, nType, nState);\r\n}\r\n\r\ninline BOOL MDC::ScrollDC(INT dx, INT dy, LPCRECT lpRectScroll,\r\n    LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate)\r\n{\r\n    assert(Handle());\r\n    return ::ScrollDC(Handle(),\r\n        dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);\r\n}\r\n\r\ninline BOOL MDC::GetCharWidth(\r\n    UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCharWidth(Handle(), nFirstChar, nLastChar, lpBuffer);\r\n}\r\n\r\ninline BOOL MDC::GetCharWidth32(\r\n    UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCharWidth32(Handle(), nFirstChar, nLastChar, lpBuffer);\r\n}\r\n\r\ninline DWORD MDC::SetMapperFlags(DWORD dwFlag)\r\n{\r\n    assert(Handle());\r\n    return ::SetMapperFlags(Handle(), dwFlag);\r\n}\r\n\r\ninline BOOL MDC::GetAspectRatioFilter(LPSIZE lpSize) const\r\n{\r\n    assert(Handle());\r\n    return ::GetAspectRatioFilterEx(Handle(), lpSize);\r\n}\r\n\r\ninline BOOL MDC::GetCharABCWidths(\r\n    UINT nFirstChar, UINT nLastChar, LPABC lpabc) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCharABCWidths(Handle(), nFirstChar, nLastChar, lpabc);\r\n}\r\n\r\ninline DWORD MDC::GetFontData(\r\n    DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const\r\n{\r\n    assert(Handle());\r\n    return ::GetFontData(Handle(), dwTable, dwOffset, lpData, cbData);\r\n}\r\n\r\ninline INT MDC::GetKerningPairs(INT nPairs, LPKERNINGPAIR lpkrnpair) const\r\n{\r\n    assert(Handle());\r\n    return static_cast<INT>(::GetKerningPairs(Handle(), static_cast<DWORD>(nPairs), lpkrnpair));\r\n}\r\n\r\ninline UINT MDC::GetOutlineTextMetrics(\r\n    UINT cbData, LPOUTLINETEXTMETRIC lpotm) const\r\n{\r\n    assert(Handle());\r\n    return ::GetOutlineTextMetrics(Handle(), cbData, lpotm);\r\n}\r\n\r\ninline DWORD MDC::GetGlyphOutline(UINT nChar, UINT nFormat,\r\n    LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpBuffer,\r\n    const MAT2* lpmat2) const\r\n{\r\n    assert(Handle());\r\n    return ::GetGlyphOutline(Handle(), nChar, nFormat, lpgm,\r\n        cbBuffer, lpBuffer, lpmat2);\r\n}\r\n\r\ninline BOOL MDC::GetCharABCWidths(\r\n    UINT nFirstChar, UINT nLastChar, LPABCFLOAT lpABCF) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCharABCWidthsFloat(Handle(), nFirstChar, nLastChar, lpABCF);\r\n}\r\n\r\ninline BOOL MDC::GetCharWidth(\r\n    UINT nFirstChar, UINT nLastChar, PFLOAT lpFloatBuffer) const\r\n{\r\n    assert(Handle());\r\n    return ::GetCharWidthFloat(Handle(), nFirstChar, nLastChar, lpFloatBuffer);\r\n}\r\n\r\ninline INT MDC::Escape(\r\n    INT nEscape, INT nCount, LPCSTR lpszInData, LPVOID lpOutData)\r\n{\r\n    assert(Handle());\r\n    return ::Escape(Handle(), nEscape, nCount, lpszInData, lpOutData);\r\n}\r\n\r\ninline INT MDC::Escape(INT nEscape, INT nInputSize, LPCSTR lpszInputData,\r\n    INT nOutputSize, LPSTR lpszOutputData)\r\n{\r\n    assert(Handle());\r\n    return ::ExtEscape(Handle(),\r\n        nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);\r\n}\r\n\r\ninline INT MDC::DrawEscape(\r\n    INT nEscape, INT nInputSize, LPCSTR lpszInputData)\r\n{\r\n    assert(Handle());\r\n    return ::DrawEscape(Handle(), nEscape, nInputSize, lpszInputData);\r\n}\r\n\r\ninline INT MDC::StartDoc(LPCTSTR lpszDocName)\r\n{\r\n    DOCINFO di;\r\n    using namespace std;\r\n    ZeroMemory(&di, sizeof(DOCINFO));\r\n    di.cbSize = sizeof(DOCINFO);\r\n    di.lpszDocName = lpszDocName;\r\n    return StartDoc(&di);\r\n}\r\n\r\ninline INT MDC::StartDoc(LPDOCINFO lpDocInfo)\r\n{\r\n    assert(Handle());\r\n    return ::StartDoc(Handle(), lpDocInfo);\r\n}\r\n\r\ninline INT MDC::StartPage(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::StartPage(Handle());\r\n}\r\n\r\ninline INT MDC::EndPage(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::EndPage(Handle());\r\n}\r\n\r\ninline INT MDC::SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, INT))\r\n{\r\n    assert(Handle());\r\n    return ::SetAbortProc(Handle(), (ABORTPROC) lpfn);\r\n}\r\n\r\ninline INT MDC::AbortDoc(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::AbortDoc(Handle());\r\n}\r\n\r\ninline INT MDC::EndDoc(VOID)\r\n{\r\n    assert(Handle());\r\n    return ::EndDoc(Handle());\r\n}\r\n\r\ninline BOOL MDC::PlayEnhMetaFile(\r\n    HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)\r\n{\r\n    assert(Handle());\r\n    return ::PlayEnhMetaFile(Handle(), hEnhMetaFile, lpBounds);\r\n}\r\n\r\ninline BOOL MDC::GdiComment(UINT nDataSize, CONST BYTE* pCommentData)\r\n{\r\n    assert(Handle());\r\n    return ::GdiComment(Handle(), nDataSize, pCommentData);\r\n}\r\n\r\ninline BOOL MDC::AbortPath()\r\n{\r\n    assert(Handle());\r\n    return ::AbortPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::BeginPath()\r\n{\r\n    assert(Handle());\r\n    return ::BeginPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::CloseFigure()\r\n{\r\n    assert(Handle());\r\n    return ::CloseFigure(Handle());\r\n}\r\n\r\ninline BOOL MDC::EndPath()\r\n{\r\n    assert(Handle());\r\n    return ::EndPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::FillPath()\r\n{\r\n    assert(Handle());\r\n    return ::FillPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::FlattenPath()\r\n{\r\n    assert(Handle());\r\n    return ::FlattenPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::StrokeAndFillPath()\r\n{\r\n    assert(Handle());\r\n    return ::StrokeAndFillPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::StrokePath()\r\n{\r\n    assert(Handle());\r\n    return ::StrokePath(Handle());\r\n}\r\n\r\ninline BOOL MDC::WidenPath()\r\n{\r\n    assert(Handle());\r\n    return ::WidenPath(Handle());\r\n}\r\n\r\ninline BOOL MDC::GetMiterLimit(PFLOAT pfMiterLimit) const\r\n{\r\n    assert(Handle());\r\n    return ::GetMiterLimit(Handle(), pfMiterLimit);\r\n}\r\n\r\ninline BOOL MDC::SetMiterLimit(FLOAT fMiterLimit, PFLOAT peOldLimit/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetMiterLimit(Handle(), fMiterLimit, peOldLimit);\r\n}\r\n\r\ninline INT MDC::GetPath(LPPOINT lpPoints, LPBYTE lpTypes, INT nCount) const\r\n{\r\n    assert(Handle());\r\n    return ::GetPath(Handle(), lpPoints, lpTypes, nCount);\r\n}\r\n\r\ninline BOOL MDC::SelectClipPath(INT nRGN_)\r\n{\r\n    assert(Handle());\r\n    return ::SelectClipPath(Handle(), nRGN_);\r\n}\r\n\r\ninline INT MDC::SetDIBitsToDevice(INT x, INT y,\r\n    DWORD dwWidth, DWORD dwHeight, INT xSrc, INT ySrc,\r\n    UINT uStartScan, UINT cScanLines, LPCVOID lpvBits,\r\n    CONST BITMAPINFO* lpbmi, UINT uColorUse)\r\n{\r\n    assert(Handle());\r\n    return ::SetDIBitsToDevice(Handle(), x, y, dwWidth, dwHeight,\r\n        xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);\r\n}\r\n\r\ninline INT MDC::StretchDIBits(INT x, INT y, INT nWidth, INT nHeight,\r\n    INT xSrc, INT ySrc, INT nSrcWidth, INT nSrcHeight, LPCVOID lpvBits,\r\n    CONST BITMAPINFO* lpbmi, UINT uColorUse, DWORD dwRop)\r\n{\r\n    assert(Handle());\r\n    return ::StretchDIBits(Handle(), x, y, nWidth, nHeight, xSrc, ySrc,\r\n        nSrcWidth, nSrcHeight, lpvBits, lpbmi, uColorUse, dwRop);\r\n}\r\n\r\ninline UINT MDC::GetDIBColorTable(\r\n    UINT uStartIndex, UINT cEntries, RGBQUAD* pColors) const\r\n{\r\n    assert(Handle());\r\n    return ::GetDIBColorTable(Handle(), uStartIndex, cEntries, pColors);\r\n}\r\n\r\ninline UINT MDC::SetDIBColorTable(\r\n    UINT uStartIndex, UINT cEntries, CONST RGBQUAD* pColors)\r\n{\r\n    assert(Handle());\r\n    return ::SetDIBColorTable(Handle(), uStartIndex, cEntries, pColors);\r\n}\r\n\r\n#if (_WIN32_WINNT >= 0x0500)\r\n    inline DWORD MDC::GetFontUnicodeRanges(LPGLYPHSET lpgs) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetFontUnicodeRanges(Handle(), lpgs);\r\n    }\r\n\r\n    inline DWORD MDC::GetGlyphIndices(\r\n        LPCTSTR lpstr, INT cch, LPWORD pgi, DWORD dwFlags) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetGlyphIndices(Handle(), lpstr, cch, pgi, dwFlags);\r\n    }\r\n\r\n    inline BOOL MDC::GetTextExtentPointI(\r\n        LPWORD pgiIn, INT cgi, LPSIZE lpSize) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetTextExtentPointI(Handle(), pgiIn, cgi, lpSize);\r\n    }\r\n\r\n    inline BOOL MDC::GetTextExtentExPointI(LPWORD pgiIn, INT cgi,\r\n        INT nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetTextExtentExPointI(Handle(),\r\n            pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);\r\n    }\r\n\r\n    inline BOOL MDC::GetCharWidthI(UINT giFirst, UINT cgi,\r\n        LPWORD pgi, LPINT lpBuffer) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetCharWidthI(Handle(), giFirst, cgi, pgi, lpBuffer);\r\n    }\r\n\r\n    inline BOOL MDC::GetCharABCWidthsI(\r\n        UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const\r\n    {\r\n        assert(Handle());\r\n        return ::GetCharABCWidthsI(Handle(), giFirst, cgi, pgi, lpabc);\r\n    }\r\n#endif  // (_WIN32_WINNT >= 0x0500)\r\n\r\ninline BOOL MDC::SetWindowExt(INT x, INT y, LPSIZE lpSize/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetWindowExtEx(Handle(), x, y, lpSize);\r\n}\r\n\r\ninline BOOL MDC::SetWindowOrg(INT x, INT y, LPPOINT lpPoint/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetWindowOrgEx(Handle(), x, y, lpPoint);\r\n}\r\n\r\ninline BOOL MDC::SetViewportExt(INT cx, INT cy, LPSIZE lpSize/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetViewportExtEx(Handle(), cx, cy, lpSize);\r\n}\r\n\r\ninline BOOL MDC::SetViewportOrg(INT x, INT y, LPPOINT lpPoint/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetViewportOrgEx(Handle(), x, y, lpPoint);\r\n}\r\n\r\ninline BOOL MDC::OffsetViewportOrg(\r\n    INT nWidth, INT nHeight, LPPOINT lpPoint/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetViewportOrgEx(Handle(), nWidth, nHeight, lpPoint);\r\n}\r\n\r\ninline BOOL MDC::PatBlt(LPCRECT prc, DWORD dwRop/* = PATCOPY*/)\r\n{\r\n    assert(Handle());\r\n    MRect rc(prc);\r\n    return PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), dwRop);\r\n}\r\n\r\ninline VOID GetDpiDx(FLOAT *xdpi, FLOAT *ydpi)\r\n{\r\n    static FLOAT s_xdpi = 0.0f, s_ydpi = 0.0f;\r\n    if (s_xdpi == 0.0)\r\n    {\r\n        HWND hwnd = ::GetDesktopWindow();\r\n        HDC hdc = ::GetDC(hwnd);\r\n        s_xdpi = ::GetDeviceCaps(hdc, LOGPIXELSX);\r\n        s_ydpi = ::GetDeviceCaps(hdc, LOGPIXELSY);\r\n        ::ReleaseDC(hwnd, hdc);\r\n    }\r\n    if (xdpi)\r\n        *xdpi = s_xdpi;\r\n    if (ydpi)\r\n        *ydpi = s_ydpi;\r\n}\r\n\r\ninline VOID MDC::Draw3dRect(INT x, INT y, INT cx, INT cy,\r\n    COLORREF clrTopLeft, COLORREF clrBottomRight)\r\n{\r\n    FillSolidRect(x, y, cx - 1, 1, clrTopLeft);\r\n    FillSolidRect(x, y, 1, cy - 1, clrTopLeft);\r\n    FillSolidRect(x + cx, y, -1, cy, clrBottomRight);\r\n    FillSolidRect(x, y + cy, cx, -1, clrBottomRight);\r\n}\r\n\r\ninline MSize MDC::GetTextExtent(LPCTSTR lpszString) const\r\n{\r\n    return MDC::GetTextExtent(lpszString, lstrlen(lpszString));\r\n}\r\n\r\ninline BOOL MDC::DitherBlt(INT x, INT y, INT nWidth, INT nHeight,\r\n    HDC hSrcDC, HBITMAP hBitmap, INT xSrc, INT ySrc,\r\n    HBRUSH hBrushBackground/* = ::GetSysColorBrush(COLOR_3DFACE)*/,\r\n    HBRUSH hBrush3DEffect/* = ::GetSysColorBrush(COLOR_3DHILIGHT)*/,\r\n    HBRUSH hBrushDisabledImage/* = ::GetSysColorBrush(COLOR_3DSHADOW)*/)\r\n{\r\n    assert(Handle() || hBitmap);\r\n    assert(nWidth > 0 && nHeight > 0);\r\n\r\n    // Create a generic DC for all BitBlts\r\n    MDC dc((hSrcDC) ? hSrcDC : ::CreateCompatibleDC(Handle()));\r\n    assert(!!dc);\r\n    if (!dc)\r\n        return FALSE;\r\n\r\n    // Create a DC for the monochrome DIB section\r\n    MMemoryDC dcBW(Handle());\r\n    assert(!!dcBW);\r\n    if (!dcBW)\r\n    {\r\n        if(hSrcDC)\r\n            dc.Detach();\r\n        return FALSE;\r\n    }\r\n\r\n    // Create the monochrome DIB section with a black and white palette\r\n    struct RGBBWBITMAPINFO\r\n    {\r\n        BITMAPINFOHEADER bmiHeader;\r\n        RGBQUAD bmiColors[2];\r\n    };\r\n\r\n    RGBBWBITMAPINFO rgbBWBitmapInfo =\r\n    {\r\n        { sizeof(BITMAPINFOHEADER), nWidth, nHeight, 1, 1,\r\n          BI_RGB, 0, 0, 0, 0, 0 },\r\n        { { 0x00, 0x00, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF, 0x00 } }\r\n    };\r\n\r\n    VOID* pbitsBW;\r\n    MBitmap bmpBW;\r\n    bmpBW.CreateDIBSection(reinterpret_cast<LPBITMAPINFO>(&rgbBWBitmapInfo),\r\n                           &pbitsBW);\r\n    assert(!!bmpBW);\r\n    if (!bmpBW)\r\n    {\r\n        if(hSrcDC)\r\n            dc.Detach();\r\n        return FALSE;\r\n    }\r\n\r\n    // Attach the monochrome DIB section and the bitmap to the DCs\r\n    HBITMAP hbmOldBW = dcBW.SelectObject(bmpBW);\r\n    HBITMAP hbmOldDC = NULL;\r\n    if (hBitmap)\r\n        hbmOldDC = dc.SelectObject(hBitmap);\r\n\r\n    {\r\n        MMemoryDC dcTemp1(Handle());\r\n        MMemoryDC dcTemp2(Handle());\r\n        MBitmap bmpTemp1;\r\n        bmpTemp1.CreateCompatibleBitmap(dc, nWidth, nHeight);\r\n        MBitmap bmpTemp2;\r\n        bmpTemp2.CreateBitmap(nWidth, nHeight, 1);\r\n        HBITMAP hOldBmp1 = dcTemp1.SelectObject(bmpTemp1);\r\n        HBITMAP hOldBmp2 = dcTemp2.SelectObject(bmpTemp2);\r\n        dcTemp1.BitBlt(0, 0, nWidth, nHeight, dc, xSrc, ySrc, SRCCOPY);\r\n        dcTemp1.SetBkColor(RGB(128, 128, 128));\r\n        dcTemp2.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);\r\n        dcTemp1.BitBlt(0, 0, nWidth, nHeight, dcTemp2, 0, 0, SRCINVERT);\r\n        dcBW.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);\r\n        dcTemp1.SelectObject(hOldBmp1);\r\n        dcTemp2.SelectObject(hOldBmp2);\r\n    }\r\n\r\n    if (hBrushBackground)\r\n        FillRect(MRect(x, y, x + nWidth, y + nHeight), hBrushBackground);\r\n\r\n    HBRUSH hOldBrush = SelectObject(hBrush3DEffect);\r\n    BitBlt(x + 1, y + 1, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);\r\n    SelectObject(hBrushDisabledImage);\r\n    BitBlt(x, y, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);\r\n    SelectObject(hOldBrush);\r\n\r\n    dcBW.SelectObject(hbmOldBW);\r\n    dc.SelectObject(hbmOldDC);\r\n\r\n    if (hSrcDC)\r\n        dc.Detach();\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline VOID MDC::GradientFill(COLORREF Color1, COLORREF Color2, LPRECT prc,\r\n    BOOL bVertical)\r\n{\r\n    INT cx = prc->right - prc->left;\r\n    INT cy = prc->bottom - prc->top;\r\n    INT r1 = GetRValue(Color1);\r\n    INT g1 = GetGValue(Color1);\r\n    INT b1 = GetBValue(Color1);\r\n    INT r2 = GetRValue(Color2);\r\n    INT g2 = GetGValue(Color2);\r\n    INT b2 = GetBValue(Color2);\r\n\r\n    COLORREF OldBkColor = GetBkColor();\r\n\r\n    INT r = r1;\r\n    INT g = g1;\r\n    INT b = b1;\r\n    if (bVertical)\r\n    {\r\n        INT dr = (r2 - r1) / cx;\r\n        INT dg = (g2 - g1) / cx;\r\n        INT db = (b2 - b1) / cx;\r\n        for(INT i = 0; i < cx; i++)\r\n        {\r\n            SetBkColor(RGB(r, g, b));\r\n            MRect line(i + prc->left, prc->top,\r\n                       prc->left + i + 1, prc->top + cy);\r\n            ExtTextOut(0, 0, ETO_OPAQUE, &line, NULL, 0);\r\n            r += dr;\r\n            g += dg;\r\n            b += db;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        INT dr = (r2 - r1) / cy;\r\n        INT dg = (g2 - g1) / cy;\r\n        INT db = (b2 - b1) / cy;\r\n        for(INT i = 0; i < cy; i++)\r\n        {\r\n            SetBkColor(RGB(r, g, b));\r\n            MRect line(prc->left, i + prc->top,\r\n                       prc->left + cx, prc->top + i + 1);\r\n            ExtTextOut(0, 0, ETO_OPAQUE, &line, NULL, 0);\r\n            r += dr;\r\n            g += dg;\r\n            b += db;\r\n        }\r\n    }\r\n\r\n    SetBkColor(OldBkColor);\r\n}\r\n\r\ninline VOID MDC::FillSolidRect(INT x, INT y, INT cx, INT cy, COLORREF crColor)\r\n{\r\n    FillSolidRect(MRect(x, y, x + cx, y + cy), crColor);\r\n}\r\n\r\ninline VOID MDC::FillSolidRect(LPCRECT prc, COLORREF crColor)\r\n{\r\n    assert(Handle());\r\n    COLORREF OldColor = ::SetBkColor(Handle(), crColor);\r\n    if (OldColor != CLR_INVALID)\r\n    {\r\n        ::ExtTextOut(Handle(), 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);\r\n        ::SetBkColor(Handle(), OldColor);\r\n    }\r\n}\r\n\r\ninline INT CALLBACK EnumMetaFileProcDx(HDC hDC, HANDLETABLE* pHandleTable,\r\n    METARECORD* pMetaRec, INT nHandles, LPARAM lParam)\r\n{\r\n    MDC* pDC = (MDC *) lParam;\r\n\r\n    switch (pMetaRec->rdFunction)\r\n    {\r\n    case META_SETMAPMODE:\r\n        pDC->SetMapMode(static_cast<INT>(static_cast<SHORT>(pMetaRec->rdParm[0])));\r\n        break;\r\n\r\n    case META_SETWINDOWEXT:\r\n        pDC->SetWindowExt(\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SETWINDOWORG:\r\n        pDC->SetWindowOrg(\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SETVIEWPORTEXT:\r\n        pDC->SetViewportExt(\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SETVIEWPORTORG:\r\n        pDC->SetViewportOrg(\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SCALEWINDOWEXT:\r\n        pDC->ScaleWindowExt(\r\n            static_cast<SHORT>(pMetaRec->rdParm[3]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[2]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SCALEVIEWPORTEXT:\r\n        pDC->ScaleViewportExt(\r\n            static_cast<SHORT>(pMetaRec->rdParm[3]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[2]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_OFFSETVIEWPORTORG:\r\n        pDC->OffsetViewportOrg(\r\n            static_cast<SHORT>(pMetaRec->rdParm[1]),\r\n            static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SAVEDC:\r\n        pDC->SaveDC();\r\n        break;\r\n\r\n    case META_RESTOREDC:\r\n        pDC->RestoreDC(static_cast<SHORT>(pMetaRec->rdParm[0]));\r\n        break;\r\n\r\n    case META_SETBKCOLOR:\r\n        {\r\n            WORD wLow = pMetaRec->rdParm[0], wHigh = pMetaRec->rdParm[1];\r\n            pDC->SetBkColor(MAKELONG(wLow, wHigh));\r\n        }\r\n        break;\r\n\r\n    case META_SETTEXTCOLOR:\r\n        {\r\n            WORD wLow = pMetaRec->rdParm[0], wHigh = pMetaRec->rdParm[1];\r\n            pDC->SetTextColor(MAKELONG(wLow, wHigh));\r\n        }\r\n        break;\r\n\r\n    // need to watch out for SelectObject(HFONT), for custom font mapping\r\n    case META_SELECTOBJECT:\r\n        {\r\n            HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];\r\n            UINT nObjType = ::GetObjectType(hObject);\r\n            if (nObjType == 0)\r\n            {\r\n                HFONT hStockFont = reinterpret_cast<HFONT>(::GetStockObject(SYSTEM_FONT));\r\n                HFONT hFontOld = reinterpret_cast<HFONT>(::SelectObject(*pDC, hStockFont));\r\n                HGDIOBJ hObjOld = ::SelectObject(*pDC, hObject);\r\n                if(hObjOld == hStockFont)\r\n                {\r\n                    pDC->SelectObject(reinterpret_cast<HFONT>(hObject));\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    pDC->SelectObject(hFontOld);\r\n                    ::SelectObject(*pDC, hObjOld);\r\n                }\r\n            }\r\n            else if(nObjType == OBJ_FONT)\r\n            {\r\n                pDC->SelectObject(reinterpret_cast<HFONT>(hObject));\r\n                break;\r\n            }\r\n        }\r\n\r\n    default:\r\n        ::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);\r\n        break;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\ninline BOOL MDC::PlayMetaFile(HMETAFILE hMF)\r\n{\r\n    assert(Handle());\r\n    if (::GetDeviceCaps(Handle(), TECHNOLOGY) == DT_METAFILE)\r\n        return ::PlayMetaFile(Handle(), hMF);\r\n    // for special playback, lParam == pDC\r\n    LPARAM lParam = reinterpret_cast<LPARAM>(this);\r\n    return ::EnumMetaFile(Handle(), hMF, EnumMetaFileProcDx, lParam);\r\n}\r\n\r\ninline BOOL MDC::ExtTextOut(INT x, INT y, UINT nOptions, LPCRECT prc,\r\n    LPCTSTR lpsz, UINT cch/* = (UINT)-1*/, LPINT lpDxWidths/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    if (cch == static_cast<UINT>(-1))\r\n        cch = ::lstrlen(lpsz);\r\n    return ::ExtTextOut(Handle(), x, y, nOptions, prc, lpsz, cch, lpDxWidths);\r\n}\r\n\r\ninline VOID MDC::Draw3dRect(\r\n    LPCRECT prc, COLORREF clrTopLeft, COLORREF clrBottomRight)\r\n{\r\n    Draw3dRect(prc->left, prc->top, prc->right - prc->left,\r\n        prc->bottom - prc->top, clrTopLeft, clrBottomRight);\r\n}\r\n\r\ninline BOOL MDC::BitBlt(LPCRECT prc, HDC hSrcDC, POINT ptSrc, DWORD dwRop/* = SRCCOPY*/)\r\n{\r\n    assert(Handle());\r\n    MRect rc(prc);\r\n    return BitBlt(rc.left, rc.top, rc.Width(), rc.Height(),\r\n        hSrcDC, ptSrc.x, ptSrc.y, dwRop);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MMemoryDC::MMemoryDC()\r\n{\r\n}\r\n\r\ninline MMemoryDC::MMemoryDC(HDC hBaseDC) : MDC(::CreateCompatibleDC(hBaseDC))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline BOOL MMemoryDC::CreateCompatibleDC(HDC hBaseDC/* = NULL*/)\r\n{\r\n    return Attach(::CreateCompatibleDC(hBaseDC));\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MClientDC::MClientDC() : MDC(), m_hWnd(NULL)\r\n{\r\n}\r\n\r\ninline MClientDC::MClientDC(HWND hWnd) : MDC(::GetDC(hWnd)), m_hWnd(hWnd)\r\n{\r\n    assert(hWnd == NULL || ::IsWindow(hWnd));\r\n    assert(Handle());\r\n}\r\n\r\ninline /*virtual*/ MClientDC::~MClientDC()\r\n{\r\n    ReleaseDC();\r\n}\r\n\r\ninline BOOL MClientDC::GetDC(HWND hWnd)\r\n{\r\n    return Attach(::GetDC(hWnd));\r\n}\r\n\r\ninline INT MClientDC::ReleaseDC()\r\n{\r\n    if (Handle())\r\n    {\r\n        INT nResult = ::ReleaseDC(m_hWnd, Detach());\r\n        m_hWnd = NULL;\r\n        return nResult;\r\n    }\r\n    return 0;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MPaintDC::MPaintDC() : MDC()\r\n{\r\n}\r\n\r\ninline MPaintDC::MPaintDC(HWND hWnd) : MDC()\r\n{\r\n    BeginPaint(hWnd);\r\n}\r\n\r\ninline /*virtual*/ MPaintDC::~MPaintDC()\r\n{\r\n    EndPaint();\r\n}\r\n\r\ninline BOOL MPaintDC::BeginPaint(HWND hWnd)\r\n{\r\n    assert(::IsWindow(hWnd));\r\n    assert(Handle() == NULL);\r\n    if (Attach(::BeginPaint(hWnd, &m_ps)))\r\n    {\r\n        m_hWnd = hWnd;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MPaintDC::EndPaint()\r\n{\r\n    assert(Handle());\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::EndPaint(m_hWnd, &m_ps);\r\n        if (bOK)\r\n        {\r\n            m_hWnd = NULL;\r\n            Detach();\r\n        }\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MWindowDC::MWindowDC(HWND hWnd)\r\n    : MDC(::GetWindowDC(hWnd)), m_hWnd(hWnd)\r\n{\r\n    assert(Handle());\r\n    assert(hWnd == NULL || ::IsWindow(hWnd));\r\n}\r\n\r\ninline /*virtual*/ MWindowDC::~MWindowDC()\r\n{\r\n    ReleaseDC();\r\n}\r\n\r\ninline BOOL MWindowDC::GetWindowDC(HWND hWnd)\r\n{\r\n    if (Attach(::GetWindowDC(hWnd)))\r\n    {\r\n        m_hWnd = hWnd;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline INT MWindowDC::ReleaseDC()\r\n{\r\n    if (Handle())\r\n    {\r\n        INT nOK = ::ReleaseDC(m_hWnd, Detach());\r\n        m_hWnd = NULL;\r\n        return nOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MMetaDC::MMetaDC()\r\n{\r\n}\r\n\r\ninline MMetaDC::MMetaDC(HDC hDC) : MDC(hDC)\r\n{\r\n}\r\n\r\ninline MMetaDC::MMetaDC(LPCTSTR pszFile) : MDC(::CreateMetaFile(pszFile))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline BOOL MMetaDC::DeleteMetaFile()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DeleteMetaFile(::CloseMetaFile(Detach()));\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline /*virtual*/ MMetaDC::~MMetaDC()\r\n{\r\n    DeleteMetaFile();\r\n}\r\n\r\ninline MMetaDC& MMetaDC::operator=(HDC hDC)\r\n{\r\n    assert(hDC);\r\n    assert(::GetObjectType(hDC) == OBJ_METADC);\r\n    if (Handle() != hDC)\r\n    {\r\n        Attach(hDC);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MMetaDC::CreateMetaFile(LPCTSTR pszFile/* = NULL*/)\r\n{\r\n    return Attach(::CreateMetaFile(pszFile));\r\n}\r\n\r\ninline HMETAFILE MMetaDC::CloseMetaFile()\r\n{\r\n    HMETAFILE hWMF = ::CloseMetaFile(Detach());\r\n    return hWMF;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MEnhMetaDC::MEnhMetaDC() : MDC()\r\n{\r\n}\r\n\r\ninline MEnhMetaDC::MEnhMetaDC(HDC hDC) : MDC(hDC)\r\n{\r\n}\r\n\r\ninline MEnhMetaDC::MEnhMetaDC(HDC hdcRef, LPCRECT prc,\r\n    LPCTSTR pszFileName/* = NULL*/, LPCTSTR pszDescription/* = NULL*/)\r\n    : MDC(::CreateEnhMetaFile(hdcRef, pszFileName, prc, pszDescription))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline /*virtual*/ MEnhMetaDC::~MEnhMetaDC()\r\n{\r\n    DeleteEnhMetaFile();\r\n}\r\n\r\ninline BOOL MEnhMetaDC::CreateEnhMetaFile(HDC hdcRef, LPCRECT prc,\r\n    LPCTSTR pszFileName/* = NULL*/, LPCTSTR pszDescription/* = NULL*/)\r\n{\r\n    return Attach(::CreateEnhMetaFile(hdcRef, pszFileName, prc, pszDescription));\r\n}\r\n\r\ninline HENHMETAFILE MEnhMetaDC::CloseEnhMetaFile()\r\n{\r\n    assert(Handle());\r\n    assert(::GetObjectType(Handle()) == OBJ_ENHMETAFILE);\r\n    HENHMETAFILE hEMF = ::CloseEnhMetaFile(Detach());\r\n    return hEMF;\r\n}\r\n\r\ninline MEnhMetaDC& MEnhMetaDC::operator=(HDC hDC)\r\n{\r\n    assert(::GetObjectType(hDC) == OBJ_ENHMETADC);\r\n    if (Handle() != hDC)\r\n    {\r\n        Attach(hDC);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MEnhMetaDC::DeleteEnhMetaFile()\r\n{\r\n    return ::DeleteEnhMetaFile(CloseEnhMetaFile());\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MDC_HPP_\r\n
MDateTimePick.hpp<>MDateTimePick.hpp<>// MDateTimePick.hpp -- Win32API date time picker wrapper       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MDATETIMEPICK_HPP_\r\n#define MZC4_MDATETIMEPICK_HPP_     2   /* Version 2 */\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MDateTimePick;\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MDateTimePick : public MWindowBase\r\n    {\r\n    public:\r\n        MDateTimePick();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        BOOL SetFormat(LPCTSTR lpszFormat);\r\n\r\n        COLORREF GetMonthCalColor(INT nColorType) const;\r\n        COLORREF SetMonthCalColor(INT nColorType, COLORREF clr);\r\n\r\n        DWORD GetRange(LPSYSTEMTIME lpSysTimeArray) const;\r\n        BOOL  SetRange(DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray);\r\n\r\n        DWORD GetSystemTime(LPSYSTEMTIME lpSysTime) const;\r\n        BOOL  SetSystemTime(DWORD dwFlags, LPSYSTEMTIME lpSysTime);\r\n\r\n        HWND GetMonthCal() const;\r\n\r\n        #if (_WIN32_IE >= 0x0400)\r\n            HFONT GetMonthCalFont() const;\r\n            VOID  SetMonthCalFont(HFONT hFont, BOOL bRedraw = TRUE);\r\n        #endif // (_WIN32_IE >= 0x0400)\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline MDateTimePick::MDateTimePick()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MDateTimePick::GetWndClassNameDx() const\r\n    {\r\n        return DATETIMEPICK_CLASS;\r\n    }\r\n\r\n    inline BOOL MDateTimePick::SetFormat(LPCTSTR lpszFormat)\r\n    {\r\n        return (BOOL)SendMessageDx(DTM_SETFORMAT, 0, (LPARAM)lpszFormat);\r\n    }\r\n\r\n    inline COLORREF MDateTimePick::GetMonthCalColor(\r\n        INT nColorType) const\r\n    {\r\n        return (COLORREF)SendMessageDx(DTM_GETMCCOLOR, (WPARAM)nColorType);\r\n    }\r\n\r\n    inline COLORREF MDateTimePick::SetMonthCalColor(\r\n        INT nColorType, COLORREF clr)\r\n    {\r\n        return (COLORREF)SendMessageDx(DTM_SETMCCOLOR, (WPARAM)nColorType, (LPARAM)clr);\r\n    }\r\n\r\n    inline DWORD MDateTimePick::GetRange(\r\n        LPSYSTEMTIME lpSysTimeArray) const\r\n    {\r\n        return (DWORD)SendMessageDx(DTM_GETRANGE, 0, (LPARAM)lpSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MDateTimePick::SetRange(\r\n        DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray)\r\n    {\r\n        return (BOOL)SendMessageDx(DTM_SETRANGE, dwFlags, (LPARAM)lpSysTimeArray);\r\n    }\r\n\r\n    inline DWORD MDateTimePick::GetSystemTime(\r\n        LPSYSTEMTIME lpSysTime) const\r\n    {\r\n        return (DWORD)SendMessageDx(DTM_GETSYSTEMTIME, 0, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline BOOL MDateTimePick::SetSystemTime(\r\n        DWORD dwFlags, LPSYSTEMTIME lpSysTime)\r\n    {\r\n        return (BOOL)SendMessageDx(DTM_SETSYSTEMTIME, dwFlags, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline HWND MDateTimePick::GetMonthCal() const\r\n    {\r\n        return (HWND)SendMessageDx(DTM_GETMONTHCAL);\r\n    }\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        inline HFONT MDateTimePick::GetMonthCalFont() const\r\n        {\r\n            return (HFONT)SendMessageDx(DTM_GETMCFONT);\r\n        }\r\n\r\n        inline VOID\r\n        MDateTimePick::SetMonthCalFont(HFONT hFont, BOOL bRedraw/* = TRUE*/)\r\n        {\r\n            SendMessageDx(DTM_SETMCFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));\r\n        }\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MDATETIMEPICK_HPP_\r\n
MDialogClass<>MDialogClass<>class MDialogClass : public MDialogBase\r\n{\r\npublic:\r\n    MDialogClass()\r\n    {\r\n    }\r\n\r\n    virtual ~MDialogClass()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n};\r\n
MDirWatch.hpp<>MDirWatch.hpp<>// MDirWatch.hpp -- Win32API directory watcher                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MDIRWATCH_HPP_\r\n#define MZC4_MDIRWATCH_HPP_     3   /* Version 3 */\r\n\r\nclass MDirWatch;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MDirWatch\r\n{\r\npublic:\r\n    enum\r\n    {\r\n        check_file_name = FILE_NOTIFY_CHANGE_FILE_NAME,\r\n        check_dir_name = FILE_NOTIFY_CHANGE_DIR_NAME,\r\n        check_attributes = FILE_NOTIFY_CHANGE_ATTRIBUTES,\r\n        check_size = FILE_NOTIFY_CHANGE_SIZE,\r\n        check_last_write = FILE_NOTIFY_CHANGE_LAST_WRITE,\r\n        check_last_access = FILE_NOTIFY_CHANGE_LAST_ACCESS,\r\n        check_creation = FILE_NOTIFY_CHANGE_CREATION,\r\n        check_security =  FILE_NOTIFY_CHANGE_SECURITY,\r\n        check_all = 0x17F\r\n    }; // for dwNotifyChangeFlags\r\n\r\npublic:\r\n    MDirWatch();\r\n    MDirWatch(HANDLE hFindChange);\r\n    MDirWatch(LPCTSTR pszPath, BOOL bWatchSubTree = TRUE,\r\n              DWORD dwNotifyChangeFlags = MDirWatch::check_all);\r\n    virtual ~MDirWatch();\r\n\r\n    bool operator!() const;\r\n    operator HANDLE() const;\r\n    MDirWatch& operator=(HANDLE hFindChange);\r\n    PHANDLE operator&();\r\n\r\n    BOOL Attach(HANDLE hFindChange);\r\n    HANDLE Detach();\r\n    HANDLE Handle() const;\r\n\r\n    BOOL FindFirstChangeNotification(\r\n        LPCTSTR pszPath, BOOL bWatchSubTree = TRUE,\r\n        DWORD dwNotifyChangeFlags = MDirWatch::check_all);\r\n    BOOL FindNextChangeNotification();  \r\n    BOOL FindCloseChangeNotification();\r\n\r\n    DWORD WaitForSingleObject(DWORD dwMilliseconds = INFINITE);\r\n    DWORD WaitForSingleObjectEx(DWORD dwMilliseconds = INFINITE,\r\n                                BOOL bAlertable = TRUE);\r\n\r\npublic:\r\n    HANDLE m_hFindChange;\r\n\r\nprivate:\r\n    // NOTE: MDirWatch is not copyable.\r\n    MDirWatch(const MDirWatch& dw);\r\n    MDirWatch& operator=(const MDirWatch& dw);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MDirWatch::MDirWatch() : m_hFindChange(INVALID_HANDLE_VALUE)\r\n{\r\n}\r\n\r\ninline MDirWatch::MDirWatch(HANDLE hFindChange) :\r\n    m_hFindChange(hFindChange)\r\n{\r\n}\r\n\r\ninline MDirWatch::MDirWatch(\r\n    LPCTSTR pszPath, BOOL bWatchSubTree/* = TRUE*/,\r\n    DWORD dwNotifyChangeFlags/* = MDirWatch::check_all*/\r\n) : m_hFindChange(INVALID_HANDLE_VALUE)\r\n{\r\n    FindFirstChangeNotification(pszPath, bWatchSubTree, dwNotifyChangeFlags);\r\n}\r\n\r\ninline /*virtual*/ MDirWatch::~MDirWatch()\r\n{\r\n    FindCloseChangeNotification();\r\n}\r\n\r\ninline bool MDirWatch::operator!() const\r\n{\r\n    return Handle() == INVALID_HANDLE_VALUE;\r\n}\r\n\r\ninline MDirWatch& MDirWatch::operator=(HANDLE hFindChange)\r\n{\r\n    if (Handle() != hFindChange)\r\n    {\r\n        Attach(hFindChange);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MDirWatch::Attach(HANDLE hFindChange)\r\n{\r\n    FindCloseChangeNotification();\r\n    m_hFindChange = hFindChange;\r\n    return m_hFindChange != NULL;\r\n}\r\n\r\ninline HANDLE MDirWatch::Detach()\r\n{\r\n    HANDLE hFindChange = m_hFindChange;\r\n    m_hFindChange = INVALID_HANDLE_VALUE;\r\n    return hFindChange;\r\n}\r\n\r\ninline HANDLE MDirWatch::Handle() const\r\n{\r\n    return (this ? m_hFindChange : NULL);\r\n}\r\n\r\ninline MDirWatch::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline PHANDLE MDirWatch::operator&()\r\n{\r\n    return &m_hFindChange;\r\n}\r\n\r\ninline BOOL MDirWatch::FindNextChangeNotification() \r\n{\r\n    assert(Handle() != INVALID_HANDLE_VALUE);\r\n    BOOL bFound = ::FindNextChangeNotification(Handle());\r\n    return bFound;\r\n}\r\n\r\ninline BOOL MDirWatch::FindCloseChangeNotification()\r\n{\r\n    if (Handle() != INVALID_HANDLE_VALUE)\r\n    {\r\n        BOOL bOK = ::FindCloseChangeNotification(m_hFindChange);\r\n        m_hFindChange = INVALID_HANDLE_VALUE;\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline DWORD\r\nMDirWatch::WaitForSingleObject(DWORD dwMilliseconds/* = INFINITE*/)\r\n{\r\n    assert(Handle());\r\n    return ::WaitForSingleObject(Handle(), dwMilliseconds);\r\n}\r\n\r\ninline DWORD MDirWatch::WaitForSingleObjectEx(\r\n    DWORD dwMilliseconds/* = INFINITE*/, BOOL bAlertable/* = TRUE*/)\r\n{\r\n    return ::WaitForSingleObjectEx(Handle(), dwMilliseconds, bAlertable);\r\n}\r\n\r\ninline BOOL MDirWatch::FindFirstChangeNotification(\r\n    LPCTSTR pszPath, BOOL bWatchSubTree/* = TRUE*/,\r\n    DWORD dwNotifyChangeFlags/* = MDirWatch::check_all*/)\r\n{\r\n    assert(pszPath);\r\n    return Attach(::FindFirstChangeNotification(pszPath, bWatchSubTree,\r\n                                                dwNotifyChangeFlags));\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MDIRWATCH_HPP_\r\n
MEditCtrl.hpp<>MEditCtrl.hpp<>// MEditCtrl.hpp -- Win32API edit control wrapper               -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MEDITCTRL_HPP_\r\n#define MZC4_MEDITCTRL_HPP_     3   /* Version 3 */\r\n\r\nclass MEditCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MEditCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MEditCtrl();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    BOOL CanUndo() const;\r\n    INT GetLineCount() const;\r\n\r\n    BOOL GetModify() const;\r\n    VOID SetModify(BOOL bModified = TRUE);\r\n\r\n    BOOL IsEmpty() const;\r\n\r\n    HLOCAL GetHandle() const;\r\n    VOID SetHandle(HLOCAL hBuffer);\r\n\r\n    DWORD GetMargins() const;\r\n    VOID SetMargins(UINT nLeft, UINT nRight);\r\n\r\n    UINT GetLimitText() const;\r\n    VOID SetLimitText(UINT nMax);\r\n\r\n    POINT PosFromChar(UINT nChar) const;\r\n    INT CharFromPos(POINT pt) const;\r\n\r\n    VOID EmptyUndoBuffer();\r\n    BOOL FmtLines(BOOL bAddEOL);\r\n\r\n    VOID LimitText(INT nChars = 0);\r\n    INT  LineFromChar(INT nIndex = -1) const;\r\n    INT  LineIndex(INT nLine = -1) const;\r\n    INT  LineLength(INT nLine = -1) const;\r\n    INT  GetLine(INT nIndex, LPTSTR lpszBuffer, INT nMaxLength) const;\r\n    VOID LineScroll(INT nLines, INT nChars = 0);\r\n\r\n    TCHAR GetPasswordChar() const;\r\n    VOID  SetPasswordChar(TCHAR ch);\r\n\r\n    VOID GetRect(LPRECT prc) const;\r\n    VOID SetRect(LPCRECT prc);\r\n    VOID SetRectNP(LPCRECT prc);\r\n\r\n    DWORD GetSel() const;\r\n    VOID  GetSel(INT& nStartChar, INT& nEndChar) const;\r\n    VOID  SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);\r\n    VOID  SetSel(INT nStartChar, INT nEndChar, BOOL bNoScroll = FALSE);\r\n    VOID  ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);\r\n    VOID  SelectAll(BOOL bNoScroll = FALSE);\r\n    VOID  SelectNone(BOOL bNoScroll = FALSE);\r\n\r\n    BOOL SetTabStops(INT nTabStops, LPINT rgTabStops);\r\n    VOID SetTabStops();\r\n    BOOL SetTabStops(const INT& cxEachStop);\r\n\r\n    BOOL Undo();\r\n    VOID Clear();\r\n    VOID Copy();\r\n    VOID Cut();\r\n    VOID Paste();\r\n\r\n    BOOL SetReadOnly(BOOL bReadOnly = TRUE);\r\n    INT GetFirstVisibleLine() const;\r\n\r\n    static void SetCtrlAHookDx(BOOL bHook);\r\n\r\nprotected:\r\n    static HHOOK& OldHookProc();\r\n    static LRESULT CALLBACK\r\n    CtrlAMsgProcDx(INT nCode, WPARAM wParam, LPARAM lParam);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MEditCtrl::MEditCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MEditCtrl::GetWndClassNameDx() const\r\n{\r\n    return TEXT("EDIT");\r\n}\r\n\r\ninline BOOL MEditCtrl::CanUndo() const\r\n{\r\n    return (BOOL)SendMessageDx(EM_CANUNDO);\r\n}\r\n\r\ninline INT MEditCtrl::GetLineCount() const\r\n{\r\n    return (INT)SendMessageDx(EM_GETLINECOUNT);\r\n}\r\n\r\ninline BOOL MEditCtrl::GetModify() const\r\n{\r\n    return (BOOL)SendMessageDx(EM_GETMODIFY);\r\n}\r\n\r\ninline VOID MEditCtrl::SetModify(BOOL bModified/* = TRUE*/)\r\n{\r\n    SendMessageDx(EM_SETMODIFY, (WPARAM)bModified);\r\n}\r\n\r\ninline BOOL MEditCtrl::IsEmpty() const\r\n{\r\n    return ::GetWindowTextLength(m_hwnd) == 0;\r\n}\r\n\r\ninline VOID MEditCtrl::GetRect(LPRECT prc) const\r\n{\r\n    SendMessageDx(EM_GETRECT, 0, (LPARAM)prc);\r\n}\r\n\r\ninline DWORD MEditCtrl::GetSel() const\r\n{\r\n    return (DWORD)SendMessageDx(EM_GETSEL);\r\n}\r\n\r\ninline VOID MEditCtrl::GetSel(INT& nStartChar, INT& nEndChar) const\r\n{\r\n    SendMessageDx(EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);\r\n}\r\n\r\ninline HLOCAL MEditCtrl::GetHandle() const\r\n{\r\n    return (HLOCAL)SendMessageDx(EM_GETHANDLE);\r\n}\r\n\r\ninline VOID MEditCtrl::SetHandle(HLOCAL hBuffer)\r\n{\r\n    SendMessageDx(EM_SETHANDLE, (WPARAM)hBuffer, 0);\r\n}\r\n\r\ninline VOID MEditCtrl::SetMargins(UINT nLeft, UINT nRight)\r\n{\r\n    SendMessageDx(EM_SETMARGINS,\r\n        EC_LEFTMARGIN | EC_RIGHTMARGIN | EC_USEFONTINFO,\r\n        MAKELPARAM(nLeft, nRight));\r\n}\r\n\r\ninline DWORD MEditCtrl::GetMargins() const\r\n{\r\n    return (DWORD)SendMessageDx(EM_GETMARGINS);\r\n}\r\n\r\ninline VOID MEditCtrl::SetLimitText(UINT nMax)\r\n{\r\n    SendMessageDx(EM_SETLIMITTEXT, nMax);\r\n}\r\n\r\ninline UINT MEditCtrl::GetLimitText() const\r\n{\r\n    return (UINT)SendMessageDx(EM_GETLIMITTEXT);\r\n}\r\n\r\ninline POINT MEditCtrl::PosFromChar(UINT nChar) const\r\n{\r\n    POINT pt;\r\n    SendMessageDx(EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)nChar);\r\n    return pt;\r\n}\r\n\r\ninline INT MEditCtrl::CharFromPos(POINT pt) const\r\n{\r\n    return (INT)SendMessageDx(EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));\r\n}\r\n\r\ninline INT MEditCtrl::GetLine(\r\n    INT nIndex, LPTSTR lpszBuffer, INT nMaxLength) const\r\n{\r\n    assert(2 <= nMaxLength && nMaxLength <= 0xFFFF);\r\n    *reinterpret_cast<WORD *>(lpszBuffer) = (WORD) nMaxLength;\r\n    return (INT)SendMessageDx(EM_GETLINE, (WPARAM)nIndex, (LPARAM)lpszBuffer);\r\n}\r\n\r\ninline VOID MEditCtrl::EmptyUndoBuffer()\r\n{\r\n    SendMessageDx(EM_EMPTYUNDOBUFFER, 0, 0);\r\n}\r\n\r\ninline BOOL MEditCtrl::FmtLines(BOOL bAddEOL)\r\n{\r\n    return (BOOL)SendMessageDx(EM_FMTLINES, (WPARAM)bAddEOL);\r\n}\r\n\r\ninline VOID MEditCtrl::LimitText(INT nChars/* = 0*/)\r\n{\r\n    SendMessageDx(EM_LIMITTEXT, (WPARAM)nChars);\r\n}\r\n\r\ninline INT MEditCtrl::LineFromChar(INT nIndex/* = -1*/) const\r\n{\r\n    return (INT)SendMessageDx(EM_LINEFROMCHAR, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MEditCtrl::LineIndex(INT nLine/* = -1*/) const\r\n{\r\n    return (INT)SendMessageDx(EM_LINEINDEX, (WPARAM)nLine);\r\n}\r\n\r\ninline INT MEditCtrl::LineLength(INT nLine/* = -1*/) const\r\n{\r\n    return (INT)SendMessageDx(EM_LINELENGTH, (WPARAM)nLine);\r\n}\r\n\r\ninline VOID MEditCtrl::LineScroll(INT nLines, INT nChars/* = 0*/)\r\n{\r\n    SendMessageDx(EM_LINESCROLL, (WPARAM)nChars, (LPARAM)nLines);\r\n}\r\n\r\ninline VOID MEditCtrl::ReplaceSel(\r\n    LPCTSTR lpszNewText, BOOL bCanUndo/* = FALSE*/)\r\n{\r\n    SendMessageDx(EM_REPLACESEL, (WPARAM)bCanUndo, (LPARAM)lpszNewText);\r\n}\r\n\r\ninline VOID MEditCtrl::SelectAll(BOOL bNoScroll/* = FALSE*/)\r\n{\r\n    SetSel(0, -1, bNoScroll);\r\n}\r\n\r\ninline VOID MEditCtrl::SelectNone(BOOL bNoScroll/* = FALSE*/)\r\n{\r\n    SetSel(-1, -1, bNoScroll);\r\n}\r\n\r\ninline VOID MEditCtrl::SetPasswordChar(TCHAR ch)\r\n{\r\n    SendMessageDx(EM_SETPASSWORDCHAR, (WPARAM)ch);\r\n}\r\n\r\ninline VOID MEditCtrl::SetRect(LPCRECT prc)\r\n{\r\n    SendMessageDx(EM_SETRECT, 0, (LPARAM)prc);\r\n}\r\n\r\ninline VOID MEditCtrl::SetRectNP(LPCRECT prc)\r\n{\r\n    SendMessageDx(EM_SETRECTNP, 0, (LPARAM)prc);\r\n}\r\n\r\ninline VOID MEditCtrl::SetSel(\r\n    DWORD dwSelection, BOOL bNoScroll/* = FALSE*/)\r\n{\r\n    SetSel((INT) LOWORD(dwSelection), (INT) HIWORD(dwSelection), bNoScroll);\r\n}\r\n\r\ninline VOID MEditCtrl::SetSel(\r\n    INT nStartChar, INT nEndChar, BOOL bNoScroll/* = FALSE*/)\r\n{\r\n    SendMessageDx(EM_SETSEL, (WPARAM)nStartChar, (LPARAM)nEndChar);\r\n    if (!bNoScroll)\r\n        SendMessageDx(EM_SCROLLCARET);\r\n}\r\n\r\ninline BOOL MEditCtrl::SetTabStops(INT nTabStops, LPINT rgTabStops)\r\n{\r\n    return (BOOL)SendMessageDx(EM_SETTABSTOPS, (WPARAM)nTabStops, (LPARAM)rgTabStops);\r\n}\r\n\r\ninline VOID MEditCtrl::SetTabStops()\r\n{\r\n    SendMessageDx(EM_SETTABSTOPS);\r\n}\r\n\r\ninline BOOL MEditCtrl::SetTabStops(const INT& cxEachStop)\r\n{\r\n    return (BOOL)SendMessageDx(EM_SETTABSTOPS, 1, (LPARAM)&cxEachStop);\r\n}\r\n\r\ninline BOOL MEditCtrl::Undo()\r\n{\r\n    return (BOOL)SendMessageDx(EM_UNDO);\r\n}\r\n\r\ninline VOID MEditCtrl::Clear()\r\n{\r\n    SendMessageDx(WM_CLEAR, 0, 0);\r\n}\r\n\r\ninline VOID MEditCtrl::Copy()\r\n{\r\n    SendMessageDx(WM_COPY, 0, 0);\r\n}\r\n\r\ninline VOID MEditCtrl::Cut()\r\n{\r\n    SendMessageDx(WM_CUT, 0, 0);\r\n}\r\n\r\ninline VOID MEditCtrl::Paste()\r\n{\r\n    SendMessageDx(WM_PASTE, 0, 0);\r\n}\r\n\r\ninline BOOL MEditCtrl::SetReadOnly(BOOL bReadOnly/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(EM_SETREADONLY, (WPARAM)bReadOnly);\r\n}\r\n\r\ninline INT MEditCtrl::GetFirstVisibleLine() const\r\n{\r\n    return (INT)SendMessageDx(EM_GETFIRSTVISIBLELINE);\r\n}\r\n\r\ninline TCHAR MEditCtrl::GetPasswordChar() const\r\n{\r\n    return (TCHAR)SendMessageDx(EM_GETPASSWORDCHAR);\r\n}\r\n\r\ninline /*static*/ HHOOK& MEditCtrl::OldHookProc()\r\n{\r\n    static HHOOK s_hHook = NULL;\r\n    return s_hHook;\r\n}\r\n\r\ninline /*static*/ LRESULT CALLBACK\r\nMEditCtrl::CtrlAMsgProcDx(INT nCode, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (nCode < 0)\r\n        return ::CallNextHookEx(OldHookProc(), nCode, wParam, lParam);\r\n\r\n    MSG *pMsg = (MSG *)lParam;\r\n    TCHAR szClassName[8];\r\n    HWND hWnd;\r\n    if (pMsg->message == WM_KEYDOWN)\r\n    {\r\n        if ((INT) pMsg->wParam == 'A' &&\r\n            ::GetAsyncKeyState(VK_CONTROL) < 0 &&\r\n            ::GetAsyncKeyState(VK_SHIFT) >= 0 &&\r\n            ::GetAsyncKeyState(VK_MENU) >= 0)\r\n        {\r\n            // Ctrl+A is pressed\r\n            hWnd = ::GetFocus();\r\n            if (hWnd != NULL)\r\n            {\r\n                ::GetClassName(hWnd, szClassName, _countof(szClassName));\r\n                if (lstrcmpi(szClassName, TEXT("EDIT")) == 0)\r\n                {\r\n                    ::SendMessage(hWnd, EM_SETSEL, 0, -1);\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return ::CallNextHookEx(OldHookProc(), nCode, wParam, lParam);\r\n}\r\n\r\ninline /*static*/ void MEditCtrl::SetCtrlAHookDx(BOOL bHook)\r\n{\r\n    if (bHook)\r\n    {\r\n        assert(OldHookProc() == NULL);\r\n        OldHookProc() = ::SetWindowsHookEx(\r\n            WH_MSGFILTER, MEditCtrl::CtrlAMsgProcDx, NULL,\r\n            ::GetCurrentThreadId());\r\n    }\r\n    else\r\n    {\r\n        assert(OldHookProc() != NULL);\r\n        ::UnhookWindowsHookEx(OldHookProc());\r\n        OldHookProc() = NULL;\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MEDITCTRL_HPP_\r\n
MEvent.hpp<>MEvent.hpp<>// MEvent.hpp -- Win32API event object wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MEVENT_HPP_\r\n#define MZC4_MEVENT_HPP_        3   /* Version 3 */\r\n\r\nclass MEvent;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MSyncBase.hpp"\r\n\r\nclass MEvent : public MSyncBase\r\n{\r\npublic:\r\n    MEvent();\r\n    MEvent(HANDLE hEvent);\r\n    MEvent(const MEvent& e);\r\n    MEvent& operator=(HANDLE hEvent);\r\n    MEvent& operator=(const MEvent& e);\r\n    MEvent(BOOL bInitiallyOwn, BOOL bManualReset = FALSE,\r\n           LPCTSTR lpszName = NULL,\r\n           LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);\r\n\r\n    BOOL CreateEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,\r\n           LPCTSTR lpszName = NULL,\r\n           LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);\r\n    BOOL SetEvent();\r\n    BOOL PulseEvent();\r\n    BOOL ResetEvent();\r\n    virtual BOOL Unlock();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MEvent::MEvent()\r\n{\r\n}\r\n\r\ninline MEvent::MEvent(HANDLE hEvent) : MSyncBase(hEvent)\r\n{\r\n}\r\n\r\ninline MEvent::MEvent(const MEvent& e)\r\n    : MSyncBase(CloneHandleDx(e))\r\n{\r\n}\r\n\r\ninline MEvent& MEvent::operator=(HANDLE hEvent)\r\n{\r\n    if (Handle() != hEvent)\r\n    {\r\n        Attach(hEvent);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MEvent& MEvent::operator=(const MEvent& e)\r\n{\r\n    if (Handle() != e.Handle())\r\n    {\r\n        HANDLE hEvent = CloneHandleDx(e);\r\n        Attach(hEvent);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MEvent::MEvent(BOOL bInitiallyOwn, BOOL bManualReset,\r\n                      LPCTSTR lpszName/* = NULL*/,\r\n                      LPSECURITY_ATTRIBUTES lpsaAttribute/* = NULL*/)\r\n    : MSyncBase(::CreateEvent(lpsaAttribute, bManualReset, bInitiallyOwn, lpszName))\r\n{\r\n    assert(Handle());\r\n}\r\n    \r\ninline BOOL MEvent::CreateEvent(\r\n    BOOL bInitiallyOwn/* = FALSE*/, BOOL bManualReset/* = FALSE*/,\r\n    LPCTSTR lpszName/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpsaAttribute/* = NULL*/)\r\n{\r\n    return Attach(::CreateEvent(lpsaAttribute, bManualReset, bInitiallyOwn, lpszName));\r\n}\r\n\r\ninline /*virtual*/ BOOL MEvent::Unlock()\r\n{\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MEvent::SetEvent()\r\n{\r\n    assert(Handle());\r\n    return ::SetEvent(Handle());\r\n}\r\n\r\ninline BOOL MEvent::PulseEvent()\r\n{\r\n    assert(Handle());\r\n    return ::PulseEvent(Handle());\r\n}\r\n\r\ninline BOOL MEvent::ResetEvent()\r\n{\r\n    assert(Handle());\r\n    return ::ResetEvent(Handle());\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MEVENT_HPP_\r\n
MFile.hpp<>MFile.hpp<>// MFile.hpp -- Win32API file or pipe wrapper                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFILE_HPP_\r\n#define MZC4_MFILE_HPP_     13      /* Version 13 */\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>\r\n#endif\r\n#include <tchar.h>\r\n#include <cassert>\r\n#ifndef NO_STRSAFE\r\n    #include <strsafe.h>\r\n#endif\r\n\r\nclass MFile;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef LOLONG\r\n    #define LOLONG(dwl) static_cast<DWORD>(dwl)\r\n#endif\r\n#ifndef HILONG\r\n    #define HILONG(dwl) static_cast<DWORD>(((dwl) >> 32) & 0xFFFFFFFF)\r\n#endif\r\n#ifndef MAKELONGLONG\r\n    #define MAKELONGLONG(lo,hi) \\\r\n        (static_cast<DWORD>(lo) | \\\r\n            (static_cast<DWORDLONG>(static_cast<DWORD>(hi)) << 32))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MFile\r\n{\r\npublic:\r\n    HANDLE m_hFile;\r\n\r\npublic:\r\n    MFile();\r\n    MFile(HANDLE hFile);\r\n    MFile(const MFile& file);\r\n    MFile& operator=(HANDLE hFile);\r\n    MFile& operator=(const MFile& file);\r\n    MFile(LPCTSTR pszFileName, BOOL bOutput = FALSE,\r\n          DWORD dwFILE_SHARE_ = FILE_SHARE_READ);\r\n    virtual ~MFile();\r\n\r\n    operator HANDLE() const;\r\n    PHANDLE operator&();\r\n\r\n    bool operator!() const;\r\n    bool operator==(HANDLE hFile) const;\r\n    bool operator!=(HANDLE hFile) const;\r\n    bool operator==(const MFile& file) const;\r\n    bool operator!=(const MFile& file) const;\r\n\r\n    BOOL Attach(HANDLE hFile);\r\n    HANDLE Detach();\r\n    HANDLE Handle() const;\r\n    BOOL CloseHandle();\r\n\r\n    BOOL DuplicateHandle(PHANDLE phFile, BOOL bInherit);\r\n    BOOL DuplicateHandle(PHANDLE phFile, BOOL bInherit,\r\n                         DWORD dwDesiredAccess);\r\n    DWORD WaitForSingleObject(DWORD dwTimeout = INFINITE);\r\n\r\n    BOOL PeekNamedPipe(LPVOID pBuffer = NULL, DWORD cbBuffer = 0,\r\n                       LPDWORD pcbRead = NULL, LPDWORD pcbAvail = NULL,\r\n                       LPDWORD pBytesLeft = NULL);\r\n    BOOL ReadFile(LPVOID pBuffer, DWORD cbToRead, LPDWORD pcbRead,\r\n                  LPOVERLAPPED pOverlapped = NULL);\r\n    BOOL WriteFile(LPCVOID pBuffer, DWORD cbToWrite, LPDWORD pcbWritten,\r\n                   LPOVERLAPPED pOverlapped = NULL);\r\n    BOOL WriteSzA(LPCSTR psz, LPDWORD pcbWritten,\r\n                  LPOVERLAPPED pOverlapped = NULL);\r\n    BOOL WriteSzW(LPCWSTR psz, LPDWORD pcbWritten,\r\n                  LPOVERLAPPED pOverlapped = NULL);\r\n    BOOL WriteSz(LPCTSTR psz, LPDWORD pcbWritten,\r\n                 LPOVERLAPPED pOverlapped = NULL);\r\n\r\n    BOOL         WriteBinary(LPCVOID pv, DWORD cb);\r\n    BOOL         WriteSzA(LPCSTR psz);\r\n    BOOL         WriteSzW(LPCWSTR psz);\r\n    BOOL         WriteSz(LPCTSTR psz);\r\n    BOOL __cdecl WriteFormatA(LPCSTR pszFormat, ...);\r\n    BOOL __cdecl WriteFormatW(LPCWSTR pszFormat, ...);\r\n    BOOL __cdecl WriteFormat(LPCTSTR pszFormat, ...);\r\n\r\n    BOOL GetStdHandle(DWORD dwSTD_);\r\n    BOOL GetStdIn();\r\n    BOOL GetStdOut();\r\n    BOOL GetStdErr();\r\n    BOOL SetStdHandle(DWORD dwSTD_) const;\r\n    BOOL SetStdIn() const;\r\n    BOOL SetStdOut() const;\r\n    BOOL SetStdErr() const;\r\n\r\n    BOOL OpenFileForInput(LPCTSTR pszFileName,\r\n                          DWORD dwFILE_SHARE_ = FILE_SHARE_READ);\r\n    BOOL OpenFileForOutput(LPCTSTR pszFileName,\r\n                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);\r\n    BOOL OpenFileForRandom(LPCTSTR pszFileName,\r\n                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);\r\n    BOOL OpenFileForAppend(LPCTSTR pszFileName,\r\n                           DWORD dwFILE_SHARE_ = FILE_SHARE_READ);\r\n\r\n    BOOL CreateFile(LPCTSTR pszFileName, DWORD dwDesiredAccess,\r\n                    DWORD dwShareMode, LPSECURITY_ATTRIBUTES pSA,\r\n                    DWORD dwCreationDistribution,\r\n                    DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,\r\n                    HANDLE hTemplateFile = NULL);\r\n    DWORD GetFileSize(LPDWORD pdwHighPart = NULL) const;\r\n    DWORDLONG GetFileSize64() const;\r\n    BOOL SetEndOfFile();\r\n    DWORD SetFilePointer(LONG nDeltaLow, PLONG pnDeltaHigh = NULL,\r\n                         DWORD dwOrigin = FILE_BEGIN);\r\n    VOID SeekToBegin();\r\n    DWORD SeekToEnd();\r\n    BOOL FlushFileBuffers();\r\n    BOOL GetFileTime(LPFILETIME pftCreate = NULL,\r\n                     LPFILETIME pftLastAccess = NULL,\r\n                     LPFILETIME pftLastWrite = NULL) const;\r\n\r\n    BOOL GetFileInformationByHandle(LPBY_HANDLE_FILE_INFORMATION info);\r\n    DWORD GetFileType() const;\r\n\r\n    BOOL LockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,\r\n                  DWORD dwNumberOfBytesToLockLow,\r\n                  DWORD dwNumberOfBytesToLockHigh);\r\n    BOOL LockFile(DWORDLONG dwlFileOffset, DWORDLONG dwlNumberOfBytesToLock);\r\n\r\n    BOOL LockFileEx(DWORD dwFlags, DWORD dwReserved,\r\n                    DWORD dwNumberOfBytesToLockLow,\r\n                    DWORD dwNumberOfBytesToLockHigh,\r\n                    LPOVERLAPPED lpOverlapped);\r\n    BOOL LockFileEx(DWORD dwFlags, DWORD dwReserved,\r\n                    DWORDLONG dwlNumberOfBytesToLock,\r\n                    LPOVERLAPPED lpOverlapped);\r\n\r\n    BOOL UnlockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,\r\n                    DWORD dwNumberOfBytesToUnlockLow,\r\n                    DWORD dwNumberOfBytesToUnlockHigh);\r\n    BOOL UnlockFile(DWORDLONG dwFileOffset, DWORDLONG dwNumberOfBytesToUnlock);\r\n\r\n    BOOL UnlockFileEx(DWORD dwReserved, DWORD dwNumberOfBytesToUnlockLow,\r\n                      DWORD dwNumberOfBytesToUnlockHigh,\r\n                      LPOVERLAPPED lpOverlapped);\r\n    BOOL UnlockFileEx(DWORD dwReserved, DWORDLONG dwlNumberOfBytesToUnlock,\r\n                      LPOVERLAPPED lpOverlapped);\r\n\r\n    BOOL ReadFileEx(LPVOID pBuffer, DWORD cbToRead, LPOVERLAPPED pOverlapped,\r\n                    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);\r\n    BOOL WriteFileEx(LPCVOID pBuffer, DWORD cbToWrite, LPOVERLAPPED pOverlapped,\r\n                     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);\r\n\r\n    static HANDLE CloneHandleDx(HANDLE hFile);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MFile::MFile() : m_hFile(INVALID_HANDLE_VALUE)\r\n{\r\n}\r\n\r\ninline MFile::MFile(HANDLE hFile) : m_hFile(hFile)\r\n{\r\n}\r\n\r\ninline MFile::MFile(const MFile& file)\r\n    : m_hFile(CloneHandleDx(file.m_hFile))\r\n{\r\n}\r\n\r\ninline MFile& MFile::operator=(const MFile& file)\r\n{\r\n    if (Handle() != file.m_hFile)\r\n    {\r\n        HANDLE hFile = CloneHandleDx(file.m_hFile);\r\n        Attach(hFile);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MFile::MFile(LPCTSTR pszFileName, BOOL bOutput/* = FALSE*/,\r\n                        DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)\r\n    : m_hFile(INVALID_HANDLE_VALUE)\r\n{\r\n    if (bOutput)\r\n        OpenFileForOutput(pszFileName, dwFILE_SHARE_);\r\n    else\r\n        OpenFileForInput(pszFileName, dwFILE_SHARE_);\r\n}\r\n\r\ninline /*virtual*/ MFile::~MFile()\r\n{\r\n    CloseHandle();\r\n}\r\n\r\ninline HANDLE MFile::Handle() const\r\n{\r\n    if (this == NULL)\r\n        return INVALID_HANDLE_VALUE;\r\n    if (m_hFile == NULL)\r\n        return INVALID_HANDLE_VALUE;\r\n    return m_hFile;\r\n}\r\n\r\ninline MFile::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline PHANDLE MFile::operator&()\r\n{\r\n    return &m_hFile;\r\n}\r\n\r\ninline bool MFile::operator!() const\r\n{\r\n    HANDLE hFile = Handle();\r\n    return hFile == INVALID_HANDLE_VALUE || hFile == NULL;\r\n}\r\n\r\ninline bool MFile::operator==(HANDLE hFile) const\r\n{\r\n    return Handle() == hFile;\r\n}\r\n\r\ninline bool MFile::operator!=(HANDLE hFile) const\r\n{\r\n    return Handle() != hFile;\r\n}\r\n\r\ninline bool MFile::operator==(const MFile& file) const\r\n{\r\n    return Handle() == file.Handle();\r\n}\r\n\r\ninline bool MFile::operator!=(const MFile& file) const\r\n{\r\n    return Handle() != file.Handle();\r\n}\r\n\r\ninline BOOL MFile::OpenFileForInput(\r\n    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)\r\n{\r\n    return MFile::CreateFile(pszFileName, GENERIC_READ,\r\n        dwFILE_SHARE_, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n}\r\n\r\ninline BOOL MFile::OpenFileForOutput(\r\n    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)\r\n{\r\n    return MFile::CreateFile(pszFileName, GENERIC_WRITE,\r\n        dwFILE_SHARE_, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\r\n}\r\n\r\ninline BOOL MFile::OpenFileForRandom(\r\n    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)\r\n{\r\n    return MFile::CreateFile(pszFileName,\r\n        GENERIC_READ | GENERIC_WRITE, dwFILE_SHARE_, NULL, OPEN_ALWAYS,\r\n        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);\r\n}\r\n\r\ninline DWORD MFile::WaitForSingleObject(\r\n    DWORD dwTimeout/* = INFINITE*/)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::WaitForSingleObject(m_hFile, dwTimeout);\r\n}\r\n\r\ninline MFile& MFile::operator=(HANDLE hFile)\r\n{\r\n#ifndef NDEBUG\r\n    BY_HANDLE_FILE_INFORMATION info;\r\n    assert(hFile == INVALID_HANDLE_VALUE ||\r\n        ::GetFileInformationByHandle(hFile, &info));\r\n#endif\r\n    if (Handle() != hFile)\r\n    {\r\n        Attach(hFile);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MFile::Attach(HANDLE hFile)\r\n{\r\n    CloseHandle();\r\n    assert(hFile != NULL && hFile != INVALID_HANDLE_VALUE);\r\n    assert(m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE);\r\n#ifndef NDEBUG\r\n    BY_HANDLE_FILE_INFORMATION info;\r\n    assert(::GetFileInformationByHandle(hFile, &info));\r\n#endif\r\n    m_hFile = hFile;\r\n    return m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE;\r\n}\r\n\r\ninline HANDLE MFile::Detach()\r\n{\r\n    HANDLE hFile = m_hFile;\r\n    m_hFile = NULL;\r\n    return hFile;\r\n}\r\n\r\ninline BOOL MFile::CloseHandle()\r\n{\r\n    if (Handle() != NULL && Handle() != INVALID_HANDLE_VALUE)\r\n    {\r\n        BOOL bOK = ::CloseHandle(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MFile::PeekNamedPipe(\r\n    LPVOID pBuffer/* = NULL*/,\r\n    DWORD cbBuffer/* = 0*/,\r\n    LPDWORD pcbRead/* = NULL*/,\r\n    LPDWORD pcbAvail/* = NULL*/,\r\n    LPDWORD pBytesLeft/* = NULL*/)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::PeekNamedPipe(m_hFile, pBuffer, cbBuffer,\r\n        pcbRead, pcbAvail, pBytesLeft);\r\n}\r\n\r\ninline BOOL MFile::ReadFile(LPVOID pBuffer, DWORD cbToRead,\r\n    LPDWORD pcbRead, LPOVERLAPPED pOverlapped/* = NULL*/)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::ReadFile(m_hFile, pBuffer, cbToRead, pcbRead, pOverlapped);\r\n}\r\n\r\ninline BOOL MFile::WriteFile(LPCVOID pBuffer, DWORD cbToWrite,\r\n    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::WriteFile(\r\n        m_hFile, pBuffer, cbToWrite, pcbWritten, pOverlapped);\r\n}\r\n\r\ninline BOOL MFile::WriteSzA(LPCSTR psz,\r\n    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)\r\n{\r\n    using namespace std;\r\n    SIZE_T size = strlen(psz) * sizeof(CHAR);\r\n    return WriteFile(psz, (DWORD)size, pcbWritten, pOverlapped);\r\n}\r\n\r\ninline BOOL MFile::WriteSzW(LPCWSTR psz,\r\n    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)\r\n{\r\n    using namespace std;\r\n    SIZE_T size = wcslen(psz) * sizeof(WCHAR);\r\n    return WriteFile(psz, (DWORD)size, pcbWritten, pOverlapped);\r\n}\r\n\r\ninline BOOL MFile::WriteSz(LPCTSTR psz,\r\n    LPDWORD pcbWritten, LPOVERLAPPED pOverlapped/* = NULL*/)\r\n{\r\n    return WriteFile(psz, (DWORD)(lstrlen(psz) * sizeof(TCHAR)), pcbWritten, pOverlapped);\r\n}\r\n\r\ninline BOOL MFile::CreateFile(LPCTSTR pszFileName,\r\n    DWORD dwDesiredAccess, DWORD dwShareMode,\r\n    LPSECURITY_ATTRIBUTES pSA, DWORD dwCreationDistribution,\r\n    DWORD dwFlagsAndAttributes/* = FILE_ATTRIBUTE_NORMAL*/,\r\n    HANDLE hTemplateFile/* = NULL*/)\r\n{\r\n    return Attach(::CreateFile(pszFileName, dwDesiredAccess, dwShareMode,\r\n                  pSA, dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile));\r\n}\r\n\r\ninline DWORD MFile::SetFilePointer(\r\n    LONG nDeltaLow,\r\n    PLONG pnDeltaHigh/* = NULL*/,\r\n    DWORD dwOrigin/* = FILE_BEGIN*/)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::SetFilePointer(m_hFile, nDeltaLow, pnDeltaHigh, dwOrigin);\r\n}\r\n\r\ninline DWORD MFile::SeekToEnd()\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return SetFilePointer(0, NULL, FILE_END);\r\n}\r\n\r\ninline VOID MFile::SeekToBegin()\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    SetFilePointer(0, NULL, FILE_BEGIN);\r\n}\r\n\r\ninline DWORD MFile::GetFileSize(LPDWORD pdwHighPart/* = NULL*/) const\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::GetFileSize(m_hFile, pdwHighPart);\r\n}\r\n\r\ninline DWORDLONG MFile::GetFileSize64() const\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    DWORD dwLow, dwHigh;\r\n    dwLow = ::GetFileSize(m_hFile, &dwHigh);\r\n    if (dwLow == 0xFFFFFFFF && ::GetLastError() != NO_ERROR)\r\n        return 0;\r\n    else\r\n        return MAKELONGLONG(dwLow, dwHigh);\r\n}\r\n\r\ninline BOOL MFile::SetEndOfFile()\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::SetEndOfFile(m_hFile);\r\n}\r\n\r\ninline BOOL MFile::FlushFileBuffers()\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::FlushFileBuffers(m_hFile);\r\n}\r\n\r\ninline BOOL MFile::WriteSzA(LPCSTR psz)\r\n{\r\n    assert(psz);\r\n    INT cb = lstrlenA(psz);\r\n    return WriteBinary(psz, (DWORD) cb);\r\n}\r\n\r\ninline BOOL MFile::WriteSzW(LPCWSTR psz)\r\n{\r\n    assert(psz);\r\n    INT cb = lstrlenW(psz) * sizeof(WCHAR);\r\n    return WriteBinary(psz, (DWORD) cb);\r\n}\r\n\r\ninline BOOL MFile::WriteSz(LPCTSTR psz)\r\n{\r\n    assert(psz);\r\n    INT cb = lstrlen(psz) * sizeof(TCHAR);\r\n    return WriteBinary(psz, (DWORD) cb);\r\n}\r\n\r\ninline BOOL MFile::GetFileTime(\r\n    LPFILETIME pftCreate/* = NULL*/,\r\n    LPFILETIME pftLastAccess/* = NULL*/,\r\n    LPFILETIME pftLastWrite/* = NULL*/) const\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::GetFileTime(m_hFile, pftCreate, pftLastAccess, pftLastWrite);\r\n}\r\n\r\ninline DWORD MFile::GetFileType() const\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::GetFileType(m_hFile);\r\n}\r\n\r\ninline BOOL MFile::GetFileInformationByHandle(LPBY_HANDLE_FILE_INFORMATION info)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::GetFileInformationByHandle(m_hFile, info);\r\n}\r\n\r\ninline BOOL MFile::LockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,\r\n    DWORD dwNumberOfBytesToLockLow, DWORD dwNumberOfBytesToLockHigh)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::LockFile(m_hFile, dwFileOffsetLow, dwFileOffsetHigh,\r\n        dwNumberOfBytesToLockLow, dwNumberOfBytesToLockHigh);\r\n}\r\n\r\ninline BOOL MFile::LockFile(DWORDLONG dwlFileOffset, DWORDLONG dwlNumberOfBytesToLock)\r\n{\r\n    return MFile::LockFile(LOLONG(dwlFileOffset), HILONG(dwlFileOffset),\r\n        LOLONG(dwlNumberOfBytesToLock), HILONG(dwlNumberOfBytesToLock));\r\n}\r\n\r\ninline BOOL MFile::LockFileEx(DWORD dwFlags, DWORD dwReserved,\r\n    DWORD dwNumberOfBytesToLockLow, DWORD dwNumberOfBytesToLockHigh,\r\n    LPOVERLAPPED lpOverlapped)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::LockFileEx(m_hFile, dwFlags, dwReserved,\r\n        dwNumberOfBytesToLockLow, dwNumberOfBytesToLockHigh, lpOverlapped);\r\n}\r\n\r\ninline BOOL MFile::LockFileEx(DWORD dwFlags, DWORD dwReserved,\r\n    DWORDLONG dwlNumberOfBytesToLock, LPOVERLAPPED lpOverlapped)\r\n{\r\n    return MFile::LockFileEx(dwFlags, dwReserved,\r\n        LOLONG(dwlNumberOfBytesToLock), HILONG(dwlNumberOfBytesToLock),\r\n        lpOverlapped);\r\n}\r\n\r\ninline BOOL MFile::UnlockFile(DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh,\r\n    DWORD dwNumberOfBytesToUnlockLow, DWORD dwNumberOfBytesToUnlockHigh)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::UnlockFile(m_hFile, dwFileOffsetLow, dwFileOffsetHigh,\r\n        dwNumberOfBytesToUnlockLow, dwNumberOfBytesToUnlockHigh);\r\n}\r\n\r\ninline BOOL MFile::UnlockFile(DWORDLONG dwFileOffset, DWORDLONG dwNumberOfBytesToUnlock)\r\n{\r\n    return MFile::UnlockFile(LOLONG(dwFileOffset), HILONG(dwFileOffset),\r\n        LOLONG(dwNumberOfBytesToUnlock), HILONG(dwNumberOfBytesToUnlock));\r\n}\r\n\r\ninline BOOL MFile::UnlockFileEx(DWORD dwReserved, DWORD dwNumberOfBytesToUnlockLow,\r\n    DWORD dwNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::UnlockFileEx(m_hFile, dwReserved, dwNumberOfBytesToUnlockLow,\r\n        dwNumberOfBytesToUnlockHigh, lpOverlapped);\r\n}\r\n\r\ninline BOOL MFile::UnlockFileEx(DWORD dwReserved, DWORDLONG dwlNumberOfBytesToUnlock,\r\n    LPOVERLAPPED lpOverlapped)\r\n{\r\n    return MFile::UnlockFileEx(dwReserved, LOLONG(dwlNumberOfBytesToUnlock),\r\n        HILONG(dwlNumberOfBytesToUnlock), lpOverlapped);\r\n}\r\n\r\ninline BOOL MFile::ReadFileEx(LPVOID pBuffer, DWORD cbToRead, \r\n    LPOVERLAPPED pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::ReadFileEx(m_hFile, pBuffer, cbToRead, pOverlapped, lpCompletionRoutine);\r\n}\r\n\r\ninline BOOL MFile::WriteFileEx(LPCVOID pBuffer, DWORD cbToWrite, \r\n    LPOVERLAPPED pOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    return ::WriteFileEx(m_hFile, pBuffer, cbToWrite, pOverlapped, lpCompletionRoutine);\r\n}\r\n\r\n\r\ninline BOOL MFile::GetStdHandle(DWORD dwSTD_)\r\n{\r\n    return Attach(::GetStdHandle(dwSTD_));\r\n}\r\n\r\ninline BOOL MFile::GetStdIn()\r\n{\r\n    return Attach(::GetStdHandle(STD_INPUT_HANDLE));\r\n}\r\n\r\ninline BOOL MFile::GetStdOut()\r\n{\r\n    return Attach(::GetStdHandle(STD_OUTPUT_HANDLE));\r\n}\r\n\r\ninline BOOL MFile::GetStdErr()\r\n{\r\n    return Attach(::GetStdHandle(STD_ERROR_HANDLE));\r\n}\r\n\r\ninline BOOL MFile::SetStdHandle(DWORD dwSTD_) const\r\n{\r\n    return ::SetStdHandle(dwSTD_, m_hFile);\r\n}\r\n\r\ninline BOOL MFile::SetStdIn() const\r\n{\r\n    return ::SetStdHandle(STD_INPUT_HANDLE, m_hFile);\r\n}\r\n\r\ninline BOOL MFile::SetStdOut() const\r\n{\r\n    return ::SetStdHandle(STD_OUTPUT_HANDLE, m_hFile);\r\n}\r\n\r\ninline BOOL MFile::SetStdErr() const\r\n{\r\n    return ::SetStdHandle(STD_ERROR_HANDLE, m_hFile);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline BOOL MFile::DuplicateHandle(PHANDLE phFile, BOOL bInherit)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    return ::DuplicateHandle(hProcess, m_hFile, hProcess, phFile, 0,\r\n        bInherit, DUPLICATE_SAME_ACCESS);\r\n}\r\n\r\ninline BOOL MFile::DuplicateHandle(\r\n    PHANDLE phFile, BOOL bInherit, DWORD dwDesiredAccess)\r\n{\r\n    assert(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE);\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    return ::DuplicateHandle(hProcess, m_hFile, hProcess, phFile,\r\n        dwDesiredAccess, bInherit, 0);\r\n}\r\n\r\ninline BOOL __cdecl MFile::WriteFormatA(LPCSTR pszFormat, ...)\r\n{\r\n    assert(pszFormat);\r\n    assert(strlen(pszFormat) < 1024);\r\n    va_list argList;\r\n    CHAR sz[1024];\r\n    va_start(argList, pszFormat);\r\n#ifndef NO_STRSAFE\r\n    StringCchVPrintfA(sz, _countof(sz), pszFormat, argList);\r\n#else\r\n    wvsprintfA(sz, pszFormat, argList);\r\n#endif\r\n    BOOL b = WriteSzA(sz);\r\n    va_end(argList);\r\n    return b;\r\n}\r\n\r\ninline BOOL __cdecl MFile::WriteFormatW(LPCWSTR pszFormat, ...)\r\n{\r\n    assert(pszFormat);\r\n    assert(wcslen(pszFormat) < 1024);\r\n    va_list argList;\r\n    WCHAR sz[1024];\r\n    va_start(argList, pszFormat);\r\n#ifndef NO_STRSAFE\r\n    StringCchVPrintfW(sz, _countof(sz), pszFormat, argList);\r\n#else\r\n    wvsprintfW(sz, pszFormat, argList);\r\n#endif\r\n    BOOL b = WriteSzW(sz);\r\n    va_end(argList);\r\n    return b;\r\n}\r\n\r\ninline BOOL __cdecl MFile::WriteFormat(LPCTSTR pszFormat, ...)\r\n{\r\n    assert(pszFormat);\r\n    assert(lstrlen(pszFormat) < 1024);\r\n    va_list argList;\r\n    TCHAR sz[1024];\r\n    va_start(argList, pszFormat);\r\n#ifndef NO_STRSAFE\r\n    StringCchVPrintf(sz, _countof(sz), pszFormat, argList);\r\n#else\r\n    wvsprintf(sz, pszFormat, argList);\r\n#endif\r\n    BOOL b = WriteSz(sz);\r\n    va_end(argList);\r\n    return b;\r\n}\r\n\r\ninline BOOL MFile::OpenFileForAppend(\r\n    LPCTSTR pszFileName, DWORD dwFILE_SHARE_/* = FILE_SHARE_READ*/)\r\n{\r\n    assert(pszFileName);\r\n    BOOL bExisted = (::GetFileAttributes(pszFileName) != 0xFFFFFFFF);\r\n    if (!MFile::CreateFile(pszFileName, GENERIC_READ | GENERIC_WRITE,\r\n        dwFILE_SHARE_, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))\r\n        return FALSE;\r\n    if (SetFilePointer(0, NULL, FILE_END) == 0xFFFFFFFF)\r\n    {\r\n        assert(false);\r\n        CloseHandle();\r\n        if (!bExisted)\r\n            ::DeleteFile(pszFileName);\r\n        return FALSE;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFile::WriteBinary(LPCVOID pv, DWORD cb)\r\n{\r\n    assert(pv || cb == 0);\r\n    const BYTE *pb = reinterpret_cast<const BYTE *>(pv);\r\n    DWORD cbWritten;\r\n    while (cb != 0)\r\n    {\r\n        if (WriteFile(pb, cb, &cbWritten))\r\n        {\r\n            cb -= cbWritten;\r\n            pb += cbWritten;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    return (cb == 0);\r\n}\r\n\r\ninline /*static*/ HANDLE MFile::CloneHandleDx(HANDLE hFile)\r\n{\r\n    if (hFile == INVALID_HANDLE_VALUE || hFile == NULL)\r\n        return INVALID_HANDLE_VALUE;\r\n\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    HANDLE hDup = INVALID_HANDLE_VALUE;\r\n    ::DuplicateHandle(hProcess, hFile, hProcess, &hDup, 0,\r\n                      FALSE, DUPLICATE_SAME_ACCESS);\r\n    return hDup;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFILE_HPP_\r\n
MFileAPI.h<>MFileAPI.h<>/* MFileAPI.h -- filesystem manipulator                       -*- C++ -*-\r\n * This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n */\r\n\r\n#ifndef MZC4_MFILEAPI_H_\r\n#define MZC4_MFILEAPI_H_        32  /* Version 32 */\r\n\r\n/*\r\n * mpath_... functions\r\n * mdir_... functions\r\n * mfile_... functions\r\n */\r\n\r\n/* TODO: support MSDOS, link, shortcut */\r\n/**************************************************************************/\r\n\r\n#if defined(UNICODE) && !defined(_UNICODE)\r\n    #define _UNICODE\r\n#endif\r\n#if !defined(UNICODE) && defined(_UNICODE)\r\n    #define UNICODE\r\n#endif\r\n\r\n/* C99 and C++11 */\r\n#if __STDC_VERSION__ >= 199901L && !defined(C99)\r\n    #define C99             1\r\n#endif\r\n#if __cplusplus >= 201103L && !defined(CXX11)\r\n    #define CXX11           1\r\n#endif\r\n\r\n/* Some C compilers don't support inline keyword. Use __inline instread if so. */\r\n#ifndef MZC_INLINE\r\n    #ifdef __cplusplus\r\n        #define MZC_INLINE inline\r\n    #elif (__STDC_VERSION__ >= 199901L)\r\n        #define MZC_INLINE inline\r\n    #else\r\n        #define MZC_INLINE __inline\r\n    #endif\r\n#endif\r\n\r\n/* <stdbool.h> and <stdint.h> */\r\n#ifdef __cplusplus\r\n    #ifdef CXX11\r\n        #include <cstdint>\r\n    #else\r\n        #include "pstdint.h"\r\n    #endif\r\n#else\r\n    #if C99\r\n        #include <stdbool.h>\r\n        #include <stdint.h>\r\n    #else\r\n        #include "pstdbool.h"\r\n        #include "pstdint.h"\r\n    #endif\r\n#endif\r\n\r\n#ifndef USING_NAMESPACE_STD\r\n    #ifdef __cplusplus\r\n        #define USING_NAMESPACE_STD     using namespace std\r\n    #else\r\n        #define USING_NAMESPACE_STD     /*empty*/\r\n    #endif\r\n#endif\r\n\r\n#ifdef _WIN32\r\n    #ifndef _INC_WINDOWS\r\n        #include <windows.h>    /* Win32API */\r\n    #endif\r\n    #include <mbstring.h>       /* _mbsrchr */\r\n    #include <tchar.h>          /* generic text mapping */\r\n\r\n    #ifndef MChar\r\n        typedef TCHAR MChar;\r\n        #define MChar MChar\r\n    #endif\r\n\r\n    #ifndef NO_STRSAFE\r\n        #include <strsafe.h>\r\n    #endif\r\n#else\r\n    #ifdef __cplusplus\r\n        #include <cstdlib>\r\n        #include <cstdio>\r\n    #else\r\n        #include <stdlib.h>\r\n        #include <stdio.h>\r\n    #endif\r\n\r\n    #include <sys/stat.h>\r\n    #include <sys/types.h>\r\n\r\n    #ifdef MSDOS\r\n        #include <direct.h>\r\n    #else\r\n        #include <unistd.h>\r\n        #include <dirent.h>     /* opendir, ... */\r\n    #endif\r\n\r\n    #ifndef MChar\r\n        typedef char MChar;\r\n        #define MChar MChar\r\n    #endif\r\n\r\n    #ifndef MAX_PATH\r\n        #ifdef PATH_MAX\r\n            #define MAX_PATH    PATH_MAX\r\n        #else\r\n            #define MAX_PATH    260\r\n        #endif\r\n    #endif\r\n\r\n    #ifndef TEXT\r\n        #define TEXT(x)     x\r\n    #endif\r\n#endif\r\n\r\n#ifdef __cplusplus\r\n    #include <cassert>          /* assert */\r\n    #include <cstring>          /* strlen, wcslen */\r\n    #include <string>           /* for std::string */\r\n    #include <vector>           /* for std::vector */\r\n    #include <algorithm>        /* for std::sort */\r\n#else\r\n    #include <assert.h>\r\n    #include <string.h>\r\n#endif\r\n\r\n#ifndef optional_\r\n    #ifdef __cplusplus\r\n        #define optional_(def) = def\r\n    #else\r\n        #define optional_(def)      /*empty*/\r\n    #endif\r\n#endif\r\n\r\n/**************************************************************************/\r\n/* pathname */\r\n\r\nbool mpath_Exists(const MChar *pathname);\r\nMChar *mpath_GetFullPath(MChar *full, const MChar *relative);\r\nMChar *mpath_AddSep(MChar *pathname);\r\nMChar *mpath_RemoveSep(MChar *pathname);\r\nMChar *mpath_FindTitle(const MChar *pathname);\r\nMChar *mpath_SetTitle(MChar *pathname, const MChar *title);\r\nMChar *mpath_FindDotExt(const MChar *pathname);\r\nMChar *mpath_SetDotExt(MChar *pathname, const MChar *dot_ext);\r\nbool mpath_IsDots(const MChar *name);\r\nvoid mpath_BackslashToSlash(MChar *pathname);\r\nvoid mpath_SlashToBackslash(MChar *pathname);\r\n\r\n/**************************************************************************/\r\n/* directory */\r\n\r\nbool mdir_Exists(const MChar *pathname);\r\nbool mdir_Create(const MChar *pathname);\r\nbool mdir_Remove(const MChar *pathname);\r\nbool mdir_Get(MChar *pathname, size_t maxbuf optional_(MAX_PATH));\r\nbool mdir_Set(const MChar *pathname);\r\nbool mdir_CreateRecurse(const MChar *pathname, bool fForce optional_(false));\r\n\r\n#ifndef MSDOS\r\n    #ifdef _WIN32\r\n        typedef WIN32_FIND_DATA     MZC_DIR_INFO;\r\n        typedef HANDLE              MZC_DIR_P;\r\n    #else\r\n        typedef struct MZC_DIR_INFO\r\n        {\r\n            MChar   cFileName[MAX_PATH];\r\n        } MZC_DIR_INFO;\r\n        typedef DIR *MZC_DIR_P;\r\n    #endif\r\n\r\n    MZC_DIR_P mdir_FindFirstItem(const MChar *pathname, MZC_DIR_INFO *info);\r\n    bool      mdir_FindNextItem(MZC_DIR_P dirp, MZC_DIR_INFO *info);\r\n    bool      mdir_FindClose(MZC_DIR_P dirp);\r\n\r\n    bool mdir_Delete(const MChar *dir);\r\n\r\n    #ifdef __cplusplus\r\n        #include "MString.hpp"\r\n\r\n        bool mdir_GetItemList(const MChar *dirname, std::vector<MString>& items,\r\n                              bool sort = true);\r\n        bool mdir_GetFullPathList(const MChar *dirname, std::vector<MString>& paths,\r\n                                  bool recursive = true, bool sort = true);\r\n    #endif\r\n#endif  /* ndef MSDOS */\r\n\r\n/**************************************************************************/\r\n/* file */\r\n\r\nbool mfile_Exists(const MChar *filename);\r\n\r\nuint8_t *\r\nmfile_GetContents(const MChar *filename, size_t *psize optional_(NULL));\r\nbool\r\nmfile_PutContents(const MChar *filename, const void *pvContents, size_t size);\r\n\r\nbool mfile_PutText(const MChar *filename, const MChar *psz);\r\n\r\nbool mfile_Move(const MChar *existing_file, const MChar *new_file);\r\nbool mfile_Copy(const MChar *existing_file, const MChar *new_file,\r\n                bool bFailIfExists optional_(false));\r\nbool mfile_Delete(const MChar *filename);\r\n\r\nunsigned long mfile_GetSize(const MChar *filename, unsigned long *high);\r\nuint64_t      mfile_GetSize64(const MChar *filename);\r\n\r\n/**************************************************************************/\r\n\r\nMZC_INLINE bool mpath_Exists(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(pathname);\r\n#ifdef _WIN32\r\n    DWORD attrs;\r\n#else\r\n    struct stat sbuf;\r\n#endif\r\n\r\n    assert(pathname);\r\n#ifdef _WIN32\r\n    attrs = GetFileAttributes(pathname);\r\n    return (attrs != 0xFFFFFFFF);\r\n#else\r\n    return (stat(pathname, &sbuf) == 0);\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool mfile_Exists(const MChar *filename)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(filename);\r\n#ifdef _WIN32\r\n    DWORD attrs;\r\n#else\r\n    struct stat sbuf;\r\n#endif\r\n\r\n    assert(filename);\r\n#ifdef _WIN32\r\n    attrs = GetFileAttributes(filename);\r\n    return (attrs != 0xFFFFFFFF) && !(attrs & FILE_ATTRIBUTE_DIRECTORY);\r\n#else\r\n    if (stat(filename, &sbuf) == 0)\r\n    {\r\n        if ((sbuf.st_mode & S_IFMT) == S_IFREG)\r\n            return true;\r\n    }\r\n    return false;\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool mdir_Exists(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(pathname);\r\n#ifdef _WIN32\r\n    DWORD attrs;\r\n#else\r\n    struct stat sbuf;\r\n#endif\r\n\r\n    assert(pathname);\r\n#ifdef _WIN32\r\n    attrs = GetFileAttributes(pathname);\r\n    return (attrs != 0xFFFFFFFF) && (attrs & FILE_ATTRIBUTE_DIRECTORY);\r\n#else\r\n    if (stat(pathname, &sbuf) == 0)\r\n    {\r\n        if ((sbuf.st_mode & S_IFMT) == S_IFDIR)\r\n            return true;\r\n    }\r\n    return false;\r\n#endif\r\n}\r\n\r\nMZC_INLINE MChar *mpath_GetFullPath(MChar *full, const MChar *relative)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(full);\r\n    assert(relative);\r\n#ifdef _WIN32\r\n    GetFullPathName(relative, MAX_PATH, full, NULL);\r\n    return full;\r\n#else\r\n    return realpath(relative, full);\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool mfile_Delete(const MChar *filename)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(filename);\r\n#ifdef _WIN32\r\n    return !!DeleteFile(filename);\r\n#elif defined(MSDOS)\r\n    return remove(filename) == 0;\r\n#else\r\n    return unlink(filename) == 0;\r\n#endif\r\n}\r\n\r\nMZC_INLINE uint64_t\r\nmfile_GetSize64(const MChar *filename)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(filename);\r\n#ifdef _WIN32\r\n    HANDLE hFile = CreateFile(filename, GENERIC_READ,\r\n        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,\r\n        OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);\r\n    if (hFile == INVALID_HANDLE_VALUE)\r\n        return (uint64_t)-1;\r\n\r\n    DWORD low, high;\r\n    low = GetFileSize(hFile, &high);\r\n    CloseHandle(hFile);\r\n    return low | ((uint64_t)high << 32);\r\n#else\r\n    struct stat st;\r\n    if (stat(filename, &st))\r\n        return (uint64_t)-1;\r\n    return st.st_size;\r\n#endif\r\n}\r\n\r\nMZC_INLINE unsigned long\r\nmfile_GetSize(const MChar *filename, unsigned long *high)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(filename);\r\n\r\n    if (high)\r\n        *high = 0;\r\n\r\n#ifdef _WIN32\r\n    HANDLE hFile = CreateFile(filename, GENERIC_READ,\r\n        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,\r\n        OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);\r\n    if (hFile == INVALID_HANDLE_VALUE)\r\n        return 0xFFFFFFFF;\r\n\r\n    DWORD low = GetFileSize(hFile, high);\r\n    CloseHandle(hFile);\r\n    return low;\r\n#else\r\n    struct stat st;\r\n    if (stat(filename, &st))\r\n        return 0xFFFFFFFF;\r\n\r\n    if (sizeof(st.st_size) >= 8 && st.st_size > 0xFFFFFFFF)\r\n    {\r\n        if (high)\r\n        {\r\n            *high = st.st_size >> 32;\r\n            return (unsigned long)st.st_size;\r\n        }\r\n        return 0xFFFFFFFF;\r\n    }\r\n\r\n    return (unsigned long)st.st_size;\r\n#endif\r\n}\r\n\r\nMZC_INLINE uint8_t *\r\nmfile_GetContents(const MChar *filename, size_t *psize)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    uint8_t *pb = NULL;\r\n\r\n#ifdef _WIN32\r\n    HANDLE hFile;\r\n    DWORD cbFile, cbRead;\r\n\r\n    assert(filename);\r\n\r\n    if (psize)\r\n        *psize = 0;\r\n\r\n    hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL,\r\n        OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);\r\n    if (hFile != INVALID_HANDLE_VALUE)\r\n    {\r\n        cbFile = GetFileSize(hFile, NULL);\r\n        if (cbFile != 0xFFFFFFFF)\r\n        {\r\n            LPVOID pv = malloc((cbFile + 3) * sizeof(char));\r\n            pb = (uint8_t *)(pv);\r\n            if (pb)\r\n            {\r\n                if (ReadFile(hFile, pb, cbFile, &cbRead, NULL) &&\r\n                    cbFile == cbRead)\r\n                {\r\n                    pb[cbFile + 0] = 0;\r\n                    pb[cbFile + 1] = 0;\r\n                    pb[cbFile + 2] = 0;\r\n                    if (psize)\r\n                        *psize = cbFile;\r\n                }\r\n                else\r\n                {\r\n                    free(pb);\r\n                    pb = NULL;\r\n                }\r\n            }\r\n        }\r\n        CloseHandle(hFile);\r\n    }\r\n#else\r\n    FILE *fp;\r\n    struct stat sbuf;\r\n\r\n    assert(filename);\r\n\r\n    if (psize)\r\n        *psize = 0;\r\n\r\n    fp = fopen(filename, "rb");\r\n    if (fp == NULL)\r\n        return NULL;\r\n\r\n    if (stat(filename, &sbuf) == 0)\r\n    {\r\n        pb = (uint8_t *)malloc(sbuf.st_size + 3);\r\n        if (pb)\r\n        {\r\n            if (fread(pb, sbuf.st_size, 1, fp))\r\n            {\r\n                pb[sbuf.st_size + 0] = 0;\r\n                pb[sbuf.st_size + 1] = 0;\r\n                pb[sbuf.st_size + 2] = 0;\r\n                if (psize)\r\n                    *psize = sbuf.st_size;\r\n            }\r\n            else\r\n            {\r\n                free(pb);\r\n                pb = NULL;\r\n            }\r\n        }\r\n    }\r\n    fclose(fp);\r\n#endif\r\n\r\n    return pb;\r\n}\r\n\r\nMZC_INLINE bool mfile_PutText(const MChar *filename, const MChar *str)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return mfile_PutContents(filename, str, _tcslen(str) * sizeof(MChar));\r\n#else\r\n    return mfile_PutContents(filename, str, strlen(str));\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool\r\nmfile_PutContents(const MChar *filename, const void *pvContents, size_t size)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    bool bOK = false;\r\n\r\n#ifdef _WIN32\r\n    HANDLE hFile;\r\n    DWORD cbWritten, dwSize = (DWORD)size;\r\n\r\n    assert(filename);\r\n    assert(pvContents || size == 0);\r\n\r\n    hFile = CreateFile(filename, GENERIC_WRITE, FILE_SHARE_READ, NULL,\r\n        CREATE_ALWAYS, FILE_FLAG_WRITE_THROUGH, NULL);\r\n    if (hFile != INVALID_HANDLE_VALUE)\r\n    {\r\n        if (WriteFile(hFile, pvContents, dwSize, &cbWritten, NULL) &&\r\n            dwSize == cbWritten)\r\n        {\r\n            if (CloseHandle(hFile))\r\n                bOK = true;\r\n        }\r\n        else\r\n        {\r\n            CloseHandle(hFile);\r\n        }\r\n\r\n        if (!bOK)\r\n            DeleteFile(filename);\r\n    }\r\n#else\r\n    FILE *fp;\r\n\r\n    assert(filename);\r\n    assert(pvContents || size == 0);\r\n\r\n    fp = fopen(filename, "wb");\r\n    if (fp)\r\n    {\r\n        if (fwrite(pvContents, size, 1, fp))\r\n        {\r\n            fclose(fp);\r\n            bOK = true;\r\n        }\r\n        else\r\n        {\r\n            fclose(fp);\r\n            mfile_Delete(filename);\r\n        }\r\n    }\r\n#endif\r\n\r\n    return bOK;\r\n}\r\n\r\nMZC_INLINE bool mdir_Create(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return !!CreateDirectory(pathname, NULL);\r\n#elif defined(MSDOS)\r\n    return mkdir(pathname) == 0;\r\n#else\r\n    return mkdir(pathname, 0755) == 0;\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool\r\nmfile_Move(const MChar *existing_file, const MChar *new_file)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(existing_file);\r\n    assert(new_file);\r\n#ifdef _WIN32\r\n    return MoveFile(existing_file, new_file) != FALSE;\r\n#else\r\n    return rename(existing_file, new_file) == 0;\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool\r\nmfile_Copy(const MChar *existing_file, const MChar *new_file,\r\n          bool bFailIfExists)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return CopyFile(existing_file, new_file, bFailIfExists) != FALSE;\r\n#else\r\n    size_t size;\r\n    void *ptr = mfile_GetContents(existing_file, &size);\r\n    return mfile_PutContents(new_file, ptr, size);\r\n#endif\r\n}\r\n\r\nMZC_INLINE MChar *mpath_SetDotExt(MChar *pathname, const MChar *dot_ext)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    assert(pathname);\r\n    assert(dot_ext);\r\n#ifdef _WIN32\r\n    MChar *pch = mpath_FindDotExt(pathname);\r\n    #ifndef NO_STRSAFE\r\n        size_t diff = pch - pathname;\r\n        StringCchCopy(pch, diff, dot_ext);\r\n    #else\r\n        lstrcpy(pch, dot_ext);\r\n    #endif\r\n#else\r\n    strcpy(mpath_FindDotExt(pathname), dot_ext);\r\n#endif\r\n    return pathname;\r\n}\r\n\r\nMZC_INLINE MChar *mpath_AddSep(MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    size_t path_len;\r\n\r\n#ifdef _WIN32\r\n    MChar *prev;\r\n\r\n    assert(pathname);\r\n    path_len = _tcslen(pathname);\r\n    if (path_len == 0)\r\n        return pathname;\r\n\r\n    prev = CharPrev(pathname, pathname + path_len);\r\n    if (*prev != TEXT('\\\\') && *prev != TEXT('/'))\r\n    {\r\n        pathname[path_len++] = TEXT('\\\\');\r\n        pathname[path_len] = 0;\r\n    }\r\n#else\r\n    char *prev;\r\n\r\n    assert(pathname);\r\n    path_len = strlen(pathname);\r\n    if (path_len == 0)\r\n        return pathname;\r\n\r\n    prev = &pathname[path_len - 1];\r\n    if (*prev != '/')\r\n    {\r\n        pathname[path_len++] = '/';\r\n        pathname[path_len] = 0;\r\n    }\r\n#endif\r\n\r\n    return pathname;\r\n}\r\n\r\nMZC_INLINE MChar *mpath_FindDotExt(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    MChar *title, *dot_ext;\r\n    assert(pathname);\r\n    title = mpath_FindTitle(pathname);\r\n#ifdef _WIN32\r\n    dot_ext = _tcsrchr(title, TEXT('.'));\r\n    if (dot_ext)\r\n        return dot_ext;\r\n    return (MChar *)pathname + _tcslen(pathname);\r\n#else\r\n    dot_ext = strrchr(title, '.');\r\n    if (dot_ext)\r\n        return dot_ext;\r\n    return (MChar *)pathname + strlen(pathname);\r\n#endif\r\n}\r\n\r\nMZC_INLINE MChar *mpath_RemoveSep(MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    size_t path_len;\r\n    MChar *prev;\r\n\r\n    assert(pathname);\r\n#ifdef _WIN32\r\n    path_len = _tcslen(pathname);\r\n#else\r\n    path_len = strlen(pathname);\r\n#endif\r\n    if (path_len == 0)\r\n        return pathname;\r\n\r\n#ifdef _WIN32\r\n    #ifdef UNICODE\r\n        prev = pathname + path_len - 1;\r\n        if (*prev == L'\\\\' || *prev == L'/')\r\n            *prev = 0;\r\n    #else\r\n        prev = CharPrev(pathname, pathname + path_len);\r\n        if (*prev == '\\\\' || *prev == '/')\r\n            *prev = 0;\r\n    #endif\r\n#else\r\n    prev = pathname + path_len - 1;\r\n    if (*prev == '/')\r\n        *prev = 0;\r\n#endif\r\n\r\n    return pathname;\r\n}\r\n\r\nMZC_INLINE MChar *mpath_FindTitle(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    const MChar *ret;\r\n    MChar *pch1 = _tcsrchr(pathname, _T('\\\\'));\r\n    MChar *pch2 = _tcsrchr(pathname, _T('/'));\r\n    if (!pch1 && !pch2)\r\n        ret = pathname;\r\n    else if (!pch1)\r\n        ret = pch2 + 1;\r\n    else if (!pch2)\r\n        ret = pch1 + 1;\r\n    else if (pch1 < pch2)\r\n        ret = pch2 + 1;\r\n    else\r\n        ret = pch1 + 1;\r\n    return (MChar *)ret;\r\n#else\r\n    MChar *pch = strrchr(pathname, '/');\r\n    if (!pch)\r\n        return (MChar *)pathname;\r\n    return pch + 1;\r\n#endif\r\n}\r\n\r\nMZC_INLINE MChar *mpath_SetTitle(MChar *pathname, const MChar *title)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    MChar *pch = mpath_FindTitle(pathname);\r\n    #ifndef NO_STRSAFE\r\n        size_t diff = pch - pathname;\r\n        StringCchCopy(pch, diff, title);\r\n    #else\r\n        lstrcpy(pch, title);\r\n    #endif\r\n#else\r\n    strcpy(mpath_FindTitle(pathname), title);\r\n#endif\r\n    return pathname;\r\n}\r\n\r\nMZC_INLINE bool mdir_Remove(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return !!RemoveDirectory(pathname);\r\n#else\r\n    return rmdir(pathname) == 0;\r\n#endif\r\n}\r\n\r\n#ifndef MSDOS\r\n    MZC_INLINE MZC_DIR_P mdir_FindFirstItem(const MChar *pathname, MZC_DIR_INFO *info)\r\n    {\r\n        USING_NAMESPACE_STD;\r\n    #ifdef _WIN32\r\n        MChar spec[MAX_PATH];\r\n        MZC_DIR_P dirp;\r\n\r\n        assert(pathname);\r\n        assert(info);\r\n\r\n        #ifndef NO_STRSAFE\r\n            StringCchCopy(spec, _countof(spec), pathname);\r\n            mpath_AddSep(spec);\r\n            StringCchCat(spec, _countof(spec), TEXT("*"));\r\n        #else\r\n            lstrcpyn(spec, pathname, _countof(spec));\r\n            mpath_AddSep(spec);\r\n            lstrcat(spec, _countof(spec), TEXT("*"));\r\n        #endif\r\n\r\n        dirp = FindFirstFile(spec, info);\r\n        if (dirp == INVALID_HANDLE_VALUE)\r\n            dirp = NULL;\r\n        return dirp;\r\n    #else\r\n        DIR *dirp;\r\n        struct dirent *ent;\r\n\r\n        assert(pathname);\r\n        assert(info);\r\n\r\n        dirp = opendir(pathname);\r\n        if (dirp == NULL)\r\n            return NULL;\r\n\r\n        ent = readdir(dirp);\r\n        if (!ent)\r\n        {\r\n            closedir(dirp);\r\n            return NULL;\r\n        }\r\n\r\n        strcpy(info->cFileName, ent->d_name);\r\n        return dirp;\r\n    #endif\r\n    }\r\n\r\n    MZC_INLINE bool mdir_FindNextItem(MZC_DIR_P dirp, MZC_DIR_INFO *info)\r\n    {\r\n        USING_NAMESPACE_STD;\r\n    #ifdef _WIN32\r\n        assert(dirp);\r\n        assert(info);\r\n\r\n        if (dirp == NULL)\r\n            return false;\r\n\r\n        return FindNextFile(dirp, info) != FALSE;\r\n    #else\r\n        struct dirent *ent;\r\n\r\n        assert(dirp);\r\n        assert(info);\r\n\r\n        if (dirp == NULL)\r\n            return false;\r\n\r\n        ent = readdir(dirp);\r\n        if (ent == NULL)\r\n            return false;\r\n\r\n        strcpy(info->cFileName, ent->d_name);\r\n        return true;\r\n    #endif\r\n    }\r\n\r\n    MZC_INLINE bool mdir_FindClose(MZC_DIR_P dirp)\r\n    {\r\n        USING_NAMESPACE_STD;\r\n        assert(dirp);\r\n\r\n    #ifdef _WIN32\r\n        return !!FindClose(dirp);\r\n    #else\r\n        return closedir(dirp) == 0;\r\n    #endif\r\n    }\r\n\r\n    MZC_INLINE bool mdir_Delete(const MChar *dir)\r\n    {\r\n    #ifdef _WIN32\r\n        TCHAR dir_old[MAX_PATH];\r\n    #else\r\n        char dir_old[MAX_PATH];\r\n    #endif\r\n        MZC_DIR_INFO info;\r\n        MZC_DIR_P dirp;\r\n\r\n        assert(dir);\r\n\r\n        if (!mdir_Exists(dir))\r\n            return false;\r\n\r\n        mdir_Get(dir_old, MAX_PATH);\r\n        if (!mdir_Set(dir))\r\n            return false;\r\n\r\n        dirp = mdir_FindFirstItem(TEXT("."), &info);\r\n        if (dirp)\r\n        {\r\n            do\r\n            {\r\n                if (!mpath_IsDots(info.cFileName))\r\n                {\r\n                    if (mdir_Exists(info.cFileName))\r\n                        mdir_Delete(info.cFileName);\r\n                    else\r\n                        mfile_Delete(info.cFileName);\r\n                }\r\n            } while(mdir_FindNextItem(dirp, &info));\r\n            mdir_FindClose(dirp);\r\n        }\r\n        mdir_Set(dir_old);\r\n\r\n        return mdir_Remove(dir);\r\n    }\r\n\r\n    #ifdef __cplusplus\r\n        inline bool mdir_GetItemList(const MChar *dirname, std::vector<MString>& items,\r\n                                     bool sort)\r\n        {\r\n            if (!mdir_Exists(dirname))\r\n                return false;\r\n\r\n            MZC_DIR_INFO info;\r\n            MZC_DIR_P dir_p = mdir_FindFirstItem(dirname, &info);\r\n            if (dir_p)\r\n            {\r\n                do\r\n                {\r\n                    if (!mpath_IsDots(info.cFileName))\r\n                    {\r\n                        items.push_back(info.cFileName);\r\n                    }\r\n                } while (mdir_FindNextItem(dir_p, &info));\r\n                mdir_FindClose(dir_p);\r\n\r\n                if (sort)\r\n                {\r\n                    std::sort(items.begin(), items.end());\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        inline bool\r\n        mdir_GetFullPathList(const MChar *dirname, std::vector<MString>& paths,\r\n                             bool recursive, bool sort)\r\n        {\r\n            MChar cur_dir[MAX_PATH], full_path[MAX_PATH];\r\n\r\n            mdir_Get(cur_dir);\r\n            if (!mdir_Set(dirname))\r\n                return false;\r\n\r\n            std::vector<MString> items;\r\n            mdir_GetItemList(TEXT("."), items, false);\r\n\r\n            bool ret = true;\r\n            std::vector<MString>::iterator it, end = items.end();\r\n            for (it = items.begin(); it != end; ++it)\r\n            {\r\n                if (recursive)\r\n                {\r\n                    if (mdir_Exists(it->c_str()))\r\n                    {\r\n                        if (!mdir_GetFullPathList(it->c_str(), paths, true, false))\r\n                            ret = false;\r\n                    }\r\n                }\r\n                mpath_GetFullPath(full_path, it->c_str());\r\n                paths.push_back(full_path);\r\n            }\r\n\r\n            mdir_Set(cur_dir);\r\n\r\n            if (sort)\r\n            {\r\n                std::sort(paths.begin(), paths.end());\r\n            }\r\n            return ret;\r\n        }\r\n    #endif  /* __cplusplus */\r\n#endif  /* ndef MSDOS */\r\n\r\nMZC_INLINE bool mdir_Get(MChar *pathname, size_t maxbuf)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return !!GetCurrentDirectory((DWORD)maxbuf, pathname);\r\n#else\r\n    MChar *pch = getcwd(NULL, maxbuf);\r\n    if (pch)\r\n    {\r\n        if (maxbuf)\r\n        {\r\n            strncpy(pathname, pch, maxbuf);\r\n            pathname[maxbuf - 1] = 0;\r\n            free(pch);\r\n            return true;\r\n        }\r\n        free(pch);\r\n    }\r\n    return false;\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool mdir_Set(const MChar *pathname)\r\n{\r\n    USING_NAMESPACE_STD;\r\n#ifdef _WIN32\r\n    return !!SetCurrentDirectory(pathname);\r\n#else\r\n    return chdir(pathname) == 0;\r\n#endif\r\n}\r\n\r\nMZC_INLINE bool mpath_IsDots(const MChar *name)\r\n{\r\n    return name[0] == TEXT('.') && (\r\n        name[1] == 0 || (name[1] == TEXT('.') && name[2] == 0)\r\n    );\r\n}\r\n\r\nMZC_INLINE bool\r\nmdir_CreateRecurse(const MChar *path, bool fForce)\r\n{\r\n    MChar *new_path, *pch, *last_sep;\r\n\r\n    assert(path);\r\n#ifdef _WIN32\r\n    new_path = _tcsdup(path);\r\n#else\r\n    new_path = strdup(path);\r\n#endif\r\n    if (!new_path)\r\n        return false;\r\n\r\n    mpath_RemoveSep(new_path);\r\n\r\n    for (;;)\r\n    {\r\n        if (!mpath_Exists(new_path))\r\n        {\r\n            last_sep = NULL;\r\n#ifdef _WIN32\r\n            for (pch = new_path; *pch; pch = CharNext(pch))\r\n            {\r\n                if (*pch == TEXT('\\\\') || *pch == TEXT('/'))\r\n                    last_sep = pch;\r\n            }\r\n#else\r\n            for (pch = new_path; *pch; ++pch)\r\n            {\r\n                if (*pch == '/')\r\n                    last_sep = pch;\r\n            }\r\n#endif\r\n            if (last_sep)\r\n            {\r\n                *last_sep = 0;\r\n                if (mdir_CreateRecurse(new_path, fForce))\r\n                {\r\n                    free(new_path);\r\n                    return mdir_Create(path);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (mdir_Create(new_path))\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            free(new_path);\r\n            return false;\r\n        }\r\n\r\n        if (!mdir_Exists(new_path))\r\n        {\r\n            if (!fForce)\r\n                return false;\r\n\r\n            if (!mfile_Delete(new_path))\r\n                return false;\r\n\r\n            continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    free(new_path);\r\n    return true;\r\n}\r\n\r\nMZC_INLINE void mpath_BackslashToSlash(MChar *pathname)\r\n{\r\n    MChar *pch = pathname;\r\n#ifdef _WIN32\r\n    while (*pch)\r\n    {\r\n        if (*pch == TEXT('\\\\'))\r\n        {\r\n            *pch = TEXT('/');\r\n        }\r\n        pch = CharNext(pch);\r\n    }\r\n#else\r\n    while (*pch)\r\n    {\r\n        if (*pch == '\\\\')\r\n        {\r\n            *pch = '/';\r\n        }\r\n        ++pch;\r\n    }\r\n#endif\r\n}\r\n\r\nMZC_INLINE void mpath_SlashToBackslash(MChar *pathname)\r\n{\r\n    MChar *pch = pathname;\r\n#ifdef _WIN32\r\n    while (*pch)\r\n    {\r\n        if (*pch == TEXT('/'))\r\n        {\r\n            *pch = TEXT('\\\\');\r\n        }\r\n        pch = CharNext(pch);\r\n    }\r\n#else\r\n    while (*pch)\r\n    {\r\n        if (*pch == '/')\r\n        {\r\n            *pch = '\\\\';\r\n        }\r\n        ++pch;\r\n    }\r\n#endif\r\n}\r\n\r\n/**************************************************************************/\r\n\r\n#endif  /* ndef MZC4_MFILEAPI_H_ */\r\n
MFileDialog.hpp<>MFileDialog.hpp<>// MFileDialog.hpp -- Win32API file dialog wrapper              -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFILEDIALOG_HPP_\r\n#define MZC4_MFILEDIALOG_HPP_       5       /* Version 5 */\r\n\r\nclass MFileDialog;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCommonDialog.hpp"\r\n#include "MFileAPI.h"\r\n\r\nclass MFileDialog : public MCommonDialog\r\n{\r\npublic:\r\n    OPENFILENAME m_ofn;\r\n\r\n    // before main\r\n    // NOTE: pszFilter should be separated by '|'s.\r\n    MFileDialog(HWND hwndOwner, LPCTSTR pszDefExt = NULL,\r\n                LPCTSTR pszFileName = NULL,\r\n                LPCTSTR pszFilter = NULL,\r\n                LPCTSTR pszTitle = NULL,\r\n                DWORD dwOFN_ = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT);\r\n\r\n    // main\r\n    BOOL GetOpenFileName();\r\n    BOOL GetSaveFileName();\r\n\r\n    // after main\r\n    LPCTSTR GetPathName() const;\r\n    LPCTSTR GetFileTitle() const;\r\n    LPCTSTR GetFileExt() const;\r\n    BOOL GetReadOnly() const;\r\n\r\n    // dialog properties\r\n    MString GetFilePath() const;\r\n    MString GetFolderPath() const;\r\n    MString GetSpec() const;\r\n\r\n    // dialog manipulators\r\n    void SetControlText(INT nID, LPCSTR lpsz);\r\n    void HideControl(INT nID);\r\n    void SetDefExt(LPCTSTR pszDefExt);\r\n\r\n    // messaging\r\n    static UINT GetFileOkMessage();\r\n    static UINT GetShareViolationMessage();\r\n    static UINT GetLBSelChangeMessage();\r\n\r\n    // convert '|' to '\\0'\r\n    static void MakeFilter(MString& m_strFilter);\r\n\r\nprotected:\r\n    MString m_strFilter;\r\n    TCHAR m_szFileName[MAX_PATH];\r\n    OFNOTIFY *m_pon;\r\n\r\n    // overridables\r\n    virtual void OnInitDone();\r\n    virtual void OnFileNameChange();\r\n    virtual void OnFolderChange();\r\n    virtual void OnTypeChange();\r\n    virtual UINT OnShareViolation(LPCTSTR lpszPathName);\r\n    virtual BOOL OnFileNameOK();\r\n    virtual void OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode);\r\n\r\n    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);\r\n\r\n    static UINT_PTR APIENTRY\r\n    OFNHookProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    // get file name extension from filter string\r\n    static BOOL FileExtFromFilter(LPTSTR pExt, OPENFILENAME *pOFN);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMFileDialog::MFileDialog(HWND hwndOwner, LPCTSTR pszDefExt/* = NULL*/,\r\n                         LPCTSTR pszFileName/* = NULL*/,\r\n                         LPCTSTR pszFilter/* = NULL*/,\r\n                         LPCTSTR pszTitle/* = NULL*/,\r\n                         DWORD dwOFN_/* = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT*/)\r\n    : MCommonDialog(hwndOwner)\r\n{\r\n    m_bModal = TRUE;\r\n\r\n    if (pszFileName)\r\n    {\r\n        lstrcpyn(m_szFileName, pszFileName, _countof(m_szFileName));\r\n    }\r\n    else\r\n    {\r\n        m_szFileName[0] = 0;\r\n    }\r\n\r\n    if (pszFilter)\r\n    {\r\n        m_strFilter = pszFilter;\r\n        MakeFilter(m_strFilter);\r\n    }\r\n\r\n    ZeroMemory(&m_ofn, sizeof(m_ofn));\r\n    m_ofn.lStructSize = sizeof(m_ofn);\r\n    m_ofn.hwndOwner = hwndOwner;\r\n    m_ofn.lpstrFilter = m_strFilter.c_str();\r\n    m_ofn.lpstrFile = m_szFileName;\r\n    m_ofn.nMaxFile = _countof(m_szFileName);\r\n    m_ofn.Flags = dwOFN_;\r\n    m_ofn.lpfnHook = MFileDialog::OFNHookProc;\r\n    m_ofn.lpstrDefExt = pszDefExt;\r\n    m_ofn.lCustData = (LPARAM)this;\r\n}\r\n\r\ninline BOOL MFileDialog::GetOpenFileName()\r\n{\r\n    m_ofn.Flags |= OFN_EXPLORER | OFN_ENABLESIZING | OFN_ENABLEHOOK;\r\n    return ::GetOpenFileName(&m_ofn);\r\n}\r\n\r\ninline BOOL MFileDialog::GetSaveFileName()\r\n{\r\n    m_ofn.Flags |= OFN_EXPLORER | OFN_ENABLESIZING | OFN_ENABLEHOOK;\r\n    return ::GetSaveFileName(&m_ofn);\r\n}\r\n\r\ninline LPCTSTR MFileDialog::GetPathName() const\r\n{\r\n    return m_ofn.lpstrFile;\r\n}\r\n\r\ninline LPCTSTR MFileDialog::GetFileTitle() const\r\n{\r\n    return &m_ofn.lpstrFile[m_ofn.nFileOffset];\r\n}\r\n\r\ninline LPCTSTR MFileDialog::GetFileExt() const\r\n{\r\n    return &m_ofn.lpstrFile[m_ofn.nFileExtension];\r\n}\r\n\r\ninline MString MFileDialog::GetFilePath() const\r\n{\r\n    MString ret = m_ofn.lpstrFile;\r\n    TCHAR sz[MAX_PATH];\r\n    HWND hwndParent = ::GetParent(m_hwnd);\r\n\r\n    if (::IsWindow(m_hwnd) &&\r\n        ::SendMessage(hwndParent, CDM_GETFILEPATH, (WPARAM)_countof(sz), (LPARAM)sz) >= 0)\r\n    {\r\n        ret = sz;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline MString MFileDialog::GetFolderPath() const\r\n{\r\n    MString ret;\r\n    TCHAR sz[MAX_PATH];\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n\r\n    if (::IsWindow(m_hwnd) &&\r\n        ::SendMessage(hParent, CDM_GETFOLDERPATH, (WPARAM)_countof(sz), (LPARAM)sz) >= 0)\r\n    {\r\n        ret = sz;\r\n    }\r\n    else\r\n    {\r\n        lstrcpyn(sz, m_ofn.lpstrFile, _countof(sz));\r\n        LPTSTR pch = mpath_FindTitle(sz);\r\n        if (pch)\r\n        {\r\n            *pch = 0;\r\n            ret = sz;\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline MString MFileDialog::GetSpec() const\r\n{\r\n    MString ret;\r\n    TCHAR sz[MAX_PATH];\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n\r\n    if (::IsWindow(m_hwnd) &&\r\n        ::SendMessage(hParent, CDM_GETSPEC, (WPARAM)_countof(sz), (LPARAM)sz))\r\n    {\r\n        ret = sz;\r\n    }\r\n    else\r\n    {\r\n        ret = &m_ofn.lpstrFile[m_ofn.nFileOffset];\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline void MFileDialog::SetControlText(INT nID, LPCSTR psz)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n    ::SendMessage(hParent, CDM_SETCONTROLTEXT, nID, (LPARAM)psz);\r\n}\r\n\r\ninline void MFileDialog::HideControl(INT nID)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n    ::SendMessage(hParent, CDM_HIDECONTROL, nID, 0);\r\n}\r\n\r\ninline void MFileDialog::SetDefExt(LPCSTR pszDefExt)\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n    ::SendMessage(hParent, CDM_SETDEFEXT, 0, (LPARAM)pszDefExt);\r\n}\r\n\r\ninline /*static*/ UINT MFileDialog::GetFileOkMessage()\r\n{\r\n    static UINT s_uMsg = ::RegisterWindowMessage(FILEOKSTRING);\r\n    return s_uMsg;\r\n}\r\n\r\ninline /*static*/ UINT MFileDialog::GetShareViolationMessage()\r\n{\r\n    static UINT s_uMsg = ::RegisterWindowMessage(SHAREVISTRING);\r\n    return s_uMsg;\r\n}\r\n\r\ninline /*static*/ UINT MFileDialog::GetLBSelChangeMessage()\r\n{\r\n    static UINT s_uMsg = ::RegisterWindowMessage(LBSELCHSTRING);\r\n    return s_uMsg;\r\n}\r\n\r\ninline BOOL MFileDialog::GetReadOnly() const\r\n{\r\n    return (m_ofn.Flags & OFN_READONLY) != 0;\r\n}\r\n\r\ninline /*static*/ void MFileDialog::MakeFilter(MString& m_strFilter)\r\n{\r\n    m_strFilter += TEXT('|');\r\n\r\n    for (size_t i = 0; i < m_strFilter.size(); ++i)\r\n    {\r\n        if (m_strFilter[i] == TEXT('|'))\r\n            m_strFilter[i] = 0;\r\n    }\r\n}\r\n\r\ninline /*virtual*/ UINT\r\nMFileDialog::OnShareViolation(LPCTSTR lpszPathName)\r\n{\r\n    return OFN_SHAREWARN;\r\n}\r\n\r\ninline /*virtual*/ BOOL MFileDialog::OnFileNameOK()\r\n{\r\n    return FALSE;\r\n}\r\n\r\ninline /*virtual*/ void\r\nMFileDialog::OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode)\r\n{\r\n}\r\n\r\ninline /*virtual*/ void MFileDialog::OnInitDone()\r\n{\r\n    CenterWindowDx(::GetParent(m_hwnd));\r\n}\r\n\r\ninline /*virtual*/ void MFileDialog::OnFileNameChange()\r\n{\r\n}\r\n\r\ninline /*virtual*/ void MFileDialog::OnFolderChange()\r\n{\r\n}\r\n\r\ninline /*static*/ BOOL\r\nMFileDialog::FileExtFromFilter(LPTSTR pExt, OPENFILENAME *pOFN)\r\n{\r\n    if (pOFN->lpstrFilter == NULL)\r\n        return FALSE;   /* not found */\r\n\r\n    LPTSTR pchExt = pExt;\r\n    *pchExt = 0;\r\n\r\n    DWORD nIndex = 1;\r\n    for (LPCTSTR pch = pOFN->lpstrFilter; *pch; ++nIndex)\r\n    {\r\n        pch += lstrlen(pch) + 1;\r\n        if (pOFN->nFilterIndex == nIndex)\r\n        {\r\n            for (++pch; *pch && *pch != _T(';'); ++pch)\r\n            {\r\n                *pchExt++ = *pch;\r\n            }\r\n            *pchExt = 0;\r\n            ::CharLower(pExt);\r\n            return TRUE;    /* found */\r\n        }\r\n        pch += lstrlen(pch) + 1;\r\n    }\r\n    return FALSE;   /* not found */\r\n}\r\n\r\ninline /*virtual*/ void MFileDialog::OnTypeChange()\r\n{\r\n    assert(::IsWindow(m_hwnd));\r\n    assert(m_pon);\r\n\r\n    // We should change the extension\r\n    TCHAR szPath[MAX_PATH];\r\n    HWND hParent = ::GetParent(m_hwnd);\r\n    ::SendMessage(hParent, CDM_GETFILEPATH, _countof(szPath), (LPARAM)szPath);\r\n\r\n    LPTSTR pchTitle = mpath_FindTitle(szPath);\r\n    LPTSTR pch = mpath_FindDotExt(szPath);\r\n    if (pch && pchTitle)\r\n    {\r\n        *pch = 0;\r\n        if (FileExtFromFilter(pch, m_pon->lpOFN))\r\n        {\r\n            ::SendMessage(hParent, CDM_SETCONTROLTEXT, 0x047c, (LPARAM)pchTitle);\r\n            lstrcpyn(m_pon->lpOFN->lpstrFile, szPath, MAX_PATH);\r\n        }\r\n    }\r\n}\r\n\r\ninline LRESULT MFileDialog::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)\r\n{\r\n    OFNOTIFY *pon = (OFNOTIFY *)pnmhdr;\r\n    m_pon = pon;\r\n\r\n    LRESULT ret = 0;\r\n    switch (pon->hdr.code)\r\n    {\r\n    case CDN_INITDONE:\r\n        OnInitDone();\r\n        break;\r\n    case CDN_SELCHANGE:\r\n        OnFileNameChange();\r\n        break;\r\n    case CDN_FOLDERCHANGE:\r\n        OnFolderChange();\r\n        break;\r\n    case CDN_SHAREVIOLATION:\r\n        ret = OnShareViolation(pon->pszFile);\r\n    case CDN_HELP:\r\n        // FIXME:\r\n        break;\r\n    case CDN_FILEOK:\r\n        ret = OnFileNameOK();\r\n    case CDN_TYPECHANGE:\r\n        OnTypeChange();\r\n        break;\r\n    }\r\n    m_pon = NULL;\r\n\r\n    return ret;\r\n}\r\n\r\ninline /*static*/ UINT_PTR APIENTRY\r\nMFileDialog::OFNHookProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    if (hwnd == NULL)\r\n        return 0;\r\n\r\n    MFileDialog *base;\r\n    OPENFILENAME *pofn;\r\n    if (uMsg == WM_INITDIALOG)\r\n    {\r\n        assert(lParam);\r\n        pofn = (OPENFILENAME *)lParam;\r\n        assert(pofn->lCustData);\r\n        base = (MFileDialog *)pofn->lCustData;\r\n        base->Attach(hwnd);\r\n    }\r\n\r\n    UINT_PTR ret = 0;\r\n    base = (MFileDialog *)GetUserData(hwnd);\r\n    if (base)\r\n    {\r\n        if (uMsg == GetFileOkMessage())\r\n        {\r\n            ret = base->OnFileNameOK();\r\n        }\r\n        else if (uMsg == GetShareViolationMessage())\r\n        {\r\n            ret = base->OnShareViolation((LPCTSTR)lParam);\r\n        }\r\n        else if (uMsg == GetLBSelChangeMessage())\r\n        {\r\n            base->OnLBSelChangedNotify((UINT)wParam, LOWORD(lParam), HIWORD(lParam));\r\n        }\r\n        else\r\n        {\r\n            ret = base->DialogProcDx(hwnd, uMsg, wParam, lParam);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\ninline /*virtual*/ INT_PTR CALLBACK\r\nMFileDialog::DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (uMsg)\r\n    {\r\n        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);\r\n    }\r\n    return DefaultProcDx();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFILEDIALOG_HPP_\r\n
MFileLister.hpp<>MFileLister.hpp<>// MFileLister.hpp -- Win32API file lister                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFILELISTER_HPP_\r\n#define MZC4_MFILELISTER_HPP_   3       /* Version 3 */\r\n\r\nclass MFileLister;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MFileAPI.h"\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MFileLister\r\n{\r\npublic:\r\n    HANDLE m_hFind;\r\n    WIN32_FIND_DATA m_find;\r\n    TCHAR m_szRootDir[MAX_PATH];\r\n\r\npublic:\r\n    MFileLister();\r\n    MFileLister(LPCTSTR pszWildCard, BOOL bUseFullPath = FALSE);\r\n    virtual ~MFileLister();\r\n\r\n    bool operator!() const;\r\n    operator HANDLE() const;\r\n    MFileLister& operator=(HANDLE hFind);\r\n    PHANDLE operator&();\r\n\r\n    BOOL Attach(HANDLE hFind);\r\n    HANDLE Detach();\r\n    HANDLE Handle() const;\r\n\r\n    BOOL FindFirstFile(LPCTSTR pszWildCard = TEXT("*"), BOOL bUseFullPath = FALSE);\r\n    BOOL FindNextFile();\r\n    BOOL FindClose();\r\n\r\n    ULONGLONG GetFileSize() const;\r\n\r\n    LPCTSTR GetRootDir() const;\r\n    LPCTSTR GetFileName() const;\r\n    LPCTSTR GetAlternateFileName() const;\r\n    BOOL GetFilePath(LPTSTR pszPath, DWORD cchPath) const;\r\n    template <typename T_STRING>\r\n    BOOL GetFilePath(T_STRING& strPath);\r\n\r\n    BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;\r\n    BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;\r\n    BOOL GetCreationTime(FILETIME* pTimeStamp) const;\r\n    DWORD GetFileAttributes() const;\r\n    BOOL MatchesMask(DWORD dwMask) const;\r\n\r\n    BOOL IsDots() const;    // "." or ".."\r\n    BOOL IsReadOnly() const;\r\n    BOOL IsDirectory() const;\r\n    BOOL IsCompressed() const;\r\n    BOOL IsSystem() const;\r\n    BOOL IsHidden() const;\r\n    BOOL IsTemporary() const;\r\n    BOOL IsNormal() const;\r\n    BOOL IsArchived() const;\r\n\r\nprivate:\r\n    // NOTE: MFileLister is not copyable.\r\n    MFileLister(const MFileLister& find);\r\n    MFileLister& operator=(const MFileLister& find);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MFileLister::MFileLister()\r\n{\r\n    m_hFind = INVALID_HANDLE_VALUE;\r\n    m_szRootDir[0] = TEXT('\\0');\r\n}\r\n\r\ninline /*virtual*/ MFileLister::~MFileLister()\r\n{\r\n}\r\n\r\ninline bool MFileLister::operator!() const\r\n{\r\n    return Handle() == INVALID_HANDLE_VALUE;\r\n}\r\n\r\ninline MFileLister& MFileLister::operator=(HANDLE hFind)\r\n{\r\n    if (Handle() != hFind)\r\n    {\r\n        Attach(hFind);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MFileLister::Attach(HANDLE hFind)\r\n{\r\n    FindClose();\r\n    m_hFind = hFind;\r\n    return m_hFind != INVALID_HANDLE_VALUE;\r\n}\r\n\r\ninline HANDLE MFileLister::Detach()\r\n{\r\n    HANDLE hFind = m_hFind;\r\n    m_hFind = INVALID_HANDLE_VALUE;\r\n    return hFind;\r\n}\r\n\r\ninline HANDLE MFileLister::Handle() const\r\n{\r\n    return (this ? m_hFind : NULL);\r\n}\r\n\r\ninline MFileLister::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline PHANDLE MFileLister::operator&()\r\n{\r\n    return &m_hFind;\r\n}\r\n\r\ninline ULONGLONG MFileLister::GetFileSize() const\r\n{\r\n    return MAKELONGLONG(m_find.nFileSizeLow, m_find.nFileSizeHigh);\r\n}\r\n\r\ninline BOOL MFileLister::GetLastWriteTime(FILETIME* pTimeStamp) const\r\n{\r\n    assert(pTimeStamp);\r\n    *pTimeStamp = m_find.ftLastWriteTime;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileLister::GetLastAccessTime(FILETIME* pTimeStamp) const\r\n{\r\n    assert(pTimeStamp);\r\n    *pTimeStamp = m_find.ftLastAccessTime;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileLister::GetCreationTime(FILETIME* pTimeStamp) const\r\n{\r\n    assert(pTimeStamp);\r\n    *pTimeStamp = m_find.ftCreationTime;\r\n    return TRUE;\r\n}\r\n\r\ninline DWORD MFileLister::GetFileAttributes() const\r\n{\r\n    return m_find.dwFileAttributes;\r\n}\r\n\r\ninline BOOL MFileLister::MatchesMask(DWORD dwMask) const\r\n{\r\n    return (MFileLister::GetFileAttributes() & dwMask) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsReadOnly() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_READONLY) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsDirectory() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsCompressed() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsSystem() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsHidden() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsTemporary() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsNormal() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_NORMAL) != 0;\r\n}\r\n\r\ninline BOOL MFileLister::IsArchived() const\r\n{\r\n    return (m_find.dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE) != 0;\r\n}\r\n\r\ninline LPCTSTR MFileLister::GetRootDir() const\r\n{\r\n    return m_szRootDir;\r\n}\r\n\r\ninline LPCTSTR MFileLister::GetFileName() const\r\n{\r\n    return m_find.cFileName;\r\n}\r\n\r\ninline LPCTSTR MFileLister::GetAlternateFileName() const\r\n{\r\n    return m_find.cAlternateFileName;\r\n}\r\n\r\ninline BOOL MFileLister::FindNextFile()\r\n{\r\n    assert(m_hFind != INVALID_HANDLE_VALUE);\r\n    BOOL bFound = ::FindNextFile(m_hFind, &m_find);\r\n    return bFound;\r\n}\r\n\r\ninline BOOL MFileLister::FindClose()\r\n{\r\n    if (m_hFind != INVALID_HANDLE_VALUE)\r\n    {\r\n        BOOL bOK = ::FindClose(m_hFind);\r\n        m_hFind = INVALID_HANDLE_VALUE;\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ntemplate <typename T_STRING>\r\ninline BOOL MFileLister::GetFilePath(T_STRING& strPath)\r\n{\r\n    TCHAR szPath[MAX_PATH] = TEXT("");\r\n    if (m_szRootDir[0])\r\n    {\r\n        lstrcpy(szPath, m_szRootDir);\r\n        MPath_AddSep(szPath);\r\n    }\r\n    lstrcat(szPath, MFileLister::GetFileName());\r\n    strPath = szPath;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileLister::IsDots() const\r\n{\r\n    if (m_find.cFileName[0] == TEXT('.'))\r\n    {\r\n        if (!m_find.cFileName[1])\r\n            return TRUE;\r\n\r\n        if (m_find.cFileName[1] == TEXT('.') && !m_find.cFileName[2])\r\n            return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline MFileLister::MFileLister(\r\n    LPCTSTR pszWildCard, BOOL bUseFullPath/* = FALSE*/)\r\n{\r\n    m_hFind = INVALID_HANDLE_VALUE;\r\n    m_szRootDir[0] = TEXT('\\0');\r\n\r\n    MFileLister::FindFirstFile(pszWildCard, bUseFullPath);\r\n}\r\n\r\ninline BOOL MFileLister::GetFilePath(LPTSTR pszPath, DWORD cchPath) const\r\n{\r\n    assert(pszPath);\r\n\r\n    TCHAR szPath[MAX_PATH];\r\n    if (m_szRootDir[0])\r\n    {\r\n        lstrcpy(szPath, m_szRootDir);\r\n        MPath_AddSep(szPath);\r\n    }\r\n    else\r\n        szPath[0] = 0;\r\n    lstrcat(szPath, MFileLister::GetFileName());\r\n\r\n    if (pszPath)\r\n    {\r\n        lstrcpyn(pszPath, szPath, cchPath);\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MFileLister::FindFirstFile(\r\n    LPCTSTR pszWildCard/* = TEXT("*")*/, BOOL bUseFullPath/* = FALSE*/)\r\n{\r\n    assert(pszWildCard);\r\n\r\n    TCHAR szPath[MAX_PATH];\r\n    lstrcpyn(szPath, pszWildCard, MAX_PATH);\r\n    LPTSTR pch = MPath_FindTitle(szPath);\r\n\r\n    if (pch != szPath)\r\n    {\r\n        pch--;\r\n        *pch = '\\0';\r\n        if (bUseFullPath)\r\n            ::GetFullPathName(szPath, MAX_PATH, m_szRootDir, NULL);\r\n        else\r\n            lstrcpyn(m_szRootDir, szPath, MAX_PATH);\r\n    }\r\n    else \r\n    {\r\n        if (bUseFullPath)\r\n            ::GetCurrentDirectory(MAX_PATH, m_szRootDir);\r\n        else\r\n            m_szRootDir[0] = 0;\r\n    }\r\n\r\n    m_hFind = ::FindFirstFile(pszWildCard, &m_find);\r\n    return (m_hFind != INVALID_HANDLE_VALUE);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFILELISTER_HPP_\r\n
MFileMapping.hpp<>MFileMapping.hpp<>// MFileMapping.hpp -- Win32API file mapping wrapper            -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFILEMAPPING_HPP_\r\n#define MZC4_MFILEMAPPING_HPP_      25      /* Version 25 */\r\n\r\nclass MMapView;\r\n    template <typename T>\r\n    class MTypedMapView;\r\nclass MFileMapping;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef LOLONG\r\n    #define LOLONG(dwl) static_cast<DWORD>(dwl)\r\n#endif\r\n#ifndef HILONG\r\n    #define HILONG(dwl) static_cast<DWORD>(((dwl) >> 32) & 0xFFFFFFFF)\r\n#endif\r\n#ifndef MAKELONGLONG\r\n    #define MAKELONGLONG(lo,hi) \\\r\n        (static_cast<DWORD>(lo) | \\\r\n            (static_cast<DWORDLONG>(static_cast<DWORD>(hi)) << 32))\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MUnknown.hpp"\r\n\r\nclass MMapView\r\n{\r\npublic:\r\n    class MSharedView;\r\n    MSharedView *m_pView;\r\n\r\n    MMapView();\r\n    MMapView(LPVOID pv, DWORDLONG index, DWORD mod, DWORD size);\r\n    MMapView(const MMapView& view);\r\n    MMapView& operator=(const MMapView& view);\r\n    ~MMapView();\r\n\r\n    LPVOID      Ptr() const;\r\n    DWORD       GetPos(LPDWORD pdwHigh = NULL) const;\r\n    DWORDLONG   GetPos64() const;\r\n    DWORD       GetMod() const;\r\n    DWORD       GetSize() const;\r\n\r\n    operator LPVOID() const;\r\n    bool operator!() const;\r\n\r\n    BOOL FlushViewOfFile(DWORD dwNumberOfBytes = 0);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T>\r\nclass MTypedMapView\r\n{\r\npublic:\r\n    MMapView m_map_view;\r\n\r\n    MTypedMapView();\r\n    MTypedMapView(LPVOID pv, DWORDLONG index, DWORD mod, DWORD size);\r\n    MTypedMapView(const MMapView& map_view);\r\n    MTypedMapView(const MTypedMapView<T>& map_view);\r\n    MTypedMapView<T>& operator=(const MMapView& map_view);\r\n    MTypedMapView<T>& operator=(const MTypedMapView<T>& map_view);\r\n\r\n    T *         Ptr() const;\r\n    DWORD       GetPos(LPDWORD pdwHigh = NULL) const;\r\n    DWORDLONG   GetPos64() const;\r\n    DWORD       GetMod() const;\r\n    DWORD       GetSize() const;\r\n\r\n    operator T*() const;\r\n    bool operator!() const;\r\n    T& operator*() const;\r\n    T *operator->() const;\r\n    T& operator[](size_t index)\r\n    {\r\n        return Ptr()[index];\r\n    }\r\n    const T& operator[](size_t index) const\r\n    {\r\n        return Ptr()[index];\r\n    }\r\n\r\n    BOOL FlushViewOfFile(DWORD dwNumberOfBytes = 0);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MFileMapping\r\n{\r\npublic:\r\n    MFileMapping();\r\n    MFileMapping(HANDLE hMapping);\r\n    MFileMapping(const MFileMapping& mapping);\r\n    MFileMapping& operator=(HANDLE hMapping);\r\n    MFileMapping& operator=(const MFileMapping& mapping);\r\n    ~MFileMapping();\r\n\r\n    HANDLE Handle() const;\r\n    operator HANDLE() const;\r\n    BOOL Attach(HANDLE hMapping);\r\n    HANDLE Detach();\r\n\r\n    BOOL CreateFileMapping(\r\n        HANDLE hFile = INVALID_HANDLE_VALUE,\r\n        LPSECURITY_ATTRIBUTES lpSA = NULL,\r\n        DWORD dwPAGE_ = PAGE_READWRITE,\r\n        DWORD dwSizeHigh = 0, DWORD dwSizeLow = 0,\r\n        LPCTSTR lpName = NULL);\r\n    BOOL CreateFileMapping64(\r\n        HANDLE hFile = INVALID_HANDLE_VALUE,\r\n        LPSECURITY_ATTRIBUTES lpSA = NULL,\r\n        DWORD dwPAGE_ = PAGE_READWRITE,\r\n        DWORDLONG dwlSize = 0, LPCTSTR lpName = NULL);\r\n    BOOL OpenFileMapping(DWORD dwFILE_MAP_ = FILE_MAP_ALL_ACCESS,\r\n                         BOOL bInherit = FALSE,\r\n                         LPCTSTR lpName = NULL);\r\n    BOOL CloseHandle();\r\n\r\n    LPVOID\r\n    MapViewOfFile(DWORD dwFILE_MAP_, DWORD dwOffsetHigh = 0,\r\n                  DWORD dwOffsetLow = 0, DWORD dwNumberOfBytes = 0);\r\n    LPVOID\r\n    MapViewOfFile64(DWORD dwFILE_MAP_, DWORDLONG dwlOffset = 0,\r\n                    DWORD dwNumberOfBytes = 0);\r\n    LPVOID\r\n    MapViewOfFileEx(DWORD dwFILE_MAP_, DWORD dwOffsetHigh = 0,\r\n                    DWORD dwOffsetLow = 0, DWORD dwNumberOfBytes = 0,\r\n                    LPVOID lpBaseAddress = NULL);\r\n    LPVOID\r\n    MapViewOfFileEx64(DWORD dwFILE_MAP_, DWORDLONG dwlOffset = 0,\r\n                      DWORD dwNumberOfBytes = 0, LPVOID lpBaseAddress = NULL);\r\n    BOOL UnmapViewOfFile(LPVOID lpBaseAddress);\r\n\r\n    DWORD     Seek(DWORD dwOffsetHigh, DWORD dwOffsetLow, BOOL bAbsolute = FALSE);\r\n    DWORDLONG Seek64(LONGLONG offset, BOOL bAbsolute = FALSE);\r\n\r\n    BOOL ReadData(LPVOID pvData, DWORD dwDataSize);\r\n    BOOL WriteData(LPCVOID pvData, DWORD dwDataSize);\r\n\r\n    DWORD GetPos(LPDWORD pdwHigh = NULL) const;\r\n    DWORDLONG GetPos64() const;\r\n\r\n    DWORDLONG SetPos(DWORD dwOffsetHigh, DWORD dwOffsetLow)\r\n    {\r\n        m_index = MAKELONGLONG(dwOffsetLow, dwOffsetHigh);\r\n        return m_index;\r\n    }\r\n    DWORDLONG SetPos64(DWORDLONG offset)\r\n    {\r\n        m_index = offset;\r\n        return m_index;\r\n    }\r\n\r\n    MMapView MapViewDx(DWORD dwOffsetHigh = 0, DWORD dwOffsetLow = 0,\r\n                       DWORD dwFILE_MAP_ = FILE_MAP_ALL_ACCESS,\r\n                       DWORD dwNumberOfBytes = 0);\r\n    MMapView MapViewDx64(DWORDLONG dwlOffset = 0,\r\n                         DWORD dwFILE_MAP_ = FILE_MAP_ALL_ACCESS,\r\n                         DWORD dwNumberOfBytes = 0);\r\n\r\n    MMapView GetData(DWORD dwDataSize,\r\n                     DWORD dwFILE_MAP_ = FILE_MAP_ALL_ACCESS);\r\n    template <typename T>\r\n    MTypedMapView<T> GetTypedData(DWORD dwDataSize = sizeof(T) * 1,\r\n                                  DWORD dwFILE_MAP_ = FILE_MAP_ALL_ACCESS)\r\n    {\r\n        MTypedMapView<T> view(MapViewDx64(m_index, dwFILE_MAP_, dwDataSize));\r\n        return view;\r\n    }\r\n\r\n    static HANDLE CloneHandleDx(HANDLE hMapping);\r\n\r\nprotected:\r\n    HANDLE m_hMapping;\r\n    DWORDLONG m_index;\r\n    DWORD m_granularity;\r\n\r\n    static VOID GetGranularity(DWORD& granularity);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MMapView::MSharedView : public MUnknown\r\n{\r\npublic:\r\n    LPVOID      m_pv;\r\n    DWORDLONG   m_index;\r\n    DWORD       m_mod;\r\n    DWORD       m_size;\r\n\r\n    MSharedView(LPVOID pv, DWORDLONG index, DWORD mod, DWORD size)\r\n        : m_pv(pv), m_index(index), m_mod(mod), m_size(size)\r\n    {\r\n    }\r\n\r\n    virtual ~MSharedView()\r\n    {\r\n        ::UnmapViewOfFile(m_pv);\r\n    }\r\n};\r\n\r\ninline MMapView::MMapView() : m_pView(NULL)\r\n{\r\n}\r\n\r\ninline MMapView::MMapView(LPVOID pv, DWORDLONG index, DWORD mod, DWORD size)\r\n    : m_pView(new MSharedView(pv, index, mod, size))\r\n{\r\n}\r\n\r\ninline MMapView::MMapView(const MMapView& view) : m_pView(view.m_pView)\r\n{\r\n    if (m_pView)\r\n        m_pView->AddRef();\r\n}\r\n\r\ninline MMapView&\r\nMMapView::operator=(const MMapView& view)\r\n{\r\n    if (m_pView != view.m_pView)\r\n    {\r\n        if (m_pView)\r\n            m_pView->Release();\r\n        m_pView = view.m_pView;\r\n        if (m_pView)\r\n            m_pView->AddRef();\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MMapView::~MMapView()\r\n{\r\n    if (m_pView)\r\n        m_pView->Release();\r\n}\r\n\r\ninline LPVOID MMapView::Ptr() const\r\n{\r\n    if (this && m_pView)\r\n    {\r\n        return ((LPBYTE)m_pView->m_pv) + m_pView->m_mod;\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline MMapView::operator LPVOID() const\r\n{\r\n    return Ptr();\r\n}\r\n\r\ninline bool MMapView::operator!() const\r\n{\r\n    return Ptr() == NULL;\r\n}\r\n\r\ninline BOOL\r\nMMapView::FlushViewOfFile(DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    assert(m_pView);\r\n    return ::FlushViewOfFile(Ptr(), dwNumberOfBytes);\r\n}\r\n\r\ninline DWORD MMapView::GetPos(LPDWORD pdwHigh/* = NULL*/) const\r\n{\r\n    if (m_pView == NULL)\r\n    {\r\n        if (pdwHigh)\r\n            *pdwHigh = 0;\r\n        return 0;\r\n    }\r\n    if (pdwHigh)\r\n    {\r\n        *pdwHigh = HILONG(m_pView->m_index);\r\n        return LOLONG(m_pView->m_index);\r\n    }\r\n    if (HILONG(m_pView->m_index))\r\n        return 0xFFFFFFFF;\r\n    return LOLONG(m_pView->m_index);\r\n}\r\n\r\ninline DWORDLONG MMapView::GetPos64() const\r\n{\r\n    if (m_pView)\r\n    {\r\n        return m_pView->m_index;\r\n    }\r\n    return 0;\r\n}\r\n\r\ninline DWORD MMapView::GetMod() const\r\n{\r\n    if (m_pView)\r\n    {\r\n        return m_pView->m_mod;\r\n    }\r\n    return 0;\r\n}\r\n\r\ninline DWORD MMapView::GetSize() const\r\n{\r\n    if (m_pView)\r\n    {\r\n        return m_pView->m_size;\r\n    }\r\n    return 0;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ VOID\r\nMFileMapping::GetGranularity(DWORD& granularity)\r\n{\r\n    SYSTEM_INFO info;\r\n    ::GetSystemInfo(&info);\r\n    granularity = info.dwAllocationGranularity;\r\n}\r\n\r\ninline MFileMapping::MFileMapping() : m_hMapping(NULL), m_index(0)\r\n{\r\n    GetGranularity(m_granularity);\r\n}\r\n\r\ninline MFileMapping::MFileMapping(HANDLE hMapping)\r\n    : m_hMapping(hMapping), m_index(0)\r\n{\r\n    GetGranularity(m_granularity);\r\n}\r\n\r\ninline MFileMapping::MFileMapping(const MFileMapping& mapping)\r\n    : m_hMapping(CloneHandleDx(mapping.m_hMapping)), m_index(mapping.m_index),\r\n      m_granularity(mapping.m_granularity)\r\n{\r\n}\r\n\r\ninline MFileMapping::~MFileMapping()\r\n{\r\n    CloseHandle();\r\n}\r\n\r\ninline HANDLE MFileMapping::Handle() const\r\n{\r\n    return (this ? m_hMapping : NULL);\r\n}\r\n\r\ninline MFileMapping::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline BOOL MFileMapping::Attach(HANDLE hMapping)\r\n{\r\n    CloseHandle();\r\n    m_hMapping = hMapping;\r\n    return m_hMapping != NULL;\r\n}\r\n\r\ninline HANDLE MFileMapping::Detach()\r\n{\r\n    HANDLE hMapping = m_hMapping;\r\n    m_hMapping = NULL;\r\n    return hMapping;\r\n}\r\n\r\ninline BOOL MFileMapping::CreateFileMapping(\r\n    HANDLE hFile/* = INVALID_HANDLE_VALUE*/,\r\n    LPSECURITY_ATTRIBUTES lpSA/* = NULL*/,\r\n    DWORD dwPAGE_/* = PAGE_READWRITE*/,\r\n    DWORD dwSizeHigh/* = 0*/, DWORD dwSizeLow/* = 0*/,\r\n    LPCTSTR lpName/* = NULL*/)\r\n{\r\n    HANDLE hMapping = ::CreateFileMapping(hFile, lpSA, dwPAGE_,\r\n                                          dwSizeHigh, dwSizeLow, lpName);\r\n    return Attach(hMapping);\r\n}\r\n\r\ninline BOOL\r\nMFileMapping::CreateFileMapping64(\r\n    HANDLE hFile/* = INVALID_HANDLE_VALUE*/,\r\n    LPSECURITY_ATTRIBUTES lpSA/* = NULL*/,\r\n    DWORD dwPAGE_/* = PAGE_READWRITE*/,\r\n    DWORDLONG dwlSize/* = 0*/, LPCTSTR lpName/* = NULL*/)\r\n{\r\n    return CreateFileMapping(hFile, lpSA, dwPAGE_,\r\n                             HILONG(dwlSize), LOLONG(dwlSize), lpName);\r\n}\r\n\r\ninline BOOL MFileMapping::OpenFileMapping(\r\n    DWORD dwFILE_MAP_/* = FILE_MAP_ALL_ACCESS*/,\r\n    BOOL bInherit/* = FALSE*/, LPCTSTR lpName/* = NULL*/)\r\n{\r\n    HANDLE hMapping = ::OpenFileMapping(dwFILE_MAP_, bInherit, lpName);\r\n    return Attach(hMapping);\r\n}\r\n\r\ninline BOOL MFileMapping::CloseHandle()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::CloseHandle(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline LPVOID\r\nMFileMapping::MapViewOfFile(\r\n    DWORD dwFILE_MAP_, DWORD dwOffsetHigh/* = 0*/, DWORD dwOffsetLow/* = 0*/,\r\n    DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    LPVOID pMap = ::MapViewOfFile(Handle(), dwFILE_MAP_, dwOffsetHigh,\r\n                                  dwOffsetLow, dwNumberOfBytes);\r\n    return pMap;\r\n}\r\n\r\ninline LPVOID \r\nMFileMapping::MapViewOfFileEx(\r\n    DWORD dwFILE_MAP_, DWORD dwOffsetHigh/* = 0*/, DWORD dwOffsetLow/* = 0*/,\r\n    DWORD dwNumberOfBytes/* = 0*/, LPVOID lpBaseAddress/* = NULL*/)\r\n{\r\n    LPVOID pMap = ::MapViewOfFileEx(Handle(), dwFILE_MAP_, dwOffsetHigh,\r\n                                    dwOffsetHigh, dwNumberOfBytes,\r\n                                    lpBaseAddress);\r\n    return pMap;\r\n}\r\n\r\ninline LPVOID\r\nMFileMapping::MapViewOfFileEx64(DWORD dwFILE_MAP_, DWORDLONG dwlOffset/* = 0*/,\r\n    DWORD dwNumberOfBytes/* = 0*/, LPVOID lpBaseAddress/* = NULL*/)\r\n{\r\n    return MapViewOfFileEx(dwFILE_MAP_, HILONG(dwlOffset),\r\n        LOLONG(dwlOffset), dwNumberOfBytes, lpBaseAddress);\r\n}\r\n\r\ninline BOOL MFileMapping::UnmapViewOfFile(LPVOID lpBaseAddress)\r\n{\r\n    return ::UnmapViewOfFile(lpBaseAddress);\r\n}\r\n\r\ninline MMapView\r\nMFileMapping::MapViewDx(\r\n    DWORD dwOffsetHigh/* = 0*/, DWORD dwOffsetLow/* = 0*/,\r\n    DWORD dwFILE_MAP_/* = FILE_MAP_ALL_ACCESS*/, DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    DWORDLONG dwlOffset = MAKELONGLONG(dwOffsetLow, dwOffsetHigh);\r\n    return MapViewDx64(dwlOffset, dwFILE_MAP_, dwNumberOfBytes);\r\n}\r\n\r\ninline MMapView\r\nMFileMapping::MapViewDx64(DWORDLONG dwlOffset/* = 0*/,\r\n                          DWORD dwFILE_MAP_/* = FILE_MAP_ALL_ACCESS*/,\r\n                          DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    DWORD mod = DWORD(dwlOffset % m_granularity);\r\n    DWORDLONG dwlFixedOffset = dwlOffset;\r\n    dwlFixedOffset -= mod;\r\n\r\n    LPVOID pv = MapViewOfFile64(dwFILE_MAP_, dwlFixedOffset, dwNumberOfBytes + mod);\r\n    MMapView view(pv, dwlOffset, mod, dwNumberOfBytes);\r\n    return view;\r\n}\r\n\r\ninline /*static*/ HANDLE MFileMapping::CloneHandleDx(HANDLE hMapping)\r\n{\r\n    if (hMapping == NULL)\r\n        return NULL;\r\n\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    HANDLE hDup = NULL;\r\n    ::DuplicateHandle(hProcess, hMapping, hProcess, &hDup, 0,\r\n                      FALSE, DUPLICATE_SAME_ACCESS);\r\n    return hDup;\r\n}\r\n\r\ninline MFileMapping& MFileMapping::operator=(HANDLE hMapping)\r\n{\r\n    if (Handle() != hMapping)\r\n    {\r\n        Attach(hMapping);\r\n    }\r\n    m_index = 0;\r\n    GetGranularity(m_granularity);\r\n    return *this;\r\n}\r\n\r\ninline MFileMapping& MFileMapping::operator=(const MFileMapping& mapping)\r\n{\r\n    if (Handle() != mapping.m_hMapping)\r\n    {\r\n        HANDLE hMapping = CloneHandleDx(mapping);\r\n        Attach(hMapping);\r\n    }\r\n    m_index = mapping.m_index;\r\n    m_granularity = mapping.m_granularity;\r\n    return *this;\r\n}\r\n\r\ninline LPVOID\r\nMFileMapping::MapViewOfFile64(DWORD dwFILE_MAP_, DWORDLONG dwlOffset/* = 0*/,\r\n                              DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    return MapViewOfFile(dwFILE_MAP_, HILONG(dwlOffset), LOLONG(dwlOffset),\r\n                         dwNumberOfBytes);\r\n}\r\n\r\ninline DWORD\r\nMFileMapping::Seek(DWORD dwOffsetHigh, DWORD dwOffsetLow,\r\n                   BOOL bAbsolute/* = FALSE*/)\r\n{\r\n    return (DWORD)Seek64(MAKELONGLONG(dwOffsetLow, dwOffsetHigh), bAbsolute);\r\n}\r\n\r\ninline DWORDLONG\r\nMFileMapping::Seek64(LONGLONG offset, BOOL bAbsolute/* = FALSE*/)\r\n{\r\n    if (bAbsolute)\r\n    {\r\n        m_index = offset;\r\n    }\r\n    else\r\n    {\r\n        m_index += offset;\r\n    }\r\n    return m_index;\r\n}\r\n\r\ninline MMapView\r\nMFileMapping::GetData(DWORD dwDataSize,\r\n                      DWORD dwFILE_MAP_/* = FILE_MAP_ALL_ACCESS*/)\r\n{\r\n    return MapViewDx64(m_index, dwFILE_MAP_, dwDataSize);\r\n}\r\n\r\ninline BOOL MFileMapping::ReadData(LPVOID pvData, DWORD dwDataSize)\r\n{\r\n    MMapView view = GetData(dwDataSize, FILE_MAP_READ);\r\n    if (!view)\r\n        return FALSE;\r\n    CopyMemory(pvData, view, dwDataSize);\r\n    m_index += dwDataSize;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileMapping::WriteData(LPCVOID pvData, DWORD dwDataSize)\r\n{\r\n    MMapView view = GetData(dwDataSize, FILE_MAP_WRITE);\r\n    if (!view)\r\n        return FALSE;\r\n    CopyMemory(view, pvData, dwDataSize);\r\n    m_index += dwDataSize;\r\n    return TRUE;\r\n}\r\n\r\ninline DWORD MFileMapping::GetPos(LPDWORD pdwHigh) const\r\n{\r\n    DWORDLONG index = m_index;\r\n    if (pdwHigh)\r\n    {\r\n        *pdwHigh = HILONG(index);\r\n        return LOLONG(index);\r\n    }\r\n    else if (index > 0xFFFFFFFF)\r\n    {\r\n        return 0xFFFFFFFF;\r\n    }\r\n    else\r\n    {\r\n        return (DWORD)index;\r\n    }\r\n}\r\n\r\ninline DWORDLONG MFileMapping::GetPos64() const\r\n{\r\n    return m_index;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>::MTypedMapView()\r\n{\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>::MTypedMapView(LPVOID pv, DWORDLONG index,\r\n                                       DWORD mod, DWORD size)\r\n    : m_map_view(pv, index, mod, size)\r\n{\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>::MTypedMapView(const MMapView& map_view)\r\n    : m_map_view(map_view)\r\n{\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>::MTypedMapView(const MTypedMapView<T>& map_view)\r\n    : m_map_view(map_view.m_map_view)\r\n{\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>& MTypedMapView<T>::operator=(const MMapView& map_view)\r\n{\r\n    m_map_view = map_view;\r\n    return *this;\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>&\r\nMTypedMapView<T>::operator=(const MTypedMapView<T>& map_view)\r\n{\r\n    m_map_view = map_view.m_map_view;\r\n    return *this;\r\n}\r\n\r\ntemplate <typename T>\r\ninline MTypedMapView<T>::operator T*() const\r\n{\r\n    return Ptr();\r\n}\r\n\r\ntemplate <typename T>\r\ninline T *MTypedMapView<T>::Ptr() const\r\n{\r\n    return reinterpret_cast<T *>(m_map_view.Ptr());\r\n}\r\n\r\ntemplate <typename T>\r\ninline bool MTypedMapView<T>::operator!() const\r\n{\r\n    return !m_map_view;\r\n}\r\n\r\ntemplate <typename T>\r\ninline BOOL MTypedMapView<T>::FlushViewOfFile(DWORD dwNumberOfBytes/* = 0*/)\r\n{\r\n    return m_map_view.FlushViewOfFile(dwNumberOfBytes);\r\n}\r\n\r\ntemplate <typename T>\r\ninline T *MTypedMapView<T>::operator->() const\r\n{\r\n    return Ptr();\r\n}\r\n\r\ntemplate <typename T>\r\ninline T& MTypedMapView<T>::operator*() const\r\n{\r\n    return *Ptr();\r\n}\r\n\r\ntemplate <typename T>\r\ninline DWORD MTypedMapView<T>::GetPos(LPDWORD pdwHigh/* = NULL*/) const\r\n{\r\n    return m_map_view.GetPos(pdwHigh);\r\n}\r\n\r\ntemplate <typename T>\r\ninline DWORDLONG MTypedMapView<T>::GetPos64() const\r\n{\r\n    return m_map_view.GetPos64();\r\n}\r\n\r\ntemplate <typename T>\r\ninline DWORD MTypedMapView<T>::GetMod() const\r\n{\r\n    return m_map_view.GetMod();\r\n}\r\n\r\ntemplate <typename T>\r\ninline DWORD MTypedMapView<T>::GetSize() const\r\n{\r\n    return m_map_view.GetSize();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFILEMAPPING_HPP_\r\n
MFileVersionInfo.hpp<>MFileVersionInfo.hpp<>// MFileVersionInfo.hpp -- EXE file version info getter         -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFILEVERSIONINFO_HPP_\r\n#define MZC4_MFILEVERSIONINFO_HPP_      3   /* Version 3 */\r\n\r\nstruct MLangAndCodePage;\r\nclass MFileVersionInfo;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n#include "MString.hpp"\r\n\r\n#pragma comment(lib, "version.lib")\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MLangAndCodePage\r\n\r\n#include <pshpack1.h>\r\nstruct MLangAndCodePage\r\n{\r\n    WORD wLanguage;\r\n    WORD wCodePage;\r\n};\r\n#include <poppack.h>\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MFileVersionInfo\r\n{\r\npublic:\r\n    MFileVersionInfo();\r\n    MFileVersionInfo(LPCTSTR pszFileName);\r\n    virtual ~MFileVersionInfo();\r\n\r\n    bool operator!() const;\r\n\r\n    BOOL Open(LPCTSTR pszFileName);\r\n    BOOL QueryTranslation();\r\n    VOID Close();\r\n\r\n    BOOL GetValue(LPCTSTR pszBlockName, MString& strValue) const;\r\n    BOOL GetFixedFileInfo(VS_FIXEDFILEINFO& info) const;\r\n\r\n    BOOL GetComments(MString& strValue) const;\r\n    BOOL GetCompanyName(MString& strValue) const;\r\n    BOOL GetFileDescription(MString& strValue) const;\r\n    BOOL GetFileVersion(MString& strValue) const;\r\n    BOOL GetInternalName(MString& strValue) const;\r\n    BOOL GetLegalCopyright(MString& strValue) const;\r\n    BOOL GetLegalTrademarks(MString& strValue) const;\r\n    BOOL GetOriginalFilename(MString& strValue) const;\r\n    BOOL GetPrivateBuild(MString& strValue) const;\r\n    BOOL GetProductName(MString& strValue) const;\r\n    BOOL GetProductVersion(MString& strValue) const;\r\n    BOOL GetSpecialBuild(MString& strValue) const;\r\n\r\n    const BYTE *GetData() const;\r\n    INT GetTranslationIndex() const;\r\n    INT GetNumberOfTranslations() const;\r\n    const MLangAndCodePage *GetTranslations() const;\r\n\r\nprotected:\r\n    BYTE *               m_pbData;\r\n    MLangAndCodePage *   m_pTranslations;\r\n    INT                  m_iTranslation;\r\n    INT                  m_cTranslation;\r\n\r\nprivate:\r\n    // NOTE: MFileVersionInfo is not copyable.\r\n    MFileVersionInfo(const MFileVersionInfo& info);\r\n    MFileVersionInfo& operator=(const MFileVersionInfo& info);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MFileVersionInfo::MFileVersionInfo() :\r\n    m_pbData(NULL), m_pTranslations(NULL), m_iTranslation(-1),\r\n    m_cTranslation(0)\r\n{\r\n}\r\n\r\ninline MFileVersionInfo::MFileVersionInfo(LPCTSTR pszFileName) :\r\n    m_pbData(NULL), m_pTranslations(NULL), m_iTranslation(-1),\r\n    m_cTranslation(0)\r\n{\r\n    Open(pszFileName);\r\n}\r\n\r\ninline /*virtual*/ MFileVersionInfo::~MFileVersionInfo()\r\n{\r\n    if (m_pbData)\r\n        Close();\r\n}\r\n\r\ninline bool MFileVersionInfo::operator!() const\r\n{\r\n    return m_pbData == NULL;\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetComments(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("Comments"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetCompanyName(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("CompanyName"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetFileDescription(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("FileDescription"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetFileVersion(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("FileVersion"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetInternalName(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("InternalName"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetLegalCopyright(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("LegalCopyright"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetLegalTrademarks(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("LegalTrademarks"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetOriginalFilename(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("OriginalFilename"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetPrivateBuild(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("PrivateBuild"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetProductName(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("ProductName"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetProductVersion(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("ProductVersion"), strValue);\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetSpecialBuild(MString& strValue) const\r\n{\r\n    return GetValue(TEXT("SpecialBuild"), strValue);\r\n}\r\n\r\ninline const BYTE *MFileVersionInfo::GetData() const\r\n{\r\n    return m_pbData;\r\n}\r\n\r\ninline INT MFileVersionInfo::GetTranslationIndex() const\r\n{\r\n    return m_iTranslation;\r\n}\r\n\r\ninline INT MFileVersionInfo::GetNumberOfTranslations() const\r\n{\r\n    return m_cTranslation;\r\n}\r\n\r\ninline const MLangAndCodePage *MFileVersionInfo::GetTranslations() const\r\n{\r\n    return m_pTranslations;\r\n}\r\n\r\ninline VOID MFileVersionInfo::Close()\r\n{\r\n    if (m_pbData)\r\n    {\r\n        delete[] m_pbData;\r\n        m_pbData = NULL;\r\n    }\r\n}\r\n\r\ninline BOOL MFileVersionInfo::Open(LPCTSTR pszFileName)\r\n{\r\n    LPTSTR pszFile = const_cast<LPTSTR>(pszFileName);\r\n    DWORD cb = ::GetFileVersionInfoSize(pszFile, NULL);\r\n    if (cb == 0)\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    delete[] m_pbData;\r\n    m_pbData = new BYTE[cb];\r\n    assert(m_pbData);\r\n    if (!::GetFileVersionInfo(pszFile, 0, cb, m_pbData))\r\n    {\r\n        assert(FALSE);\r\n        delete[] m_pbData;\r\n        m_pbData = NULL;\r\n        return FALSE;\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileVersionInfo::QueryTranslation()\r\n{\r\n    if (m_pbData == NULL)\r\n        return FALSE;\r\n\r\n    LPVOID lpBuffer;\r\n    UINT cbBuffer;\r\n    if (!::VerQueryValue(m_pbData, TEXT("\\\\VarFileInfo\\\\Translation"),\r\n                         &lpBuffer, &cbBuffer))\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    LCID lcid = ::GetThreadLocale();\r\n    WORD wLangID = LANGIDFROMLCID(lcid);\r\n\r\n    MLangAndCodePage *pLangAndCodePage =\r\n        reinterpret_cast<MLangAndCodePage *>(lpBuffer);\r\n\r\n    INT i, c = static_cast<INT>(cbBuffer / sizeof(MLangAndCodePage));\r\n    for (i = 0; i < c; i++)\r\n    {\r\n        if (pLangAndCodePage[i].wLanguage == wLangID)\r\n            break;\r\n    }\r\n\r\n    if (i == c)\r\n    {\r\n        for (i = 0; i < c; i++)\r\n        {\r\n            if (PRIMARYLANGID(pLangAndCodePage[i].wLanguage) == LANG_ENGLISH)\r\n                break;\r\n        }\r\n        if (i == c)\r\n            i = -1;\r\n    }\r\n\r\n    m_pTranslations = pLangAndCodePage;\r\n    m_iTranslation = i;\r\n    m_cTranslation = c;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetValue(LPCTSTR pszBlockName, MString& strValue) const\r\n{\r\n    LPVOID pData;\r\n    UINT cb;\r\n    TCHAR szPath[MAX_PATH];\r\n    static const TCHAR szFormat[] = TEXT("\\\\StringFileInfo\\\\%04x%04x\\\\%s");\r\n\r\n    if (m_pbData == NULL || m_pTranslations == NULL)\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    if (m_iTranslation != -1 && m_cTranslation > 0)\r\n    {\r\n        INT i = m_iTranslation;\r\n        ::wsprintf(szPath, szFormat,\r\n            m_pTranslations[i].wLanguage, m_pTranslations[i].wCodePage,\r\n            pszBlockName);\r\n        if (::VerQueryValue(m_pbData, szPath, &pData, &cb))\r\n        {\r\n            strValue = reinterpret_cast<LPCTSTR>(pData);\r\n            return TRUE;\r\n        }\r\n    }\r\n\r\n    for (INT i = 0; i < m_cTranslation; i++)\r\n    {\r\n        ::wsprintf(szPath, szFormat,\r\n            m_pTranslations[i].wLanguage, m_pTranslations[i].wCodePage,\r\n            pszBlockName);\r\n\r\n        if (::VerQueryValue(m_pbData, szPath, &pData, &cb))\r\n        {\r\n            strValue = reinterpret_cast<LPCTSTR>(pData);\r\n            return TRUE;\r\n        }\r\n    }\r\n\r\n    assert(FALSE);\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MFileVersionInfo::GetFixedFileInfo(VS_FIXEDFILEINFO& info) const\r\n{\r\n    if (m_pbData == NULL)\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    LPVOID lpBuffer;\r\n    UINT cbBuffer;\r\n    if (!::VerQueryValue(m_pbData, TEXT("\\\\"), &lpBuffer, &cbBuffer))\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    assert(cbBuffer >= sizeof(VS_FIXEDFILEINFO));\r\n    memcpy(&info, lpBuffer, sizeof(VS_FIXEDFILEINFO));\r\n    return TRUE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFILEVERSIONINFO_HPP_\r\n
MFindReplaceDialog.hpp<>MFindReplaceDialog.hpp<>// MFindReplaceDialog.hpp -- Win32API find/replace dialog       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFINDREPLACEDIALOG_HPP_\r\n#define MZC4_MFINDREPLACEDIALOG_HPP_    3       /* Version 3 */\r\n\r\nclass MFindReplaceDialog;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCommonDialog.hpp"\r\n\r\nstruct FINDREPLACEDX : FINDREPLACE\r\n{\r\n    DWORD dwMagic;\r\n    MFindReplaceDialog *pDialog;\r\n};\r\n\r\nclass MFindReplaceDialog : public MCommonDialog\r\n{\r\npublic:\r\n    FINDREPLACEDX m_fr;\r\n\r\n    MFindReplaceDialog();\r\n    BOOL FindText(HWND hwndOwner, LPCTSTR pszFindWhat = NULL, DWORD dwFR_ = FR_DOWN);\r\n    BOOL ReplaceText(HWND hwndOwner, LPCTSTR pszFindWhat = NULL,\r\n                     LPCTSTR pszReplaceWith = NULL, DWORD dwFR_ = FR_DOWN);\r\n    BOOL FindNext() const;\r\n    MString GetFindString() const;\r\n    MString GetReplaceString() const;\r\n    BOOL IsTerminating() const;\r\n    BOOL MatchCase() const;\r\n    BOOL MatchWholeWord() const;\r\n    BOOL ReplaceAll() const;\r\n    BOOL ReplaceCurrent() const;\r\n    BOOL SearchDown() const;\r\n\r\n    static MFindReplaceDialog *GetNotifier(LPARAM lParam);\r\n    static UINT GetFindReplaceMessageDx();\r\n\r\nprotected:\r\n    TCHAR m_szFindWhat[128];\r\n    TCHAR m_szReplaceWith[128];\r\n\r\n    VOID SetFindWhat(LPCTSTR pszFindWhat);\r\n    VOID SetReplaceWidth(LPCTSTR pszReplaceWith);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMFindReplaceDialog::MFindReplaceDialog()\r\n{\r\n    ZeroMemory(&m_fr, sizeof(m_fr));\r\n    m_fr.lStructSize = sizeof(m_fr);\r\n    m_fr.hwndOwner = NULL;\r\n    m_fr.hInstance = ::GetModuleHandle(NULL);\r\n\r\n    m_szFindWhat[0] = 0;\r\n    m_fr.lpstrFindWhat = m_szFindWhat;\r\n    m_fr.wFindWhatLen = _countof(m_szFindWhat);\r\n\r\n    m_szReplaceWith[0] = 0;\r\n    m_fr.lpstrReplaceWith = m_szReplaceWith;\r\n    m_fr.wReplaceWithLen = _countof(m_szReplaceWith);\r\n\r\n    m_fr.dwMagic = 0xDEADFACE;\r\n    m_fr.pDialog = this;\r\n}\r\n\r\ninline VOID MFindReplaceDialog::SetFindWhat(LPCTSTR pszFindWhat)\r\n{\r\n    if (pszFindWhat)\r\n    {\r\n        ::lstrcpyn(m_szFindWhat, pszFindWhat, _countof(m_szFindWhat));\r\n    }\r\n    else\r\n    {\r\n        m_szFindWhat[0] = 0;\r\n    }\r\n    m_fr.lpstrFindWhat = m_szFindWhat;\r\n}\r\n\r\ninline VOID MFindReplaceDialog::SetReplaceWidth(LPCTSTR pszReplaceWith)\r\n{\r\n    if (pszReplaceWith)\r\n    {\r\n        ::lstrcpyn(m_szReplaceWith, pszReplaceWith, _countof(m_szReplaceWith));\r\n    }\r\n    else\r\n    {\r\n        m_szReplaceWith[0] = 0;\r\n    }\r\n    m_fr.lpstrReplaceWith = m_szReplaceWith;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::FindText(HWND hwndOwner, LPCTSTR pszFindWhat/* = NULL*/,\r\n                             DWORD dwFR_/* = FR_DOWN*/)\r\n{\r\n    m_fr.Flags = dwFR_;\r\n    m_fr.Flags &= ~(FR_REPLACE | FR_REPLACEALL);\r\n\r\n    SetFindWhat(pszFindWhat);\r\n    m_fr.hwndOwner = hwndOwner;\r\n\r\n    return Attach(::FindText(&m_fr));\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::ReplaceText(HWND hwndOwner,\r\n                                LPCTSTR pszFindWhat/* = NULL*/,\r\n                                LPCTSTR pszReplaceWith/* = NULL*/,\r\n                                DWORD dwFR_/* = FR_DOWN*/)\r\n{\r\n    m_fr.Flags = dwFR_;\r\n    m_fr.Flags |= FR_REPLACE;\r\n\r\n    SetFindWhat(pszFindWhat);\r\n    SetReplaceWidth(pszReplaceWith);\r\n    m_fr.hwndOwner = hwndOwner;\r\n\r\n    return Attach(::ReplaceText(&m_fr));\r\n}\r\n\r\ninline BOOL MFindReplaceDialog::FindNext() const\r\n{\r\n    return (m_fr.Flags & FR_FINDNEXT) != 0;\r\n}\r\n\r\ninline MString\r\nMFindReplaceDialog::GetFindString() const\r\n{\r\n    MString ret;\r\n    if (m_fr.lpstrFindWhat)\r\n        ret = m_fr.lpstrFindWhat;\r\n    return ret;\r\n}\r\n\r\ninline MString\r\nMFindReplaceDialog::GetReplaceString() const\r\n{\r\n    MString ret;\r\n    if (m_fr.lpstrReplaceWith)\r\n        ret = m_fr.lpstrReplaceWith;\r\n    return ret;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::IsTerminating() const\r\n{\r\n    return (m_fr.Flags & FR_DIALOGTERM) != 0;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::MatchCase() const\r\n{\r\n    return (m_fr.Flags & FR_MATCHCASE) != 0;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::MatchWholeWord() const\r\n{\r\n    return (m_fr.Flags & FR_WHOLEWORD) != 0;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::ReplaceAll() const\r\n{\r\n    return (m_fr.Flags & FR_REPLACEALL) != 0;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::ReplaceCurrent() const\r\n{\r\n    return (m_fr.Flags & FR_REPLACE) != 0;\r\n}\r\n\r\ninline BOOL\r\nMFindReplaceDialog::SearchDown() const\r\n{\r\n    return (m_fr.Flags & FR_DOWN) != 0;\r\n}\r\n\r\ninline /*static*/ UINT\r\nMFindReplaceDialog::GetFindReplaceMessageDx()\r\n{\r\n    static UINT s_uMsg = ::RegisterWindowMessage(FINDMSGSTRING);\r\n    return s_uMsg;\r\n}\r\n\r\ninline /*static*/ MFindReplaceDialog *\r\nMFindReplaceDialog::GetNotifier(LPARAM lParam)\r\n{\r\n    FINDREPLACEDX *fr = reinterpret_cast<FINDREPLACEDX *>(lParam);\r\n    if (fr->dwMagic == 0xDEADFACE)\r\n        return fr->pDialog;\r\n    return NULL;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFINDREPLACEDIALOG_HPP_\r\n
MFolderDialog.hpp<>MFolderDialog.hpp<>// MFolderDialog.hpp -- MZC4 folder dialog                      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFOLDERDIALOG_HPP_\r\n#define MZC4_MFOLDERDIALOG_HPP_     3       /* Version 3 */\r\n\r\nclass MFolderDialog;\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MDialogBase.hpp"\r\n#include "MTextToText.hpp"\r\n\r\n#ifndef _SHLOBJ_H_\r\n    #include <shlobj.h>\r\n#endif\r\n\r\nclass MFolderDialog : public MDialogBase\r\n{\r\npublic:\r\n    LPCITEMIDLIST   m_pidlInitialSelection;\r\n    LPITEMIDLIST    m_pidlSelected;\r\n    BOOL            m_bExpand;\r\n    BROWSEINFO      m_bi;\r\n    TCHAR           m_szInitialDir[MAX_PATH];\r\n    TCHAR           m_szFolderPath[MAX_PATH];\r\n    TCHAR           m_szFolderDisplayName[MAX_PATH];\r\n\r\npublic:\r\n    MFolderDialog(HWND hwndOwner = NULL, LPCTSTR pszTitle = NULL,\r\n                  UINT uBIF_flags = BIF_RETURNONLYFSDIRS);\r\n    virtual ~MFolderDialog();\r\n\r\n    /* before main */\r\n    VOID SetInitial(LPCTSTR pszInitialFolder, BOOL bExpand = TRUE);\r\n    VOID SetInitial(LPCITEMIDLIST pidl, BOOL bExpand = TRUE);\r\n\r\n    /* main */\r\n    BOOL SHBrowseForFolder();\r\n\r\n    /* after main */\r\n    LPITEMIDLIST GetSelectedItem(BOOL bDetach = FALSE);\r\n    LPCTSTR GetFolderPath() const;\r\n    LPCTSTR GetFolderDisplayName() const;\r\n    INT GetFolderImageIndex() const;\r\n\r\n    /* overridables */\r\n    virtual VOID OnInitialized();\r\n    virtual VOID OnSelChanged(LPITEMIDLIST pidl);\r\n    virtual INT  OnValidateFailed(LPCTSTR pszFolderPath);\r\n    virtual VOID OnIUnknown(IUnknown* pUnknown);\r\n\r\nprotected:\r\n    /* manipulation in callback */\r\n    VOID EnableOK(BOOL bEnable);\r\n    VOID SetSelection(LPCITEMIDLIST pidl);\r\n    VOID SetSelection(LPCTSTR pszFolderPath);\r\n    VOID SetStatusText(LPCTSTR pszText);\r\n    VOID SetOKText(LPCTSTR pszOKText);\r\n    VOID SetExpanded(LPCITEMIDLIST pidl);\r\n    VOID SetExpanded(LPCTSTR pszFolderPath);\r\n\r\n    static INT CALLBACK BrowseCallbackProc(\r\n        HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData);\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMFolderDialog::MFolderDialog(\r\n    HWND hwndOwner/* = NULL*/,\r\n    LPCTSTR pszTitle/* = NULL*/,\r\n    UINT uBIF_flags/* = BIF_RETURNONLYFSDIRS*/)\r\n    : MDialogBase(hwndOwner), m_pidlInitialSelection(NULL),\r\n      m_pidlSelected(NULL), m_bExpand(FALSE)\r\n{\r\n    m_bModal = TRUE;\r\n\r\n    ZeroMemory(&m_bi, sizeof(m_bi));\r\n    m_bi.hwndOwner = hwndOwner;\r\n    m_bi.pidlRoot = NULL;\r\n    m_bi.pszDisplayName = m_szFolderDisplayName;\r\n    m_bi.lpszTitle = pszTitle;\r\n    m_bi.ulFlags = uBIF_flags;\r\n    m_bi.lpfn = MFolderDialog::BrowseCallbackProc;\r\n    m_bi.lParam = reinterpret_cast<LPARAM>(this);\r\n\r\n    m_szInitialDir[0] = 0;\r\n    m_szFolderPath[0] = 0;\r\n    m_szFolderDisplayName[0] = 0;\r\n}\r\n\r\ninline /*virtual*/ MFolderDialog::~MFolderDialog()\r\n{\r\n    ::CoTaskMemFree(m_pidlSelected);\r\n}\r\n\r\ninline VOID\r\nMFolderDialog::SetInitial(LPCTSTR pszInitialFolder, BOOL bExpand/* = TRUE*/)\r\n{\r\n    ::lstrcpyn(m_szInitialDir, pszInitialFolder, MAX_PATH);\r\n    m_bExpand = bExpand;\r\n}\r\n\r\ninline VOID\r\nMFolderDialog::SetInitial(LPCITEMIDLIST pidl, BOOL bExpand/* = TRUE*/)\r\n{\r\n    m_pidlInitialSelection = pidl;\r\n    m_bExpand = bExpand;\r\n}\r\n\r\ninline BOOL MFolderDialog::SHBrowseForFolder()\r\n{\r\n    m_szFolderPath[0] = 0;\r\n    m_szFolderDisplayName[0] = 0;\r\n    ::CoTaskMemFree(m_pidlSelected);\r\n\r\n    m_pidlSelected = ::SHBrowseForFolder(&m_bi);\r\n    if (m_pidlSelected)\r\n    {\r\n        if (!::SHGetPathFromIDList(m_pidlSelected, m_szFolderPath))\r\n            m_szFolderPath[0] = 0;\r\n    }\r\n    Detach();\r\n    return m_pidlSelected != NULL;\r\n}\r\n\r\ninline LPITEMIDLIST\r\nMFolderDialog::GetSelectedItem(BOOL bDetach/* = FALSE*/)\r\n{\r\n    LPITEMIDLIST pidl = m_pidlSelected;\r\n    if (bDetach)\r\n        m_pidlSelected = NULL;\r\n    return pidl;\r\n}\r\n\r\ninline LPCTSTR MFolderDialog::GetFolderPath() const\r\n{\r\n    return m_szFolderPath;\r\n}\r\n\r\ninline LPCTSTR MFolderDialog::GetFolderDisplayName() const\r\n{\r\n    return m_szFolderDisplayName;\r\n}\r\n\r\ninline INT MFolderDialog::GetFolderImageIndex() const\r\n{\r\n    return m_bi.iImage;\r\n}\r\n\r\ninline VOID MFolderDialog::EnableOK(BOOL bEnable)\r\n{\r\n    SendMessageDx(BFFM_ENABLEOK, 0, bEnable);\r\n}\r\n\r\ninline VOID MFolderDialog::SetStatusText(LPCTSTR pszText)\r\n{\r\n    SendMessageDx(BFFM_SETSTATUSTEXT, 0, (LPARAM)pszText);\r\n}\r\n\r\ninline VOID MFolderDialog::SetOKText(LPCTSTR pszOKText)\r\n{\r\n#ifndef BFFM_SETOKTEXT\r\n    const UINT BFFM_SETOKTEXT = WM_USER + 105;\r\n#endif\r\n    MTextToWide str(pszOKText);\r\n    SendMessageDx(BFFM_SETOKTEXT, (WPARAM)str.c_str());\r\n}\r\n\r\ninline VOID MFolderDialog::SetExpanded(LPCITEMIDLIST pidl)\r\n{\r\n#ifndef BFFM_SETEXPANDED\r\n    const UINT BFFM_SETEXPANDED = WM_USER + 106;\r\n#endif\r\n    SendMessageDx(BFFM_SETEXPANDED, FALSE, (LPARAM)pidl);\r\n}\r\n\r\ninline VOID MFolderDialog::SetExpanded(LPCTSTR pszFolderPath)\r\n{\r\n#ifndef BFFM_SETEXPANDED\r\n    const UINT BFFM_SETEXPANDED = WM_USER + 106;\r\n#endif\r\n    MTextToWide str(pszFolderPath);\r\n    SendMessageDx(BFFM_SETEXPANDED, TRUE, (LPARAM)str.c_str());\r\n}\r\n\r\ninline VOID MFolderDialog::SetSelection(LPCITEMIDLIST pidl)\r\n{\r\n    SendMessageDx(BFFM_SETSELECTION, FALSE, (LPARAM)pidl);\r\n}\r\n\r\ninline VOID MFolderDialog::SetSelection(LPCTSTR pszFolderPath)\r\n{\r\n    SendMessageDx(BFFM_SETSELECTION, TRUE, (LPARAM)pszFolderPath);\r\n}\r\n\r\ninline /*static*/ INT CALLBACK\r\nMFolderDialog::BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData)\r\n{\r\n#ifndef BFFM_VALIDATEFAILED\r\n    #ifdef _UNICODE\r\n        const INT BFFM_VALIDATEFAILED = 4;\r\n    #else\r\n        const INT BFFM_VALIDATEFAILED = 3;\r\n    #endif\r\n#endif\r\n#ifndef BFFM_IUNKNOWN\r\n    const INT BFFM_IUNKNOWN = 5;\r\n#endif\r\n    assert(lpData);\r\n    MFolderDialog *pDialog = reinterpret_cast<MFolderDialog *>(lpData);\r\n    if (pDialog->m_hwnd == NULL)\r\n        pDialog->Attach(hWnd);\r\n\r\n    INT nRet = 0;\r\n    switch (uMsg)\r\n    {\r\n    case BFFM_INITIALIZED:\r\n        /* set selection */\r\n        if (pDialog->m_pidlInitialSelection)\r\n            pDialog->SetSelection(pDialog->m_pidlInitialSelection);\r\n        else if (pDialog->m_szInitialDir[0] != 0)\r\n            pDialog->SetSelection(pDialog->m_szInitialDir);\r\n\r\n        /* expand if necessary */\r\n        if (pDialog->m_bExpand)\r\n        {\r\n            if (pDialog->m_pidlInitialSelection)\r\n                pDialog->SetExpanded(pDialog->m_pidlInitialSelection);\r\n            else if (pDialog->m_szInitialDir[0] != 0)\r\n                pDialog->SetExpanded(pDialog->m_szInitialDir);\r\n        }\r\n\r\n        pDialog->OnInitialized();\r\n        break;\r\n\r\n    case BFFM_SELCHANGED:\r\n        pDialog->OnSelChanged(reinterpret_cast<LPITEMIDLIST>(lParam));\r\n        break;\r\n\r\n    case BFFM_VALIDATEFAILED:\r\n        nRet = pDialog->OnValidateFailed(reinterpret_cast<LPCTSTR>(lParam));\r\n        break;\r\n\r\n    case BFFM_IUNKNOWN:\r\n        pDialog->OnIUnknown(reinterpret_cast<IUnknown *>(lParam));\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n\r\n    return nRet;\r\n}\r\n\r\ninline /*virtual*/ VOID MFolderDialog::OnInitialized()\r\n{\r\n}\r\n\r\ninline /*virtual*/ VOID MFolderDialog::OnSelChanged(LPITEMIDLIST)\r\n{\r\n}\r\n\r\ninline /*virtual*/ INT MFolderDialog::OnValidateFailed(LPCTSTR)\r\n{\r\n    return 1;   // 1: continue, 0: EndDialog\r\n}\r\n\r\ninline /*virtual*/ VOID MFolderDialog::OnIUnknown(IUnknown*)\r\n{\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFOLDERDIALOG_HPP_\r\n
MFont.hpp<>MFont.hpp<>// MFont.hpp -- Win32API font object wrapper                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFONT_HPP_\r\n#define MZC4_MFONT_HPP_         5   /* Version 5 */\r\n\r\nclass MFont;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n#include "MString.hpp"\r\n\r\n#include <vector>\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MFont : public MGdiObject\r\n{\r\npublic:\r\n    MFont();\r\n    MFont(HFONT hFont);\r\n    MFont(const MFont& font);\r\n\r\n    operator HFONT() const;\r\n    HFONT Handle() const;\r\n\r\n    INT GetLogFont(LOGFONT *lplf) const;\r\n\r\n    MFont& operator=(HFONT hFont);\r\n    MFont& operator=(const MFont& font);\r\n\r\n    BOOL Attach(HFONT hFont);\r\n    HFONT Detach(VOID);\r\n\r\n    BOOL CreateFont(\r\n        LPCTSTR pszFace,\r\n        INT nHeight,\r\n        INT nWidth = 0,\r\n        INT nEscapement = 0,\r\n        INT nOrientation = 0,\r\n        INT fnWeight = FW_NORMAL,\r\n        DWORD fdwItalic = FALSE,\r\n        DWORD fdwUnderline = FALSE,\r\n        DWORD fdwStrikeOut = FALSE,\r\n        DWORD fdwCharSet = DEFAULT_CHARSET,\r\n        DWORD fdwOutputPrecision = OUT_DEFAULT_PRECIS,\r\n        DWORD fdwClipPrecision = CLIP_DEFAULT_PRECIS,\r\n        DWORD fdwQuality = ANTIALIASED_QUALITY,\r\n        DWORD fdwPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE);\r\n    BOOL CreateFontIndirect(CONST LOGFONT *lplf);\r\n    BOOL CreateAnsiFixedFont();\r\n    BOOL CreateAnsiVarFont();\r\n    BOOL CreateDeviceDefaultFont();\r\n    BOOL CreateDefaultGuiFont();\r\n    BOOL CreateOemFixedFont();\r\n    BOOL CreateSystemFont();\r\n    BOOL CreateSystemFixedFont();\r\n\r\n    static HFONT CloneHandleDx(HFONT hFont);\r\n\r\n    enum\r\n    {\r\n        fontset_no_vertical = 1,\r\n        fontset_vertical_only = 2,\r\n        fontset_truetype_only = 4,\r\n        fontset_raster_only = 8,\r\n        fontset_fixed_pitch_only = 16\r\n    };\r\n    static BOOL GetFontList(HDC hdc, std::vector<MString>& vec, LPCTSTR pszName = NULL,\r\n                            DWORD dwFlags = fontset_no_vertical);\r\n    static BOOL GetFontList(HDC hdc, std::vector<MString>& vec, LPLOGFONT plf,\r\n                            DWORD dwFlags = fontset_no_vertical);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nstruct MEnumFontData\r\n{\r\n    std::vector<MString> m_vec;\r\n    DWORD m_dwFlags;\r\n};\r\n\r\nINT CALLBACK EnumFontFamProcDx(\r\n    ENUMLOGFONT *lpelf, NEWTEXTMETRIC *lpntm,\r\n    INT nFontType, LPARAM lParam);\r\n\r\nINT CALLBACK EnumFontFamExProcDx(\r\n    ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme,\r\n    INT nFontType, LPARAM lParam);\r\n\r\ninline /*static*/ BOOL\r\nMFont::GetFontList(HDC hdc, std::vector<MString>& vec,\r\n                   LPCTSTR pszName/* = NULL*/,\r\n                   DWORD dwFlags/* = fontset_no_vertical*/)\r\n{\r\n    MEnumFontData data;\r\n    data.m_dwFlags = dwFlags;\r\n\r\n    BOOL bCreateDC = FALSE;\r\n    if (hdc == NULL)\r\n    {\r\n        hdc = CreateCompatibleDC(NULL);\r\n        bCreateDC = TRUE;\r\n    }\r\n\r\n    BOOL bOK = ::EnumFontFamilies(hdc, pszName, (FONTENUMPROC)EnumFontFamProcDx, (LPARAM)&data);\r\n\r\n    if (bCreateDC)\r\n        ::DeleteDC(hdc);\r\n\r\n    if (bOK)\r\n        vec.assign(data.m_vec.begin(), data.m_vec.end());\r\n    else\r\n        vec.clear();\r\n\r\n    return bOK;\r\n}\r\n\r\ninline /*static*/ BOOL\r\nMFont::GetFontList(HDC hdc, std::vector<MString>& vec, LPLOGFONT plf,\r\n                   DWORD dwFlags/* = fontset_no_vertical*/)\r\n{\r\n    MEnumFontData data;\r\n    data.m_dwFlags = dwFlags;\r\n\r\n    BOOL bCreateDC = FALSE;\r\n    if (hdc == NULL)\r\n    {\r\n        hdc = CreateCompatibleDC(NULL);\r\n        bCreateDC = TRUE;\r\n    }\r\n\r\n    BOOL bOK = ::EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)EnumFontFamExProcDx, (LPARAM)&data, 0);\r\n\r\n    if (bCreateDC)\r\n        ::DeleteDC(hdc);\r\n\r\n    if (bOK)\r\n        vec.assign(data.m_vec.begin(), data.m_vec.end());\r\n    else\r\n        vec.clear();\r\n\r\n    return bOK;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ HFONT MFont::CloneHandleDx(HFONT hFont)\r\n{\r\n    if (hFont == NULL)\r\n        return NULL;\r\n    LOGFONT lf;\r\n    ::GetObject(hFont, sizeof(LOGFONT), &lf);\r\n    return ::CreateFontIndirect(&lf);\r\n}\r\n\r\ninline MFont::MFont()\r\n{\r\n}\r\n\r\ninline MFont::MFont(HFONT hFont) : MGdiObject(hFont)\r\n{\r\n}\r\n\r\ninline MFont::MFont(const MFont& font) : MGdiObject(CloneHandleDx(font))\r\n{\r\n}\r\n\r\ninline HFONT MFont::Handle() const\r\n{\r\n    return (this ? (HFONT)m_hGdiObj : NULL);\r\n}\r\n\r\ninline MFont::operator HFONT() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline INT MFont::GetLogFont(LOGFONT *lplf) const\r\n{\r\n    assert(Handle());\r\n    return ::GetObject(Handle(), sizeof(LOGFONT), lplf);\r\n}\r\n\r\ninline MFont& MFont::operator=(HFONT hFont)\r\n{\r\n    assert(hFont == NULL || ::GetObjectType(hFont) == OBJ_FONT);\r\n    if (Handle() != hFont)\r\n    {\r\n        Attach(hFont);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MFont& MFont::operator=(const MFont& font)\r\n{\r\n    if (Handle() != font.Handle())\r\n    {\r\n        HFONT hFont = CloneHandleDx(font);\r\n        Attach(hFont);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MFont::Attach(HFONT hFont)\r\n{\r\n    assert(::GetObjectType(hFont) == OBJ_FONT);\r\n    return MGdiObject::Attach(hFont);\r\n}\r\n\r\ninline HFONT MFont::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HFONT>(MGdiObject::Detach());\r\n}\r\n\r\ninline BOOL MFont::CreateFontIndirect(CONST LOGFONT *lplf)\r\n{\r\n    return Attach(::CreateFontIndirect(lplf));\r\n}\r\n\r\ninline BOOL MFont::CreateAnsiFixedFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(ANSI_FIXED_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateAnsiVarFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(ANSI_VAR_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateDeviceDefaultFont()\r\n{\r\n    assert(Handle() == NULL);\r\n    return Attach((HFONT)::GetStockObject(DEVICE_DEFAULT_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateDefaultGuiFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(DEFAULT_GUI_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateOemFixedFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(OEM_FIXED_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateSystemFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(SYSTEM_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateSystemFixedFont()\r\n{\r\n    return Attach((HFONT)::GetStockObject(SYSTEM_FIXED_FONT));\r\n}\r\n\r\ninline BOOL MFont::CreateFont(LPCTSTR pszFace, INT nHeight,\r\n    INT nWidth/* = 0*/, INT nEscapement/* = 0*/, INT nOrientation/* = 0*/,\r\n    INT fnWeight/* = FW_NORMAL*/, DWORD fdwItalic/* = FALSE*/,\r\n    DWORD fdwUnderline/* = FALSE*/, DWORD fdwStrikeOut/* = FALSE*/,\r\n    DWORD fdwCharSet/* = DEFAULT_CHARSET*/,\r\n    DWORD fdwOutputPrecision/* = OUT_DEFAULT_PRECIS*/,\r\n    DWORD fdwClipPrecision/* = CLIP_DEFAULT_PRECIS*/,\r\n    DWORD fdwQuality/* = ANTIALIASED_QUALITY*/,\r\n    DWORD fdwPitchAndFamily/* = DEFAULT_PITCH | FF_DONTCARE*/)\r\n{\r\n    return Attach(::CreateFont(nHeight, nWidth, nEscapement,\r\n        nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut,\r\n        fdwCharSet, fdwOutputPrecision, fdwClipPrecision,\r\n        fdwQuality, fdwPitchAndFamily, pszFace));\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline INT CALLBACK EnumFontFamProcDx(\r\n    ENUMLOGFONT *lpelf, NEWTEXTMETRIC *lpntm,\r\n    INT nFontType, LPARAM lParam)\r\n{\r\n    MEnumFontData *pData = reinterpret_cast<MEnumFontData *>(lParam);\r\n    assert(pData);\r\n\r\n    BOOL bAccept = TRUE;\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_truetype_only)\r\n    {\r\n        if (!(nFontType & TRUETYPE_FONTTYPE))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_raster_only)\r\n    {\r\n        if (!(nFontType & RASTER_FONTTYPE))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_fixed_pitch_only)\r\n    {\r\n        if (lpelf->elfLogFont.lfPitchAndFamily != FIXED_PITCH)\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_no_vertical)\r\n    {\r\n        if (lpelf->elfLogFont.lfFaceName[0] == TEXT('@'))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_vertical_only)\r\n    {\r\n        if (lpelf->elfLogFont.lfFaceName[0] != TEXT('@'))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (bAccept)\r\n        pData->m_vec.push_back(lpelf->elfLogFont.lfFaceName);\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline INT CALLBACK\r\nEnumFontFamExProcDx(\r\n    ENUMLOGFONTEX *lpelfe, NEWTEXTMETRICEX *lpntme,\r\n    INT nFontType, LPARAM lParam)\r\n{\r\n    MEnumFontData *pData = reinterpret_cast<MEnumFontData *>(lParam);\r\n    assert(pData);\r\n\r\n    BOOL bAccept = TRUE;\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_truetype_only)\r\n    {\r\n        if (!(nFontType & TRUETYPE_FONTTYPE))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_raster_only)\r\n    {\r\n        if (!(nFontType & RASTER_FONTTYPE))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_fixed_pitch_only)\r\n    {\r\n        if (lpelfe->elfLogFont.lfPitchAndFamily != FIXED_PITCH)\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_no_vertical)\r\n    {\r\n        if (lpelfe->elfLogFont.lfFaceName[0] == TEXT('@'))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (pData->m_dwFlags & MFont::fontset_vertical_only)\r\n    {\r\n        if (lpelfe->elfLogFont.lfFaceName[0] != TEXT('@'))\r\n            bAccept = FALSE;\r\n    }\r\n\r\n    if (bAccept)\r\n        pData->m_vec.push_back(lpelfe->elfLogFont.lfFaceName);\r\n\r\n    return TRUE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFONT_HPP_\r\n
MFontDialog.hpp<>MFontDialog.hpp<>// MFontDialog.hpp -- MZC4 font dialog wrapper                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MFONTDIALOG_HPP_\r\n#define MZC4_MFONTDIALOG_HPP_       2       /* Version 2 */\r\n\r\nclass MFontDialog;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCommonDialog.hpp"\r\n\r\nclass MFontDialog : public MCommonDialog\r\n{\r\npublic:\r\n    CHOOSEFONT  m_cf;\r\n    LOGFONT     m_lf;\r\n\r\n    // before main\r\n    MFontDialog(HWND hwndOwner, LPLOGFONT plfInitial = NULL,\r\n                DWORD dwCF_ = CF_EFFECTS | CF_SCREENFONTS,\r\n                HDC hdcPrinter = NULL);\r\n\r\n    // main\r\n    BOOL ChooseFont();\r\n\r\n    // after main\r\n    COLORREF GetColor() const;\r\n    VOID GetCurrentFont(LPLOGFONT plf);\r\n    MString GetFaceName() const;\r\n    INT GetSize() const;\r\n    MString GetStyleName() const;\r\n    INT GetWeight() const;\r\n    BOOL IsBold() const;\r\n    BOOL IsItalic() const;\r\n    BOOL IsStrikeOut() const;\r\n    BOOL IsUnderline() const;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMFontDialog::MFontDialog(HWND hwndOwner,\r\n                         LPLOGFONT plfInitial/* = NULL*/,\r\n                         DWORD dwCF_/* = CF_EFFECTS | CF_SCREENFONTS*/,\r\n                         HDC hdcPrinter/* = NULL*/)\r\n    : MCommonDialog(hwndOwner)\r\n{\r\n    m_bModal = TRUE;\r\n\r\n    ZeroMemory(&m_cf, sizeof(m_cf));\r\n    m_cf.lStructSize = sizeof(m_cf);\r\n    m_cf.hwndOwner = hwndOwner;\r\n    m_cf.hDC = hdcPrinter;\r\n    m_cf.lpLogFont = &m_lf;\r\n    m_cf.Flags = dwCF_;\r\n    if (hdcPrinter)\r\n        m_cf.Flags |= CF_PRINTERFONTS;\r\n\r\n    if (plfInitial)\r\n    {\r\n        CopyMemory(&m_lf, plfInitial, sizeof(LOGFONT));\r\n        m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;\r\n    }\r\n    else\r\n    {\r\n        ZeroMemory(&m_lf, sizeof(m_lf));\r\n        m_lf.lfCharSet = DEFAULT_CHARSET;\r\n    }\r\n}\r\n\r\ninline BOOL MFontDialog::ChooseFont()\r\n{\r\n    return ::ChooseFont(&m_cf);\r\n}\r\n\r\ninline COLORREF MFontDialog::GetColor() const\r\n{\r\n    assert(m_cf.Flags & CF_EFFECTS);\r\n    return (COLORREF)m_cf.rgbColors;\r\n}\r\n\r\ninline VOID MFontDialog::GetCurrentFont(LPLOGFONT plf)\r\n{\r\n    CopyMemory(plf, &m_lf, sizeof(LOGFONT));\r\n}\r\n\r\ninline MString MFontDialog::GetFaceName() const\r\n{\r\n    MString ret(m_lf.lfFaceName);\r\n    return ret;\r\n}\r\n\r\ninline INT MFontDialog::GetSize() const\r\n{\r\n    return m_cf.iPointSize;\r\n}\r\n\r\ninline MString MFontDialog::GetStyleName() const\r\n{\r\n    MString ret;\r\n    if ((m_cf.Flags & CF_USESTYLE) && m_cf.lpszStyle)\r\n        ret = m_cf.lpszStyle;\r\n    return ret;\r\n}\r\n\r\ninline INT MFontDialog::GetWeight() const\r\n{\r\n    return m_lf.lfWeight;\r\n}\r\n\r\ninline BOOL MFontDialog::IsBold() const\r\n{\r\n    return GetWeight() >= FW_BOLD;\r\n}\r\n\r\ninline BOOL MFontDialog::IsItalic() const\r\n{\r\n    return m_lf.lfItalic;\r\n}\r\n\r\ninline BOOL MFontDialog::IsStrikeOut() const\r\n{\r\n    return m_lf.lfStrikeOut;\r\n}\r\n\r\ninline BOOL MFontDialog::IsUnderline() const\r\n{\r\n    return m_lf.lfUnderline;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MFONTDIALOG_HPP_\r\n
MGdiObject.hpp<>MGdiObject.hpp<>// MGdiObject.hpp -- Win32API GDI object wrapper                -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MGDIOBJECT_HPP_\r\n#define MZC4_MGDIOBJECT_HPP_     2   /* Version 2 */\r\n\r\nclass MGdiObject;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n#pragma comment(lib, "gdi32.lib")\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MGdiObject\r\n{\r\npublic:\r\n    HGDIOBJ m_hGdiObj;\r\n\r\npublic:\r\n    MGdiObject();\r\n    MGdiObject(HGDIOBJ hGdiObj);\r\n    virtual ~MGdiObject();\r\n\r\n    bool operator!() const;\r\n    MGdiObject& operator=(HGDIOBJ hGdiObj);\r\n    bool operator==(HGDIOBJ hGdiObj);\r\n    bool operator!=(HGDIOBJ hGdiObj);\r\n    HANDLE Handle() const;\r\n\r\n    BOOL Attach(HGDIOBJ hGdiObj);\r\n    HGDIOBJ Detach();\r\n\r\n    BOOL GetStockObject(INT nObject);\r\n    INT GetObject(INT nSize, LPVOID pData) const;\r\n    BOOL DeleteObject(VOID);\r\n\r\n    BOOL UnrealizeObject(VOID);\r\n\r\nprivate:\r\n    // NOTE: MGdiObject is not copyable.\r\n    MGdiObject(const MGdiObject& obj);              // no impl\r\n    MGdiObject& operator=(const MGdiObject& obj);   // no impl\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MGdiObject::MGdiObject() : m_hGdiObj(NULL)\r\n{\r\n}\r\n\r\ninline MGdiObject::MGdiObject(HGDIOBJ hGdiObj) : m_hGdiObj(hGdiObj)\r\n{\r\n}\r\n\r\ninline /*virtual*/ MGdiObject::~MGdiObject()\r\n{\r\n    DeleteObject();\r\n}\r\n\r\ninline MGdiObject& MGdiObject::operator=(HGDIOBJ hGdiObj)\r\n{\r\n    if (Handle() != hGdiObj)\r\n    {\r\n        DeleteObject();\r\n        m_hGdiObj = hGdiObj;\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MGdiObject::Attach(HGDIOBJ hGdiObj)\r\n{\r\n    assert(hGdiObj);\r\n    assert(m_hGdiObj == NULL);\r\n    m_hGdiObj = hGdiObj;\r\n    return m_hGdiObj != NULL;\r\n}\r\n\r\ninline HGDIOBJ MGdiObject::Detach()\r\n{\r\n    HGDIOBJ hGdiObj = m_hGdiObj;\r\n    m_hGdiObj = NULL;\r\n    return hGdiObj;\r\n}\r\n\r\ninline BOOL MGdiObject::GetStockObject(INT nObject)\r\n{\r\n    assert(m_hGdiObj == NULL);\r\n    return Attach(::GetStockObject(nObject));\r\n}\r\n\r\ninline BOOL MGdiObject::DeleteObject(VOID)\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DeleteObject(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline HANDLE MGdiObject::Handle() const\r\n{\r\n    return (this ? m_hGdiObj : NULL);\r\n}\r\n\r\ninline BOOL MGdiObject::UnrealizeObject(VOID)\r\n{\r\n    return ::UnrealizeObject(m_hGdiObj);\r\n}\r\n\r\ninline bool MGdiObject::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline bool MGdiObject::operator==(HGDIOBJ hGdiObj)\r\n{\r\n    return Handle() == hGdiObj;\r\n}\r\n\r\ninline bool MGdiObject::operator!=(HGDIOBJ hGdiObj)\r\n{\r\n    return Handle() != hGdiObj;\r\n}\r\n\r\ninline INT MGdiObject::GetObject(INT nSize, LPVOID pData) const\r\n{\r\n    return ::GetObject(m_hGdiObj, nSize, pData);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MGDIOBJECT_HPP_\r\n
MHeaderCtrl.hpp<>MHeaderCtrl.hpp<>// MHeaderCtrl.hpp -- Win32API header control wrapper           -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MHEADERCTRL_HPP_\r\n#define MZC4_MHEADERCTRL_HPP_       2       /* Version 2 */\r\n\r\nclass MHeaderCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MHeaderCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MHeaderCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetItemCount() const;\r\n    BOOL GetItem(INT nPos, HDITEM* pHeaderItem) const;\r\n    BOOL SetItem(INT nPos, HDITEM* pHeaderItem);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        BOOL GetItemRect(INT nIndex, LPRECT prc) const;\r\n\r\n        HIMAGELIST GetImageList() const;\r\n        HIMAGELIST SetImageList(HIMAGELIST hImageList);\r\n\r\n        BOOL GetOrderArray(LPINT piArray, INT iCount = -1);\r\n        BOOL SetOrderArray(INT iCount, LPINT piArray);\r\n\r\n        INT OrderToIndex(INT nOrder) const;\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    INT InsertItem(INT nPos, HDITEM* phdi);\r\n    BOOL DeleteItem(INT nPos);\r\n    BOOL Layout(HDLAYOUT* pHeaderLayout);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        HIMAGELIST CreateDragImage(INT nIndex);\r\n\r\n        INT SetHotDivider(MPoint pt);\r\n        INT SetHotDivider(INT nIndex);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MHeaderCtrl::MHeaderCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MHeaderCtrl::GetWndClassNameDx() const\r\n{\r\n    return WC_HEADER;\r\n}\r\n\r\ninline INT MHeaderCtrl::GetItemCount() const\r\n{\r\n    return (INT)SendMessageDx(HDM_GETITEMCOUNT);\r\n}\r\n\r\ninline BOOL MHeaderCtrl::GetItem(INT nPos, HDITEM* pHeaderItem) const\r\n{\r\n    return (BOOL)SendMessageDx(HDM_GETITEM, (WPARAM)nPos, (LPARAM)pHeaderItem);\r\n}\r\n\r\ninline BOOL MHeaderCtrl::SetItem(INT nPos, HDITEM* pHeaderItem)\r\n{\r\n    return (BOOL)SendMessageDx(HDM_SETITEM, (WPARAM)nPos, (LPARAM)pHeaderItem);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline HIMAGELIST MHeaderCtrl::GetImageList() const\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(HDM_GETIMAGELIST);\r\n    }\r\n\r\n    inline HIMAGELIST MHeaderCtrl::SetImageList(HIMAGELIST hImageList)\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(HDM_SETIMAGELIST, 0, (LPARAM)hImageList);\r\n    }\r\n\r\n    inline BOOL MHeaderCtrl::GetItemRect(INT nIndex, LPRECT prc) const\r\n    {\r\n        return (BOOL)SendMessageDx(HDM_GETITEMRECT, (WPARAM)nIndex, (LPARAM)prc);\r\n    }\r\n\r\n    inline BOOL MHeaderCtrl::GetOrderArray(LPINT piArray, INT iCount/* = -1*/)\r\n    {\r\n        return (BOOL)SendMessageDx(\r\n            HDM_GETORDERARRAY, (WPARAM)iCount, (LPARAM)piArray);\r\n    }\r\n\r\n    inline BOOL MHeaderCtrl::SetOrderArray(INT iCount, LPINT piArray)\r\n    {\r\n        return (BOOL)SendMessageDx(HDM_SETORDERARRAY, (WPARAM)iCount, (LPARAM)piArray);\r\n    }\r\n\r\n    inline INT MHeaderCtrl::OrderToIndex(INT nOrder) const\r\n    {\r\n        return (INT)SendMessageDx(HDM_ORDERTOINDEX, (WPARAM)nOrder);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline INT MHeaderCtrl::InsertItem(INT nPos, HDITEM* phdi)\r\n{\r\n    return (INT)SendMessageDx(HDM_INSERTITEM, (WPARAM)nPos, (LPARAM)phdi);\r\n}\r\n\r\ninline BOOL MHeaderCtrl::DeleteItem(INT nPos)\r\n{\r\n    return (BOOL)SendMessageDx(HDM_DELETEITEM, (WPARAM)nPos);\r\n}\r\n\r\ninline BOOL MHeaderCtrl::Layout(HDLAYOUT* pHeaderLayout)\r\n{\r\n    return (BOOL)SendMessageDx(HDM_LAYOUT, 0, (LPARAM)pHeaderLayout);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline HIMAGELIST MHeaderCtrl::CreateDragImage(INT nIndex)\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(HDM_CREATEDRAGIMAGE, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline INT MHeaderCtrl::SetHotDivider(MPoint pt)\r\n    {\r\n        return (INT)SendMessageDx(HDM_SETHOTDIVIDER, TRUE, MAKELPARAM(pt.x, pt.y));\r\n    }\r\n\r\n    inline INT MHeaderCtrl::SetHotDivider(INT nIndex)\r\n    {\r\n        return (INT)SendMessageDx(HDM_SETHOTDIVIDER, FALSE, nIndex);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MHEADERCTRL_HPP_\r\n
MHotKeyCtrl.hpp<>MHotKeyCtrl.hpp<>// MHotKeyCtrl.hpp -- Win32API hot-key control wrapper          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MHOTKEYCTRL_HPP_\r\n#define MZC4_MHOTKEYCTRL_HPP_    2       /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MHotKeyCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MHotKeyCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    DWORD GetHotKey() const;\r\n    VOID GetHotKey(WORD &wVK_, WORD &wHOTKEYF_flags) const;\r\n    VOID SetHotKey(WORD wVK_, WORD wHOTKEYF_flags);\r\n\r\n    VOID SetRules(WORD wHKCOMB_invalid, WORD wHOTKEYF_flags);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MHotKeyCtrl::MHotKeyCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MHotKeyCtrl::GetWndClassNameDx() const\r\n{\r\n    return HOTKEY_CLASS;\r\n}\r\n\r\ninline DWORD MHotKeyCtrl::GetHotKey() const\r\n{\r\n    return (DWORD)SendMessageDx(HKM_GETHOTKEY);\r\n}\r\n\r\ninline VOID\r\nMHotKeyCtrl::GetHotKey(WORD &wVK_, WORD &wHOTKEYF_flags) const\r\n{\r\n    DWORD dw = (DWORD)SendMessageDx(HKM_GETHOTKEY);\r\n    wVK_ = LOBYTE(LOWORD(dw));\r\n    wHOTKEYF_flags = HIBYTE(LOWORD(dw));\r\n}\r\n\r\ninline VOID MHotKeyCtrl::SetHotKey(WORD wVK_, WORD wHOTKEYF_flags)\r\n{\r\n    SendMessageDx(HKM_SETHOTKEY, MAKEWPARAM(wVK_, wHOTKEYF_flags));\r\n}\r\n\r\ninline VOID MHotKeyCtrl::SetRules(WORD wHKCOMB_invalid, WORD wHOTKEYF_flags)\r\n{\r\n    SendMessageDx(HKM_SETRULES, wHKCOMB_invalid, wHOTKEYF_flags);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MHOTKEYCTRL_HPP_\r\n
MHyperLinkCtrl.hpp<>MHyperLinkCtrl.hpp<>// MHyperLinkCtrl.hpp --- hyper link control\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MHYPERLINKCTRL_HPP_\r\n#define MZC4_MHYPERLINKCTRL_HPP_        4   /* Version 4 */\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MHyperLinkCtrl;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MHyperLinkCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MHyperLinkCtrl() :\r\n        m_bGotFocus(FALSE),\r\n        m_hHandCursor(LoadCursor(NULL, IDC_HAND))\r\n    {\r\n    }\r\n\r\n    virtual ~MHyperLinkCtrl()\r\n    {\r\n        DestroyCursor(m_hHandCursor);\r\n    }\r\n\r\n    virtual void OnJump(HWND hwnd)\r\n    {\r\n        WPARAM wParam = MAKEWPARAM(GetDlgCtrlID(hwnd), STN_CLICKED);\r\n        LPARAM lParam = (LPARAM)hwnd;\r\n        SendMessage(GetParent(hwnd), WM_COMMAND, wParam, lParam);\r\n    }\r\n\r\n    void OnPaint(HWND hwnd)\r\n    {\r\n        ModifyStyleDx(0, SS_NOTIFY | WS_TABSTOP);\r\n\r\n        TCHAR szClass[64];\r\n        GetClassName(hwnd, szClass, 64);\r\n        assert(lstrcmpi(szClass, TEXT("STATIC")) == 0);\r\n\r\n        PAINTSTRUCT ps;\r\n        if (HDC hDC = BeginPaint(hwnd, &ps))\r\n        {\r\n            HFONT hDefaultFont = (HFONT)SendMessageDx(WM_GETFONT, 0, 0);\r\n\r\n            LOGFONT lf;\r\n            GetObject(hDefaultFont, sizeof(lf), &lf);\r\n            lf.lfUnderline = TRUE;\r\n\r\n            HFONT hFont = CreateFontIndirect(&lf);\r\n            if (hFont)\r\n            {\r\n                HGDIOBJ hFontOld = SelectObject(hDC, hFont);\r\n\r\n                RECT rcWindow, rcClient;\r\n                GetWindowRect(hwnd, &rcWindow);\r\n                GetClientRect(hwnd, &rcClient);\r\n\r\n                POINT pt;\r\n                GetCursorPos(&pt);\r\n\r\n                if (m_bGotFocus || PtInRect(&rcWindow, pt))\r\n                {\r\n                    SetTextColor(hDC, RGB(255, 0, 0));\r\n                    SetBkColor(hDC, RGB(255, 255, 0));\r\n                }\r\n                else\r\n                {\r\n                    SetTextColor(hDC, RGB(0, 0, 255));\r\n                    SetBkColor(hDC, GetSysColor(COLOR_3DFACE));\r\n                }\r\n                SetBkMode(hDC, OPAQUE);\r\n\r\n                FillRect(hDC, &rcClient, (HBRUSH)(COLOR_3DFACE + 1));\r\n\r\n                UINT uFormat = DT_NOPREFIX;\r\n                DWORD style = GetStyleDx();\r\n                if (style & SS_CENTER)\r\n                    uFormat |= DT_CENTER;\r\n                if (style & SS_RIGHT)\r\n                    uFormat |= DT_RIGHT;\r\n                if (style & SS_CENTERIMAGE)\r\n                    uFormat |= DT_VCENTER | DT_SINGLELINE;\r\n\r\n                MString text = GetWindowText();\r\n                DrawText(hDC, text.c_str(), int(text.size()), &rcClient, uFormat);\r\n\r\n                if (m_bGotFocus)\r\n                {\r\n                    InflateRect(&rcClient, -1, -1);\r\n                    DrawFocusRect(hDC, &rcClient);\r\n                }\r\n\r\n                SelectObject(hDC, hFontOld);\r\n                DeleteObject(hFont);\r\n            }\r\n\r\n            EndPaint(hwnd, &ps);\r\n        }\r\n    }\r\n\r\n    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)\r\n    {\r\n        InvalidateRect(hwnd, NULL, TRUE);\r\n        SetTimer(hwnd, 999, 100, NULL);\r\n        SetCursor(m_hHandCursor);\r\n    }\r\n\r\n    void OnTimer(HWND hwnd, UINT id)\r\n    {\r\n        RECT rc;\r\n        GetWindowRect(hwnd, &rc);\r\n\r\n        POINT pt;\r\n        GetCursorPos(&pt);\r\n\r\n        if (!PtInRect(&rc, pt))\r\n        {\r\n            InvalidateRect(hwnd, NULL, TRUE);\r\n            KillTimer(hwnd, 999);\r\n            SetCursor(LoadCursor(NULL, IDC_ARROW));\r\n        }\r\n    }\r\n\r\n    void OnSetFocus(HWND hwnd, HWND hwndOldFocus)\r\n    {\r\n        m_bGotFocus = TRUE;\r\n        InvalidateRect(hwnd, NULL, TRUE);\r\n    }\r\n\r\n    void OnKillFocus(HWND hwnd, HWND hwndNewFocus)\r\n    {\r\n        m_bGotFocus = FALSE;\r\n        InvalidateRect(hwnd, NULL, TRUE);\r\n    }\r\n\r\n    void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)\r\n    {\r\n        if (vk == VK_SPACE)\r\n        {\r\n            OnJump(hwnd);\r\n        }\r\n    }\r\n\r\n    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)\r\n    {\r\n        OnJump(hwnd);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_PAINT, OnPaint);\r\n        HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);\r\n        HANDLE_MSG(hwnd, WM_TIMER, OnTimer);\r\n        HANDLE_MSG(hwnd, WM_SETFOCUS, OnSetFocus);\r\n        HANDLE_MSG(hwnd, WM_KILLFOCUS, OnKillFocus);\r\n        HANDLE_MSG(hwnd, WM_KEYDOWN, OnKey);\r\n        HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\nprotected:\r\n    BOOL m_bGotFocus;\r\n    HCURSOR m_hHandCursor;\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MHYPERLINKCTRL_HPP_\r\n
MIPAddressCtrl.hpp<>MIPAddressCtrl.hpp<>// MAccel.hpp -- Win32API IP address control wrapper            -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MIPADDRESSCTRL_HPP_\r\n#define MZC4_MIPADDRESSCTRL_HPP_        2       /* Version 2 */\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    class MIPAddressCtrl;\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    class MIPAddressCtrl : public MWindowBase\r\n    {\r\n    public:\r\n        MIPAddressCtrl();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        BOOL IsBlank() const;\r\n\r\n        INT GetAddress(LPDWORD lpdwAddress) const;\r\n        VOID SetAddress(DWORD dwAddress);\r\n        VOID ClearAddress();\r\n\r\n        VOID SetRange(INT nField, WORD wRange);\r\n        VOID SetRange(INT nField, BYTE nMin, BYTE nMax);\r\n        VOID SetFocus(INT nField);\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline MIPAddressCtrl::MIPAddressCtrl()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MIPAddressCtrl::GetWndClassNameDx() const\r\n    {\r\n        return WC_IPADDRESS;\r\n    }\r\n\r\n    inline BOOL MIPAddressCtrl::IsBlank() const\r\n    {\r\n        return (BOOL)SendMessageDx(IPM_ISBLANK);\r\n    }\r\n\r\n    inline INT MIPAddressCtrl::GetAddress(LPDWORD lpdwAddress) const\r\n    {\r\n        return (INT)SendMessageDx(IPM_GETADDRESS, 0, (LPARAM)lpdwAddress);\r\n    }\r\n\r\n    inline VOID MIPAddressCtrl::SetAddress(DWORD dwAddress)\r\n    {\r\n        SendMessageDx(IPM_SETADDRESS, 0, (LPARAM)dwAddress);\r\n    }\r\n\r\n    inline VOID MIPAddressCtrl::ClearAddress()\r\n    {\r\n        SendMessageDx(IPM_CLEARADDRESS);\r\n    }\r\n\r\n    inline VOID MIPAddressCtrl::SetRange(INT nField, WORD wRange)\r\n    {\r\n        SendMessageDx(IPM_SETRANGE, (WPARAM)nField, (LPARAM)wRange);\r\n    }\r\n\r\n    inline VOID MIPAddressCtrl::SetRange(INT nField, BYTE nMin, BYTE nMax)\r\n    {\r\n        SendMessageDx(IPM_SETRANGE, (WPARAM)nField, MAKEIPRANGE(nMin, nMax));\r\n    }\r\n\r\n    inline VOID MIPAddressCtrl::SetFocus(INT nField)\r\n    {\r\n        SendMessageDx(IPM_SETFOCUS, (WPARAM)nField);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MIPADDRESSCTRL_HPP_\r\n
MIcon.hpp<>MIcon.hpp<>// MIcon.hpp -- Win32API icon class                             -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MICON_HPP_\r\n#define MZC4_MICON_HPP_         4   /* Version 4 */\r\n\r\nclass MIcon;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MIcon\r\n{\r\npublic:\r\n    MIcon();\r\n    MIcon(HICON hIcon);\r\n    MIcon(const MIcon& icon);\r\n    MIcon& operator=(HICON hIcon);\r\n    MIcon& operator=(const MIcon& icon);\r\n    virtual ~MIcon();\r\n\r\n    bool operator!() const;\r\n    bool operator==(HICON hIcon) const;\r\n    bool operator!=(HICON hIcon) const;\r\n    HICON Handle() const;\r\n    operator HICON() const;\r\n\r\n    BOOL Attach(HICON hIcon);\r\n    HICON Detach();\r\n\r\n    BOOL CopyIcon(HICON hIcon);\r\n    BOOL CreateIcon(HINSTANCE hInstance, INT width, INT height,\r\n                    BYTE cPlanes, BYTE cBitsPixel,\r\n                    const BYTE *pbANDbits, const BYTE *pbXORbits);\r\n    BOOL CreateIcon(HINSTANCE hInstance, SIZE siz, BYTE cPlanes,\r\n                    BYTE cBitsPixel, const BYTE *pbANDbits,\r\n                    const BYTE *pbXORbits);\r\n    BOOL CreateIconFromResource(PBYTE presbits, DWORD dwResSize,\r\n                                BOOL fIcon = TRUE,\r\n                                DWORD dwVer = 0x00030000);\r\n    BOOL CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize,\r\n                                  BOOL fIcon = TRUE,\r\n                                  DWORD dwVer = 0x00030000,\r\n                                  INT cxDesired = 0, INT cyDesired = 0,\r\n                                  UINT uFlags = LR_DEFAULTCOLOR);\r\n    BOOL LoadIcon(LPCTSTR pszResourceName, HINSTANCE hInstance = NULL);\r\n    BOOL LoadIcon(UINT nIconID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadImage(HINSTANCE hInstance, LPCTSTR pszName,\r\n                   INT cxDesired = 0, INT cyDesired = 0, UINT fuLoad = 0);\r\n    BOOL LoadImageFromFile(HINSTANCE hInstance, LPCTSTR pszName,\r\n                           INT cxDesired = 0, INT cyDesired = 0,\r\n                           UINT fuLoad = 0);\r\n    BOOL CreateIconIndirect(PICONINFO pIconInfo);\r\n    BOOL ExtractIcon(LPCTSTR pszFile, UINT nIconIndex,\r\n                     HINSTANCE hInst = NULL);\r\n    UINT GetNumberOfIcons(LPCTSTR pszFile) const;\r\n    BOOL ExtractIconEx(LPCTSTR pszFile, INT nIconIndex, UINT nIcons,\r\n                       HICON *phIcons = NULL, HICON *phSmallIcons = NULL);\r\n    BOOL ExtractAssociatedIcon(LPTSTR pszPath, LPWORD pnIndex,\r\n                               HINSTANCE hInst = NULL);\r\n    BOOL DestroyIcon();\r\n\r\n    BOOL DrawIcon(HDC hDC, INT x, INT y);\r\n    BOOL DrawIconEx(HDC hDC, INT x, INT y, INT cx, INT cy,\r\n        UINT index = 0, HBRUSH hbr = NULL, UINT uDI_flags = DI_NORMAL);\r\n    BOOL GetIconInfo(PICONINFO pIconInfo) const;\r\n\r\n    static HICON CloneHandleDx(HICON hIcon);\r\n\r\nprotected:\r\n    HICON m_hIcon;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MIcon::MIcon() : m_hIcon(NULL)\r\n{\r\n}\r\n\r\ninline MIcon::MIcon(HICON hIcon) : m_hIcon(hIcon)\r\n{\r\n}\r\n\r\ninline MIcon::MIcon(const MIcon& icon)\r\n    : m_hIcon(CloneHandleDx(icon.m_hIcon))\r\n{\r\n    \r\n}\r\n\r\ninline /*virtual*/ MIcon::~MIcon()\r\n{\r\n    DestroyIcon();\r\n}\r\n\r\ninline bool MIcon::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline bool MIcon::operator==(HICON hIcon) const\r\n{\r\n    return Handle() == hIcon;\r\n}\r\n\r\ninline bool MIcon::operator!=(HICON hIcon) const\r\n{\r\n    return Handle() != hIcon;\r\n}\r\n\r\ninline HICON MIcon::Handle() const\r\n{\r\n    return (this ? m_hIcon : NULL);\r\n}\r\n\r\ninline MIcon::operator HICON() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline MIcon& MIcon::operator=(HICON hIcon)\r\n{\r\n    if (Handle() != hIcon)\r\n    {\r\n        Attach(hIcon);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MIcon& MIcon::operator=(const MIcon& icon)\r\n{\r\n    if (Handle() != icon.Handle())\r\n    {\r\n        HICON hIcon = CloneHandleDx(icon);\r\n        Attach(hIcon);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MIcon::Attach(HICON hIcon)\r\n{\r\n    DestroyIcon();\r\n    m_hIcon = hIcon;\r\n    return m_hIcon != NULL;\r\n}\r\n\r\ninline HICON MIcon::Detach()\r\n{\r\n    HICON hIcon = m_hIcon;\r\n    m_hIcon = NULL;\r\n    return hIcon;\r\n}\r\n\r\ninline BOOL MIcon::CopyIcon(HICON hIcon)\r\n{\r\n    return Attach(::CopyIcon(hIcon));\r\n}\r\n\r\ninline BOOL MIcon::CreateIcon(HINSTANCE hInstance,\r\n    INT width, INT height, BYTE cPlanes,\r\n    BYTE cBitsPixel, const BYTE *pbANDbits, const BYTE *pbXORbits)\r\n{\r\n    HICON hIcon = ::CreateIcon(hInstance, width, height,\r\n                               cPlanes, cBitsPixel, pbANDbits, pbXORbits);\r\n    if (hIcon == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hIcon = ::CreateIcon(hInstance, width, height,\r\n                             cPlanes, cBitsPixel, pbANDbits, pbXORbits);\r\n    }\r\n    return Attach(hIcon);\r\n}\r\n\r\ninline BOOL MIcon::CreateIcon(HINSTANCE hInstance, SIZE siz, BYTE cPlanes,\r\n    BYTE cBitsPixel, const BYTE *pbANDbits, const BYTE *pbXORbits)\r\n{\r\n    return MIcon::CreateIcon(hInstance, siz.cx, siz.cy, cPlanes,\r\n        cBitsPixel, pbANDbits, pbXORbits);\r\n}\r\n\r\ninline BOOL MIcon::CreateIconFromResource(PBYTE presbits, DWORD dwResSize,\r\n    BOOL fIcon/* = TRUE*/, DWORD dwVer/* = 0x00030000*/)\r\n{\r\n    return Attach(::CreateIconFromResource(presbits, dwResSize, fIcon, dwVer));\r\n}\r\n\r\ninline BOOL MIcon::CreateIconFromResourceEx(PBYTE presbits,\r\n    DWORD dwResSize, BOOL fIcon/* = TRUE*/, DWORD dwVer/* = 0x00030000*/,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT uFlags/* = LR_DEFAULTCOLOR*/)\r\n{\r\n    return Attach(::CreateIconFromResourceEx(presbits, dwResSize, fIcon, dwVer,\r\n                                             cxDesired, cyDesired, uFlags));\r\n}\r\n\r\ninline BOOL MIcon::LoadIcon(\r\n    LPCTSTR pszResourceName, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    HICON hIcon = ::LoadIcon(hInstance, pszResourceName);\r\n    if (hIcon == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hIcon = ::LoadIcon(hInstance, pszResourceName);\r\n    }\r\n    return Attach(hIcon);\r\n}\r\n\r\ninline BOOL MIcon::LoadIcon(UINT nIconID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    return LoadIcon(MAKEINTRESOURCE(nIconID), hInstance);\r\n}\r\n\r\ninline BOOL MIcon::LoadImage(HINSTANCE hInstance, LPCTSTR pszName,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    HICON hIcon = reinterpret_cast<HICON>(\r\n        ::LoadImage(hInstance, pszName, IMAGE_ICON, cxDesired, cyDesired,\r\n                    fuLoad));\r\n    if (hIcon == NULL && hInstance == NULL)\r\n    {\r\n        hInstance = ::GetModuleHandle(NULL);\r\n        hIcon = reinterpret_cast<HICON>(\r\n            ::LoadImage(hInstance, pszName, IMAGE_ICON, cxDesired, cyDesired,\r\n                        fuLoad));\r\n    }\r\n    return Attach(hIcon);\r\n}\r\n\r\ninline BOOL MIcon::LoadImageFromFile(HINSTANCE hInstance, LPCTSTR pszName,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    fuLoad |= LR_LOADFROMFILE;\r\n    return LoadImage(hInstance, pszName, cxDesired, cyDesired, fuLoad);\r\n}\r\n\r\ninline BOOL MIcon::CreateIconIndirect(PICONINFO pIconInfo)\r\n{\r\n    return Attach(::CreateIconIndirect(pIconInfo));\r\n}\r\n\r\ninline BOOL MIcon::DestroyIcon()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DestroyIcon(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL MIcon::DrawIcon(HDC hDC, INT x, INT y)\r\n{\r\n    assert(Handle());\r\n    assert(hDC);\r\n    return ::DrawIcon(hDC, x, y, Handle());\r\n}\r\n\r\ninline BOOL MIcon::DrawIconEx(HDC hDC, INT x, INT y,\r\n    INT cx, INT cy, UINT index/* = 0*/, HBRUSH hbr/* = NULL*/,\r\n    UINT uDI_flags/* = DI_NORMAL*/)\r\n{\r\n    assert(Handle());\r\n    assert(hDC);\r\n    return ::DrawIconEx(hDC, x, y, Handle(),\r\n        cx, cy, index, hbr, uDI_flags);\r\n}\r\n\r\ninline BOOL MIcon::GetIconInfo(PICONINFO pIconInfo) const\r\n{\r\n    assert(Handle());\r\n    assert(pIconInfo);\r\n    return ::GetIconInfo(Handle(), pIconInfo);\r\n}\r\n\r\ninline /*static*/ HICON MIcon::CloneHandleDx(HICON hIcon)\r\n{\r\n    if (hIcon == NULL)\r\n        return NULL;\r\n    return ::CopyIcon(hIcon);\r\n}\r\n\r\ninline BOOL MIcon::ExtractIcon(\r\n    LPCTSTR pszFile, UINT nIconIndex, HINSTANCE hInst/* = NULL*/)\r\n{\r\n    HICON hIcon = ::ExtractIcon(hInst, pszFile, nIconIndex);\r\n    if (hIcon == NULL && hInst == NULL)\r\n    {\r\n        hInst = ::GetModuleHandle(NULL);\r\n        hIcon = ::ExtractIcon(hInst, pszFile, nIconIndex);\r\n    }\r\n    return Attach(hIcon);\r\n}\r\n\r\ninline UINT MIcon::GetNumberOfIcons(LPCTSTR pszFile) const\r\n{\r\n    return ::ExtractIconEx(pszFile, -1, NULL, NULL, 0);\r\n}\r\n\r\ninline BOOL MIcon::ExtractIconEx(LPCTSTR pszFile, INT nIconIndex,\r\n    UINT nIcons, HICON *phIcons/* = NULL*/, HICON *phSmallIcons/* = NULL*/)\r\n{\r\n    return ::ExtractIconEx(pszFile, nIconIndex, phIcons, phSmallIcons, nIcons);\r\n}\r\n\r\ninline BOOL MIcon::ExtractAssociatedIcon(\r\n    LPTSTR pszPath, LPWORD pnIndex, HINSTANCE hInst/* = NULL*/)\r\n{\r\n    HICON hIcon = ::ExtractAssociatedIcon(hInst, pszPath, pnIndex);\r\n    if (hIcon == NULL && hInst == NULL)\r\n    {\r\n        hInst = ::GetModuleHandle(NULL);\r\n        hIcon = ::ExtractAssociatedIcon(hInst, pszPath, pnIndex);\r\n    }\r\n    return Attach(hIcon);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MICON_HPP_\r\n
MImageList.hpp<>MImageList.hpp<>// MAccel.hpp -- Win32API accelerator wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MIMAGELIST_HPP_\r\n#define MZC4_MIMAGELIST_HPP_    4       /* Version 4 */\r\n\r\nclass MImageList;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_COMMCTRL\r\n    #include <commctrl.h>   // for image list\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MLibrary.hpp"\r\n\r\nclass MImageList\r\n{\r\npublic:\r\n    HIMAGELIST m_hImageList;\r\n\r\n    MImageList();\r\n    MImageList(HIMAGELIST hImageList);\r\n    MImageList(const MImageList& il);\r\n    MImageList& operator=(HIMAGELIST hImageList);\r\n    MImageList& operator=(const MImageList& ilist);\r\n    virtual ~MImageList();\r\n\r\n    operator HIMAGELIST() const;\r\n\r\n    HIMAGELIST Handle() const;\r\n    BOOL Attach(HIMAGELIST hImageList);\r\n    HIMAGELIST Detach();\r\n\r\n    BOOL Create(INT cx, INT cy, UINT uILC_flags, INT nInitial, INT nGrow);\r\n    BOOL Create(LPCTSTR lpszBitmapID, INT cx, INT nGrow, COLORREF crMask,\r\n                HINSTANCE hInstance = NULL);\r\n    BOOL Merge(HIMAGELIST hIml1, INT nImage1, HIMAGELIST hIml2,\r\n        INT nImage2, INT dx, INT dy);\r\n    BOOL Destroy();\r\n\r\n    INT GetImageCount() const;\r\n    #if (_WIN32_IE >= 0x0300)\r\n        BOOL SetImageCount(UINT uNewCount);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    BOOL GetImageSize(INT *cx, INT *cy) const;\r\n    BOOL SetImageSizeAndClear(INT cx, INT cy);\r\n\r\n    COLORREF GetBkColor() const;\r\n    COLORREF SetBkColor(COLORREF cr);\r\n\r\n    BOOL GetImageInfo(INT nImage, IMAGEINFO* pImageInfo) const;\r\n\r\n    INT Add(HBITMAP hbmImage, HBITMAP hbmMask);\r\n    INT Add(HBITMAP hbmImage, COLORREF crMask);\r\n    BOOL Remove(INT nImage);\r\n    BOOL Replace(INT nImage, HBITMAP hbmImage, HBITMAP hbmMask);\r\n    INT Add(HICON hIcon);\r\n    INT Replace(INT nImage, HICON hIcon);\r\n    HICON ExtractIcon(INT nImage);\r\n\r\n    BOOL Draw(INT nImage, HDC hDC, INT x, INT y, UINT nILD_flags = ILD_NORMAL);\r\n    BOOL Draw(INT nImage, HDC hDC, POINT pt, UINT nILD_flags = ILD_NORMAL);\r\n    BOOL DrawEx(INT nImage, HDC hDC, INT x, INT y, INT dx, INT dy,\r\n        COLORREF rgbBk, COLORREF rgbFg = CLR_NONE, UINT nILD_flags = ILD_NORMAL);\r\n    BOOL DrawEx(INT nImage, HDC hDC, LPCRECT prc, COLORREF rgbBk,\r\n        COLORREF rgbFg = CLR_NONE, UINT nILD_flags = ILD_NORMAL);\r\n    BOOL SetOverlayImage(INT nImage, INT nOverlay);\r\n\r\n    BOOL BeginDrag(INT nImage, INT xHotSpot, INT yHotSpot);\r\n    BOOL BeginDrag(INT nImage, POINT ptHotSpot);\r\n    static VOID EndDrag();\r\n    static BOOL DragMove(INT x, INT y);\r\n    static BOOL DragMove(POINT pt);\r\n    BOOL SetDragCursorImage(INT nDrag, INT xHotSpot, INT yHotSpot);\r\n    BOOL SetDragCursorImage(INT nDrag, POINT ptHotSpot);\r\n    static BOOL DragShowNolock(BOOL bShow = TRUE);\r\n    static HIMAGELIST GetDragImage(LPPOINT ppt, LPPOINT pptHotSpot);\r\n    static BOOL DragEnter(HWND hWnd, POINT pt);\r\n    static BOOL DragEnter(HWND hWnd, INT x, INT y);\r\n    static BOOL DragLeave(HWND hWnd);\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    BOOL Copy(INT iDst, INT iSrc, UINT uILCF_flags = ILCF_MOVE);\r\n    BOOL Copy(INT iDst, HIMAGELIST hImlSrc, INT iSrc,\r\n              UINT uILCF_flags = ILCF_MOVE);\r\n    static BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    static HIMAGELIST CloneHandleDx(HIMAGELIST hImageList);\r\n};\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MImageList::MImageList() : m_hImageList(NULL)\r\n{\r\n}\r\n\r\ninline MImageList::MImageList(HIMAGELIST hImageList)\r\n    : m_hImageList(hImageList)\r\n{\r\n}\r\n\r\ninline /*virtual*/ MImageList::~MImageList()\r\n{\r\n    Destroy();\r\n}\r\n\r\ninline MImageList::MImageList(const MImageList& il)\r\n    : m_hImageList(CloneHandleDx(il))\r\n{\r\n}\r\n\r\ninline MImageList::operator HIMAGELIST() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline HIMAGELIST MImageList::Handle() const\r\n{\r\n    return (this ? m_hImageList : NULL);\r\n}\r\n\r\ninline MImageList& MImageList::operator=(HIMAGELIST hImageList)\r\n{\r\n    if (Handle() != hImageList)\r\n    {\r\n        Attach(hImageList);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MImageList& MImageList::operator=(const MImageList& ilist)\r\n{\r\n    if (Handle() != ilist.Handle())\r\n    {\r\n        HIMAGELIST himl = CloneHandleDx(ilist);\r\n        Attach(himl);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MImageList::Attach(HIMAGELIST hImageList)\r\n{\r\n    Destroy();\r\n    m_hImageList = hImageList;\r\n    return m_hImageList != NULL;\r\n}\r\n\r\ninline HIMAGELIST MImageList::Detach()\r\n{\r\n    HIMAGELIST hImageList = m_hImageList;\r\n    m_hImageList = NULL;\r\n    return hImageList;\r\n}\r\n\r\ninline BOOL MImageList::Create(\r\n    INT cx, INT cy, UINT uILC_flags, INT nInitial, INT nGrow)\r\n{\r\n    return Attach(ImageList_Create(cx, cy, uILC_flags, nInitial, nGrow));\r\n}\r\n\r\ninline BOOL MImageList::Create(LPCTSTR lpszBitmapID,\r\n    INT cx, INT nGrow, COLORREF crMask, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    return Attach(ImageList_LoadBitmap(hInstance, lpszBitmapID, cx, nGrow, crMask));\r\n}\r\n\r\ninline BOOL MImageList::Merge(HIMAGELIST hIml1, INT nImage1,\r\n    HIMAGELIST hIml2, INT nImage2, INT dx, INT dy)\r\n{\r\n    return Attach(ImageList_Merge(hIml1, nImage1, hIml2, nImage2, dx, dy));\r\n}\r\n\r\ninline INT MImageList::GetImageCount() const\r\n{\r\n    assert(Handle());\r\n    return ImageList_GetImageCount(Handle());\r\n}\r\n\r\ninline COLORREF MImageList::SetBkColor(COLORREF cr)\r\n{\r\n    assert(Handle());\r\n    return ImageList_SetBkColor(Handle(), cr);\r\n}\r\n\r\ninline COLORREF MImageList::GetBkColor() const\r\n{\r\n    assert(Handle());\r\n    return ImageList_GetBkColor(Handle());\r\n}\r\n\r\ninline BOOL MImageList::GetImageInfo(\r\n    INT nImage, IMAGEINFO* pImageInfo) const\r\n{\r\n    assert(Handle());\r\n    return ImageList_GetImageInfo(Handle(), nImage, pImageInfo);\r\n}\r\n\r\ninline BOOL MImageList::Destroy()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ImageList_Destroy(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline BOOL MImageList::SetImageCount(UINT uNewCount)\r\n    {\r\n        assert(Handle());\r\n        return ImageList_SetImageCount(Handle(), uNewCount);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline BOOL MImageList::GetImageSize(INT *cx, INT *cy) const\r\n{\r\n    assert(Handle());\r\n    return ImageList_GetIconSize(Handle(), cx, cy);\r\n}\r\n\r\ninline BOOL MImageList::SetImageSizeAndClear(INT cx, INT cy)\r\n{\r\n    assert(Handle());\r\n    return ImageList_SetIconSize(Handle(), cx, cy);\r\n}\r\n\r\ninline INT MImageList::Add(HBITMAP hbmImage, HBITMAP hbmMask)\r\n{\r\n    assert(Handle());\r\n    return ImageList_Add(Handle(), hbmImage, hbmMask);\r\n}\r\n\r\ninline INT MImageList::Add(HBITMAP hbmImage, COLORREF crMask)\r\n{\r\n    assert(Handle());\r\n    return ImageList_AddMasked(Handle(), hbmImage, crMask);\r\n}\r\n\r\ninline BOOL MImageList::Remove(INT nImage)\r\n{\r\n    assert(Handle());\r\n    return ImageList_Remove(Handle(), nImage);\r\n}\r\n\r\ninline BOOL MImageList::Replace(\r\n    INT nImage, HBITMAP hbmImage, HBITMAP hbmMask)\r\n{\r\n    assert(Handle());\r\n    return ImageList_Replace(Handle(), nImage, hbmImage, hbmMask);\r\n}\r\n\r\ninline INT MImageList::Add(HICON hIcon)\r\n{\r\n    assert(Handle());\r\n    return ImageList_AddIcon(Handle(), hIcon);\r\n}\r\n\r\ninline INT MImageList::Replace(INT nImage, HICON hIcon)\r\n{\r\n    assert(Handle());\r\n    return ImageList_ReplaceIcon(Handle(), nImage, hIcon);\r\n}\r\n\r\ninline HICON MImageList::ExtractIcon(INT nImage)\r\n{\r\n    assert(Handle());\r\n    return ImageList_ExtractIcon(NULL, Handle(), nImage);\r\n}\r\n\r\ninline BOOL MImageList::Draw(INT nImage, HDC hDC, INT x, INT y,\r\n    UINT nILD_flags/* = ILD_NORMAL*/)\r\n{\r\n    assert(Handle());\r\n    assert(hDC);\r\n    return ImageList_Draw(Handle(), nImage, hDC, x, y, nILD_flags);\r\n}\r\n\r\ninline BOOL MImageList::Draw(\r\n    INT nImage, HDC hDC, POINT pt, UINT nILD_flags/* = ILD_NORMAL*/)\r\n{\r\n    return Draw(nImage, hDC, pt.x, pt.y, nILD_flags);\r\n}\r\n\r\ninline BOOL MImageList::DrawEx(INT nImage, HDC hDC, INT x, INT y,\r\n    INT dx, INT dy, COLORREF rgbBk, COLORREF rgbFg/* = CLR_NONE*/,\r\n    UINT nILD_flags/* = ILD_NORMAL*/)\r\n{\r\n    assert(Handle());\r\n    assert(hDC);\r\n    return ImageList_DrawEx(Handle(), nImage, hDC, x, y, dx, dy,\r\n                            rgbBk, rgbFg, nILD_flags);\r\n}\r\n\r\ninline BOOL MImageList::DrawEx(INT nImage, HDC hDC, LPCRECT prc,\r\n    COLORREF rgbBk, COLORREF rgbFg/* = CLR_NONE*/,\r\n    UINT nILD_flags/* = ILD_NORMAL*/)\r\n{\r\n    return DrawEx(nImage, hDC, prc->left, prc->top, prc->right - prc->left,\r\n                  prc->bottom - prc->top, rgbBk, rgbFg, nILD_flags);\r\n}\r\n\r\ninline BOOL MImageList::SetOverlayImage(INT nImage, INT nOverlay)\r\n{\r\n    assert(Handle());\r\n    return ImageList_SetOverlayImage(Handle(), nImage, nOverlay);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline BOOL MImageList::Copy(\r\n        INT iDst, INT iSrc, UINT uILCF_flags/* = ILCF_MOVE*/)\r\n    {\r\n        assert(Handle());\r\n        return ImageList_Copy(Handle(), iDst, Handle(), iSrc, uILCF_flags);\r\n    }\r\n    \r\n    inline BOOL MImageList::Copy(INT iDst, HIMAGELIST hImlSrc, INT iSrc,\r\n        UINT uILCF_flags/* = ILCF_MOVE*/)\r\n    {\r\n        assert(Handle());\r\n        assert(hImlSrc != NULL);\r\n        return ImageList_Copy(Handle(), iDst, hImlSrc, iSrc, uILCF_flags);\r\n    }\r\n    \r\n    inline /*static*/ BOOL\r\n    MImageList::DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)\r\n    {\r\n        return ImageList_DrawIndirect(pimldp);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline BOOL MImageList::BeginDrag(INT nImage, INT xHotSpot, INT yHotSpot)\r\n{\r\n    assert(Handle());\r\n    return ImageList_BeginDrag(Handle(), nImage, xHotSpot, yHotSpot);\r\n}\r\n\r\ninline BOOL MImageList::BeginDrag(INT nImage, POINT ptHotSpot)\r\n{\r\n    return BeginDrag(nImage, ptHotSpot.x, ptHotSpot.y);\r\n}\r\n\r\ninline /*static*/ VOID MImageList::EndDrag()\r\n{\r\n    ImageList_EndDrag();\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragMove(INT x, INT y)\r\n{\r\n    return ImageList_DragMove(x, y);\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragMove(POINT pt)\r\n{\r\n    return MImageList::DragMove(pt.x, pt.y);\r\n}\r\n\r\ninline BOOL MImageList::SetDragCursorImage(\r\n    INT nDrag, INT xHotSpot, INT yHotSpot)\r\n{\r\n    assert(Handle());\r\n    return ImageList_SetDragCursorImage(Handle(), nDrag, xHotSpot, yHotSpot);\r\n}\r\n\r\ninline BOOL MImageList::SetDragCursorImage(INT nDrag, POINT ptHotSpot)\r\n{\r\n    return MImageList::SetDragCursorImage(nDrag, ptHotSpot.x, ptHotSpot.y);\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragShowNolock(BOOL bShow/* = TRUE*/)\r\n{\r\n    return ImageList_DragShowNolock(bShow);\r\n}\r\n\r\ninline /*static*/ HIMAGELIST MImageList::GetDragImage(\r\n    LPPOINT ppt, LPPOINT pptHotSpot)\r\n{\r\n    return ImageList_GetDragImage(ppt, pptHotSpot);\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragEnter(HWND hWnd, INT x, INT y)\r\n{\r\n    return ImageList_DragEnter(hWnd, x, y);\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragEnter(HWND hWnd, POINT pt)\r\n{\r\n    return MImageList::DragEnter(hWnd, pt.x, pt.y);\r\n}\r\n\r\ninline /*static*/ BOOL MImageList::DragLeave(HWND hWnd)\r\n{\r\n    return ImageList_DragLeave(hWnd);\r\n}\r\n\r\ninline /*static*/ HIMAGELIST MImageList::CloneHandleDx(HIMAGELIST hImageList)\r\n{\r\n    typedef HIMAGELIST (WINAPI *IMAGELIST_DUPLICATE)(HIMAGELIST);\r\n\r\n    if (hImageList == NULL)\r\n        return NULL;\r\n\r\n    static MLibrary hComCtl32(TEXT("COMCTL32"));\r\n    static IMAGELIST_DUPLICATE fnImageList_Duplicate = NULL;\r\n\r\n    if (fnImageList_Duplicate == NULL)\r\n        hComCtl32.GetProcAddress("ImageList_Duplicate", fnImageList_Duplicate);\r\n    if (fnImageList_Duplicate)\r\n        return (*fnImageList_Duplicate)(hImageList);\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    return NULL;\r\n#else\r\n    INT cx, cy;\r\n    ImageList_GetIconSize(hImageList, &cx, &cy);\r\n    \r\n    HIMAGELIST himlNew = ImageList_Create(cx, cy, ILC_COLOR32 | ILC_MASK, 10, 10);\r\n    if (himlNew == NULL)\r\n        return himlNew;\r\n\r\n    ImageList_SetBkColor(himlNew, CLR_NONE);\r\n    INT nCount = ImageList_GetImageCount(hImageList);\r\n    for(INT i = 0; i < nCount; i++)\r\n    {\r\n        HICON hIcon = ImageList_GetIcon(hImageList, i, ILD_TRANSPARENT);\r\n        if (hIcon == NULL)\r\n        {\r\n            ImageList_Destroy(himlNew);\r\n            return NULL;\r\n        }\r\n        INT iIcon = ImageList_AddIcon(himlNew, hIcon);\r\n        ::DestroyIcon(hIcon);\r\n        if (iIcon < 0)\r\n        {\r\n            ImageList_Destroy(himlNew);\r\n            return NULL;\r\n        }\r\n    }\r\n    return himlNew;\r\n#endif\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MIMAGELIST_HPP_\r\n
MInterProcessShare.hpp<>MInterProcessShare.hpp<>// MInterProcessShare.hpp -- Win32API interprocess shared data  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MINTERPROCESSSHARE_HPP_\r\n#define MZC4_MINTERPROCESSSHARE_HPP_    5   /* Version 5 */\r\n\r\n// class MInterProcessShare<T_DATA>;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T_DATA>\r\nclass MInterProcessShare\r\n{\r\npublic:\r\n    MInterProcessShare();\r\n    MInterProcessShare(const TCHAR *pszName, BOOL *pfAlreadyExists = NULL,\r\n                       SECURITY_ATTRIBUTES *psa = NULL);\r\n    virtual ~MInterProcessShare();\r\n\r\n    BOOL Create(const TCHAR *pszName, BOOL *pfAlreadyExists = NULL,\r\n                SECURITY_ATTRIBUTES *psa = NULL);\r\n    void Close();\r\n\r\n    operator bool() const;\r\n    bool operator!() const;\r\n\r\n    T_DATA* Lock(DWORD dwTimeout = 1500);\r\n    BOOL Unlock();\r\n    BOOL IsLocked() const;\r\n\r\n          HANDLE& Handle();\r\n    const HANDLE& Handle() const;\r\n\r\n          HANDLE& MutexHandle();\r\n    const HANDLE& MutexHandle() const;\r\n\r\nprotected:\r\n    HANDLE m_hMutex;\r\n    HANDLE m_hFileMapping;\r\n    T_DATA *m_pData;\r\n};\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T_DATA>\r\ninline MInterProcessShare<T_DATA>::MInterProcessShare() :\r\n    m_hMutex(NULL), m_hFileMapping(NULL), m_pData(NULL)\r\n{\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline MInterProcessShare<T_DATA>::MInterProcessShare(\r\n    const TCHAR *pszName, BOOL *pfAlreadyExists/* = NULL*/,\r\n    SECURITY_ATTRIBUTES *psa/* = NULL*/)\r\n    : m_hMutex(NULL), m_hFileMapping(NULL), m_pData(NULL)\r\n{\r\n    Create(pszName, pfAlreadyExists, psa);\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline /*virtual*/ MInterProcessShare<T_DATA>::~MInterProcessShare()\r\n{\r\n    Close();\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline HANDLE& MInterProcessShare<T_DATA>::MutexHandle()\r\n{\r\n    return m_hMutex;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline const HANDLE& MInterProcessShare<T_DATA>::MutexHandle() const\r\n{\r\n    return m_hMutex;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline HANDLE& MInterProcessShare<T_DATA>::Handle()\r\n{\r\n    return m_hFileMapping;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline const HANDLE& MInterProcessShare<T_DATA>::Handle() const\r\n{\r\n    return m_hFileMapping;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline BOOL MInterProcessShare<T_DATA>::IsLocked() const\r\n{\r\n    return m_pData != NULL;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\nMInterProcessShare<T_DATA>::operator bool() const\r\n{\r\n    return m_hMutex != NULL;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline bool MInterProcessShare<T_DATA>::operator!() const\r\n{\r\n    return !m_hMutex;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\nBOOL MInterProcessShare<T_DATA>::Create(\r\n    const TCHAR *pszName, BOOL *pfAlreadyExists/* = NULL*/,\r\n    SECURITY_ATTRIBUTES *psa/* = NULL*/)\r\n{\r\n    Close();\r\n\r\n    if (pfAlreadyExists)\r\n    {\r\n        *pfAlreadyExists = FALSE;\r\n    }\r\n\r\n    // mutex name\r\n    TCHAR szName[MAX_PATH];\r\n    lstrcpyn(szName, pszName, MAX_PATH);\r\n    lstrcat(szName, TEXT(" Mutex"));\r\n\r\n    m_hMutex = ::CreateMutex(psa, TRUE, szName);\r\n    if (!m_hMutex)\r\n    {\r\n        return FALSE;\r\n    }\r\n\r\n    // file mapping name\r\n    lstrcpyn(szName, pszName, MAX_PATH);\r\n    lstrcat(szName, TEXT(" FileMapping"));\r\n\r\n    m_hFileMapping = ::CreateFileMapping(INVALID_HANDLE_VALUE,\r\n        psa, PAGE_READWRITE, 0, sizeof(T_DATA), szName);\r\n    if (!m_hFileMapping)\r\n    {\r\n        Close();\r\n        return FALSE;\r\n    }\r\n    DWORD dwError = ::GetLastError();\r\n\r\n    ::ReleaseMutex(m_hMutex);\r\n\r\n    if (dwError == ERROR_ALREADY_EXISTS && pfAlreadyExists)\r\n    {\r\n        *pfAlreadyExists = TRUE;\r\n    }\r\n\r\n    return TRUE;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\nvoid MInterProcessShare<T_DATA>::Close()\r\n{\r\n    if (IsLocked())\r\n    {\r\n        Unlock();\r\n    }\r\n\r\n    if (m_hFileMapping)\r\n    {\r\n        BOOL bRet = ::CloseHandle(m_hFileMapping);\r\n        assert(bRet);\r\n        m_hFileMapping = NULL;\r\n    }\r\n\r\n    if (m_hMutex)\r\n    {\r\n        BOOL bRet = ::CloseHandle(m_hMutex);\r\n        assert(bRet);\r\n        m_hMutex = NULL;\r\n    }\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline T_DATA* MInterProcessShare<T_DATA>::Lock(DWORD dwTimeout/* = 1500*/)\r\n{\r\n    assert(!IsLocked());\r\n\r\n    if (IsLocked())\r\n        return m_pData;\r\n\r\n    if (::WaitForSingleObject(m_hMutex, dwTimeout) != WAIT_OBJECT_0)\r\n        return NULL;\r\n\r\n    m_pData = reinterpret_cast<T_DATA *>(::MapViewOfFile(\r\n        m_hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(T_DATA)));\r\n    assert(m_pData);\r\n\r\n    return m_pData;\r\n}\r\n\r\ntemplate <typename T_DATA>\r\ninline BOOL MInterProcessShare<T_DATA>::Unlock()\r\n{\r\n    if (!IsLocked())\r\n        return FALSE;\r\n\r\n    BOOL bRet = ::FlushViewOfFile(m_pData, sizeof(T_DATA));\r\n    assert(bRet);\r\n\r\n    bRet = ::UnmapViewOfFile(m_pData);\r\n    assert(bRet);\r\n\r\n    m_pData = NULL;\r\n\r\n    bRet = ::ReleaseMutex(m_hMutex);\r\n    assert(bRet);\r\n\r\n    return bRet;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MINTERPROCESSSHARE_HPP_\r\n
MLibrary.hpp<>MLibrary.hpp<>// MLibrary.hpp -- Win32API DLL loader class                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MLIBRARY_HPP_\r\n#define MZC4_MLIBRARY_HPP_      3   /* Version 3 */\r\n\r\nclass MLibrary;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <shlwapi.h>        // DLLVERSIONINFO, DLLVERSIONINFO2\r\n#include <cassert>          // assert\r\n#include <mbstring.h>       // _mbsrchr\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MLibrary\r\n{\r\npublic:\r\n    MLibrary();\r\n    MLibrary(HINSTANCE hInstance);\r\n    MLibrary(LPCTSTR pszFileName);\r\n    MLibrary(LPCTSTR pszFileName, DWORD dwFlags);\r\n    virtual ~MLibrary();\r\n\r\n    BOOL Attach(HINSTANCE hInstance);\r\n    HINSTANCE Detach();\r\n    HINSTANCE Handle() const;\r\n\r\n    bool operator!() const;\r\n    operator HINSTANCE() const;\r\n    MLibrary& operator=(HINSTANCE hInstance);\r\n\r\n    BOOL LoadLibrary(LPCTSTR pszFileName);\r\n    BOOL LoadLibraryEx(LPCTSTR pszFileName, DWORD dwFlags);\r\n    BOOL LoadLocalLibrary(LPCTSTR pszFileName);\r\n    BOOL LoadLocalLibraryEx(LPCTSTR pszFileName, DWORD dwFlags);\r\n    BOOL LoadSystemLibrary(LPCTSTR pszFileName);\r\n    BOOL LoadSystemLibraryEx(LPCTSTR pszFileName, DWORD dwFlags);\r\n    BOOL FreeLibrary();\r\n\r\n    FARPROC GetProcAddress(LPCSTR pszProcName);\r\n    template <typename T_PROC>\r\n    BOOL GetProcAddress(LPCSTR pszProcName, T_PROC& proc);\r\n    BOOL GetModuleHandle(LPCTSTR pszFileName);\r\n    BOOL GetModuleFileName(LPTSTR pszFileName, DWORD cch = MAX_PATH);\r\n\r\n    HRESULT GetDllVersion(DLLVERSIONINFO *info);\r\n#if (_WIN32_IE >= 0x0501)\r\n    HRESULT GetDllVersion(DLLVERSIONINFO2 *info);\r\n#endif\r\n\r\n    HICON   LoadIcon(LPCTSTR pszName);\r\n    HICON   LoadIcon(UINT nID);\r\n    HICON   LoadSmallIcon(LPCTSTR pszName);\r\n    HICON   LoadSmallIcon(UINT nID);\r\n    HCURSOR LoadCursor(LPCTSTR pszName);\r\n    HCURSOR LoadCursor(UINT nID);\r\n    HBITMAP LoadBitmap(LPCTSTR pszName);\r\n    HBITMAP LoadBitmap(UINT nID);\r\n    HANDLE  LoadImage(LPCTSTR pszName, UINT uType,\r\n        INT cxDesired = 0, INT cyDesired = 0, UINT fuLoad = 0);\r\n    HANDLE  LoadImage(UINT nID, UINT uType,\r\n        INT cxDesired = 0, INT cyDesired = 0, UINT fuLoad = 0);\r\n    HMENU   LoadMenu(LPCTSTR pszName);\r\n    HMENU   LoadMenu(UINT nID);\r\n    INT     LoadString(UINT nID, LPTSTR pszBuffer, INT cchBuffer);\r\n    HACCEL  LoadAccelerators(LPCTSTR pszName);\r\n    HACCEL  LoadAccelerators(UINT nID);\r\n\r\n    HRSRC   FindResource(LPCTSTR pszName, LPCTSTR pszType);\r\n    HRSRC   FindResource(LPCTSTR pszName, UINT nType);\r\n    HRSRC   FindResource(UINT nID, LPCTSTR pszType);\r\n    HRSRC   FindResource(UINT nID, UINT nType);\r\n    HRSRC   FindResourceEx(LPCTSTR pszName, LPCTSTR pszType, WORD wLanguage);\r\n    HRSRC   FindResourceEx(LPCTSTR pszName, UINT nType, WORD wLanguage);\r\n    HRSRC   FindResourceEx(UINT nID, LPCTSTR pszType, WORD wLanguage);\r\n    HRSRC   FindResourceEx(UINT nID, UINT nType, WORD wLanguage);\r\n    HGLOBAL LoadResource(HRSRC hRsrc);\r\n    DWORD   SizeofResource(HRSRC hRsrc);\r\n\r\nprotected:\r\n    HINSTANCE m_hInstance;\r\n\r\nprivate:\r\n    // NOTE: MLibrary is not copyable.\r\n    MLibrary(const MLibrary& lib);\r\n    MLibrary& operator=(const MLibrary& lib);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#define MakeDllVerULLDx(major,minor,build,qfe) \\\r\n    MAKEDLLVERULL((major),(minor),(build),(qfe))\r\n\r\nHINSTANCE LoadLocalLibraryDx(LPCTSTR pszFileName);\r\nHINSTANCE LoadSystemLibraryDx(LPCTSTR pszFileName);\r\nHINSTANCE LoadLocalLibraryDx(LPCTSTR pszFileName, DWORD dwFlags);\r\nHINSTANCE LoadSystemLibraryDx(LPCTSTR pszFileName, DWORD dwFlags);\r\nHRESULT GetDllVersionDx(LPCTSTR pszDLL, DLLVERSIONINFO* info);\r\n#if (_WIN32_IE >= 0x0501)\r\n    HRESULT GetDllVersion2Dx(LPCTSTR pszDLL, DLLVERSIONINFO2* info);\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MLibrary::MLibrary() : m_hInstance(NULL)\r\n{\r\n}\r\n\r\ninline MLibrary::MLibrary(HINSTANCE hInstance) : m_hInstance(hInstance)\r\n{\r\n}\r\n\r\ninline MLibrary::MLibrary(LPCTSTR pszFileName)\r\n    : m_hInstance(::LoadLibrary(pszFileName))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline MLibrary::MLibrary(LPCTSTR pszFileName, DWORD dwFlags)\r\n    : m_hInstance(::LoadLibraryEx(pszFileName, NULL, dwFlags))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline /*virtual*/ MLibrary::~MLibrary()\r\n{\r\n    FreeLibrary();\r\n}\r\n\r\ninline MLibrary& MLibrary::operator=(HINSTANCE hInstance)\r\n{\r\n#ifndef NDEBUG\r\n    TCHAR szFileName[MAX_PATH];\r\n    assert(hInstance == NULL || ::GetModuleFileName(hInstance, szFileName, MAX_PATH));\r\n#endif\r\n    if (Handle() != hInstance)\r\n    {\r\n        Attach(hInstance);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MLibrary::Attach(HINSTANCE hInstance)\r\n{\r\n    FreeLibrary();\r\n    m_hInstance = hInstance;\r\n#ifndef NDEBUG\r\n    TCHAR szFileName[MAX_PATH];\r\n    assert(::GetModuleFileName(m_hInstance, szFileName, MAX_PATH));\r\n#endif\r\n    return m_hInstance != NULL;\r\n}\r\n\r\ninline HINSTANCE MLibrary::Detach()\r\n{\r\n    HINSTANCE hInstance = m_hInstance;\r\n    m_hInstance = NULL;\r\n    return hInstance;\r\n}\r\n\r\ninline HINSTANCE MLibrary::Handle() const\r\n{\r\n    return (this ? m_hInstance : NULL);\r\n}\r\n\r\ninline BOOL MLibrary::LoadLibrary(LPCTSTR pszFileName)\r\n{\r\n    return Attach(::LoadLibrary(pszFileName));\r\n}\r\n\r\ninline BOOL MLibrary::LoadLibraryEx(LPCTSTR pszFileName, DWORD dwFlags)\r\n{\r\n    return Attach(::LoadLibraryEx(pszFileName, NULL, dwFlags));\r\n}\r\n\r\ninline BOOL MLibrary::LoadLocalLibrary(LPCTSTR pszFileName)\r\n{\r\n    return Attach(LoadLocalLibraryDx(pszFileName));\r\n}\r\n\r\ninline BOOL MLibrary::LoadLocalLibraryEx(LPCTSTR pszFileName, DWORD dwFlags)\r\n{\r\n    return Attach(LoadLocalLibraryDx(pszFileName, dwFlags));\r\n}\r\n\r\ninline BOOL MLibrary::LoadSystemLibrary(LPCTSTR pszFileName)\r\n{\r\n    return Attach(LoadSystemLibraryDx(pszFileName));\r\n}\r\n\r\ninline BOOL MLibrary::LoadSystemLibraryEx(LPCTSTR pszFileName, DWORD dwFlags)\r\n{\r\n    return Attach(LoadSystemLibraryDx(pszFileName, dwFlags));\r\n}\r\n\r\ninline BOOL MLibrary::FreeLibrary()\r\n{\r\n    if (m_hInstance)\r\n    {\r\n        BOOL bOK = ::FreeLibrary(m_hInstance);\r\n        m_hInstance = NULL;\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline FARPROC MLibrary::GetProcAddress(LPCSTR pszProcName)\r\n{\r\n    assert(Handle());\r\n    return ::GetProcAddress(Handle(), pszProcName);\r\n}\r\n\r\ninline BOOL MLibrary::GetModuleHandle(LPCTSTR pszFileName)\r\n{\r\n    return Attach(::GetModuleHandle(pszFileName));\r\n}\r\n\r\ninline BOOL MLibrary::GetModuleFileName(LPTSTR pszFileName, DWORD cch/* = MAX_PATH*/)\r\n{\r\n    return ::GetModuleFileName(Handle(), pszFileName, cch);\r\n}\r\n\r\ninline bool MLibrary::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline MLibrary::operator HINSTANCE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0501)\r\n    inline HRESULT MLibrary::GetDllVersion(DLLVERSIONINFO2 *info)\r\n    {\r\n        return MLibrary::GetDllVersion(reinterpret_cast<DLLVERSIONINFO *>(info));\r\n    }\r\n#endif\r\n\r\ninline HRESULT GetDllVersionDx(LPCTSTR pszDLL, DLLVERSIONINFO* info)\r\n{\r\n    assert(info);\r\n    MLibrary lib(pszDLL);\r\n    return lib.GetDllVersion(info);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0501)\r\n    inline HRESULT GetDllVersion2Dx(LPCTSTR pszDLL, DLLVERSIONINFO2* info)\r\n    {\r\n        assert(info);\r\n        MLibrary lib(pszDLL);\r\n        return lib.GetDllVersion(info);\r\n    }\r\n#endif\r\n\r\ninline HICON MLibrary::LoadIcon(LPCTSTR pszName)\r\n{\r\n    return ::LoadIcon(Handle(), pszName);\r\n}\r\n\r\ninline HICON MLibrary::LoadIcon(UINT nID)\r\n{\r\n    return LoadIcon(MAKEINTRESOURCE(nID));\r\n}\r\n\r\ninline HCURSOR MLibrary::LoadCursor(LPCTSTR pszName)\r\n{\r\n    return ::LoadCursor(Handle(), pszName);\r\n}\r\n\r\ninline HCURSOR MLibrary::LoadCursor(UINT nID)\r\n{\r\n    return LoadCursor(MAKEINTRESOURCE(nID));\r\n}\r\n\r\ninline HBITMAP MLibrary::LoadBitmap(LPCTSTR pszName)\r\n{\r\n    return ::LoadBitmap(Handle(), pszName);\r\n}\r\n\r\ninline HBITMAP MLibrary::LoadBitmap(UINT nID)\r\n{\r\n    return LoadBitmap(MAKEINTRESOURCE(nID));\r\n}\r\n\r\ninline HANDLE MLibrary::LoadImage(LPCTSTR pszName, UINT uType,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    return ::LoadImage(Handle(), pszName, uType, cxDesired, cyDesired, fuLoad);\r\n}\r\n\r\ninline HANDLE MLibrary::LoadImage(UINT nID, UINT uType,\r\n    INT cxDesired/* = 0*/, INT cyDesired/* = 0*/, UINT fuLoad/* = 0*/)\r\n{\r\n    return LoadImage(MAKEINTRESOURCE(nID), uType, cxDesired, cyDesired, fuLoad);\r\n}\r\n\r\ninline HMENU MLibrary::LoadMenu(LPCTSTR pszName)\r\n{\r\n    assert(Handle());\r\n    return ::LoadMenu(Handle(), pszName);\r\n}\r\n\r\ninline HMENU MLibrary::LoadMenu(UINT nID)\r\n{\r\n    return LoadMenu(MAKEINTRESOURCE(nID));\r\n}\r\n\r\ninline INT MLibrary::LoadString(UINT nID, LPTSTR pszBuffer, INT cchBuffer)\r\n{\r\n    assert(Handle());\r\n    return ::LoadString(Handle(), nID, pszBuffer, cchBuffer);\r\n}\r\n\r\ninline HACCEL MLibrary::LoadAccelerators(LPCTSTR pszName)\r\n{\r\n    assert(Handle());\r\n    return ::LoadAccelerators(Handle(), pszName);\r\n}\r\n\r\ninline HACCEL MLibrary::LoadAccelerators(UINT nID)\r\n{\r\n    assert(Handle());\r\n    return LoadAccelerators(MAKEINTRESOURCE(nID));\r\n}\r\n\r\ninline HRSRC MLibrary::FindResource(LPCTSTR pszName, LPCTSTR pszType)\r\n{\r\n    return ::FindResource(Handle(), pszName, pszType);\r\n}\r\n\r\ninline HRSRC MLibrary::FindResource(LPCTSTR pszName, UINT nType)\r\n{\r\n    return FindResource(pszName, MAKEINTRESOURCE(nType));\r\n}\r\n\r\ninline HRSRC MLibrary::FindResource(UINT nID, LPCTSTR pszType)\r\n{\r\n    return FindResource(MAKEINTRESOURCE(nID), pszType);\r\n}\r\n\r\ninline HRSRC MLibrary::FindResource(UINT nID, UINT nType)\r\n{\r\n    return FindResource(MAKEINTRESOURCE(nID), MAKEINTRESOURCE(nType));\r\n}\r\n\r\ninline HRSRC MLibrary::FindResourceEx(LPCTSTR pszName, LPCTSTR pszType, WORD wLanguage)\r\n{\r\n    return ::FindResourceEx(Handle(), pszName, pszType, wLanguage);\r\n}\r\n\r\ninline HRSRC MLibrary::FindResourceEx(LPCTSTR pszName, UINT nType, WORD wLanguage)\r\n{\r\n    return FindResourceEx(pszName, MAKEINTRESOURCE(nType), wLanguage);\r\n}\r\n\r\ninline HRSRC MLibrary::FindResourceEx(UINT nID, LPCTSTR pszType, WORD wLanguage)\r\n{\r\n    return FindResourceEx(MAKEINTRESOURCE(nID), pszType, wLanguage);\r\n}\r\n\r\ninline HRSRC MLibrary::FindResourceEx(UINT nID, UINT nType, WORD wLanguage)\r\n{\r\n    return FindResourceEx(MAKEINTRESOURCE(nID), MAKEINTRESOURCE(nType), wLanguage);\r\n}\r\n\r\ninline HGLOBAL MLibrary::LoadResource(HRSRC hRsrc)\r\n{\r\n    return ::LoadResource(Handle(), hRsrc);\r\n}\r\n\r\ninline DWORD MLibrary::SizeofResource(HRSRC hRsrc)\r\n{\r\n    assert(Handle());\r\n    return ::SizeofResource(Handle(), hRsrc);\r\n}\r\n\r\ninline HICON MLibrary::LoadSmallIcon(LPCTSTR pszName)\r\n{\r\n    return (HICON)LoadImage(pszName, IMAGE_ICON,\r\n        ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON),\r\n        0);\r\n}\r\n\r\ninline HICON MLibrary::LoadSmallIcon(UINT nID)\r\n{\r\n    return (HICON)LoadImage(MAKEINTRESOURCE(nID), IMAGE_ICON,\r\n        ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON),\r\n        0);\r\n}\r\n\r\ntemplate <typename T_PROC>\r\ninline BOOL MLibrary::GetProcAddress(LPCSTR pszProcName, T_PROC& proc)\r\n{\r\n    proc = (T_PROC)GetProcAddress(pszProcName);\r\n    return proc != NULL;\r\n}\r\n\r\ninline HINSTANCE LoadLocalLibraryDx(LPCTSTR pszFileName)\r\n{\r\n    TCHAR szPath[MAX_PATH];\r\n    ::GetModuleFileName(NULL, szPath, MAX_PATH);\r\n    #ifdef UNICODE\r\n        LPWSTR pch = wcsrchr(szPath, L'\\\\');\r\n    #else\r\n        LPSTR pch = reinterpret_cast<LPSTR>(\r\n            _mbsrchr(reinterpret_cast<LPBYTE>(szPath), '\\\\'));\r\n    #endif\r\n    assert(pch != NULL);\r\n    pch++;\r\n    lstrcpy(pch, pszFileName);\r\n    HINSTANCE hInstance = ::LoadLibrary(szPath);\r\n    return hInstance;\r\n}\r\n\r\ninline HINSTANCE LoadSystemLibraryDx(LPCTSTR pszFileName)\r\n{\r\n    TCHAR szPath[MAX_PATH];\r\n    ::GetSystemDirectory(szPath, MAX_PATH);\r\n    lstrcat(szPath, TEXT("\\\\"));\r\n    lstrcat(szPath, pszFileName);\r\n    HINSTANCE hInstance = ::LoadLibrary(szPath);\r\n    return hInstance;\r\n}\r\n\r\ninline HINSTANCE LoadLocalLibraryDx(LPCTSTR pszFileName, DWORD dwFlags)\r\n{\r\n    TCHAR szPath[MAX_PATH];\r\n    ::GetModuleFileName(NULL, szPath, MAX_PATH);\r\n    #ifdef UNICODE\r\n        LPWSTR pch = wcsrchr(szPath, L'\\\\');\r\n    #else\r\n        LPSTR pch = reinterpret_cast<LPSTR>(\r\n            _mbsrchr(reinterpret_cast<LPBYTE>(szPath), '\\\\'));\r\n    #endif\r\n    assert(pch != NULL);\r\n    pch++;\r\n    lstrcpy(pch, pszFileName);\r\n    HINSTANCE hInstance = ::LoadLibraryEx(szPath, NULL, dwFlags);\r\n    return hInstance;\r\n}\r\n\r\ninline HINSTANCE LoadSystemLibraryDx(LPCTSTR pszFileName, DWORD dwFlags)\r\n{\r\n    TCHAR szPath[MAX_PATH];\r\n    ::GetSystemDirectory(szPath, MAX_PATH);\r\n    lstrcat(szPath, TEXT("\\\\"));\r\n    lstrcat(szPath, pszFileName);\r\n    HINSTANCE hInstance = ::LoadLibraryEx(szPath, NULL, dwFlags);\r\n    return hInstance;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MLIBRARY_HPP_\r\n
MListBox.hpp<>MListBox.hpp<>// MListBox.hpp -- Win32API list box wrapper                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MLISTBOX_HPP_\r\n#define MZC4_MLISTBOX_HPP_      4   /* Version 4 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MListBox : public MWindowBase\r\n{\r\npublic:\r\n    MListBox();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetCount() const;\r\n    INT GetHorizontalExtent() const;\r\n    VOID SetHorizontalExtent(INT cxExtent);\r\n    BOOL IsEmpty() const;\r\n\r\n    INT GetTopIndex() const;\r\n    INT SetTopIndex(INT nIndex);\r\n\r\n    LCID GetLocale() const;\r\n    LCID SetLocale(LCID nNewLocale);\r\n\r\n    INT InitStorage(INT nItems, UINT nBytes);\r\n    INT ItemFromPoint(POINT pt, BOOL& bOutside) const;\r\n\r\n    INT GetCurSel() const;\r\n    INT SetCurSel(INT nSelect);\r\n\r\n    INT GetSel(INT nIndex) const;\r\n    INT SetSel(INT nIndex, BOOL bSelect = TRUE);\r\n\r\n    INT GetSelCount() const;\r\n    INT GetSelItems(INT nMaxItems, LPINT rgIndex) const;\r\n\r\n    INT GetAnchorIndex() const;\r\n    VOID SetAnchorIndex(INT nIndex);\r\n\r\n    DWORD GetItemData(INT nIndex) const;\r\n    INT SetItemData(INT nIndex, DWORD dwItemData);\r\n\r\n    LPVOID GetItemDataPtr(INT nIndex) const;\r\n    INT SetItemDataPtr(INT nIndex, LPVOID pData);\r\n\r\n    INT GetItemRect(INT nIndex, LPRECT prc) const;\r\n    INT GetText(INT nIndex, LPTSTR lpszBuffer) const;\r\n    BOOL GetText(INT nIndex, MString& rString) const;\r\n    INT GetTextLen(INT nIndex) const;\r\n\r\n    VOID SetColumnWidth(INT cxWidth);\r\n    BOOL SetTabStops(INT nTabStops, LPINT rgTabStops);\r\n    VOID SetTabStops();\r\n    BOOL SetTabStops(const INT& cxEachStop);\r\n\r\n    INT GetItemHeight(INT nIndex) const;\r\n    INT SetItemHeight(INT nIndex, UINT cyItemHeight);\r\n\r\n    INT GetCaretIndex() const;\r\n    INT SetCaretIndex(INT nIndex, BOOL bScroll = TRUE);\r\n\r\n    INT AddString(LPCTSTR lpszItem);\r\n    INT DeleteString(INT nIndex);\r\n    INT InsertString(INT nIndex, LPCTSTR lpszItem);\r\n    VOID ResetContent();\r\n    INT Dir(UINT attr, LPCTSTR lpszWildCard);\r\n\r\n    INT FindString(INT nStartAfter, LPCTSTR lpszItem) const;\r\n    INT FindStringExact(INT nIndexStart, LPCTSTR lpszFind) const;\r\n\r\n    INT SelectString(INT nStartAfter, LPCTSTR lpszItem);\r\n    INT SelItemRange(BOOL bSelect, INT nFirstItem, INT nLastItem);\r\n    VOID SelectAll();\r\n    VOID SelectNone();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MListBox::MListBox()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MListBox::GetWndClassNameDx() const\r\n{\r\n    return TEXT("LISTBOX");\r\n}\r\n\r\ninline INT MListBox::GetCount() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETCOUNT);\r\n}\r\n\r\ninline INT MListBox::GetSel(INT nIndex) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETSEL, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::SetSel(INT nIndex, BOOL bSelect/* = TRUE*/)\r\n{\r\n    return (INT)SendMessageDx(LB_SETSEL, (WPARAM)bSelect, (LPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::GetHorizontalExtent() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETHORIZONTALEXTENT);\r\n}\r\n\r\ninline VOID MListBox::SetHorizontalExtent(INT cxExtent)\r\n{\r\n    SendMessageDx(LB_SETHORIZONTALEXTENT, (WPARAM)cxExtent);\r\n}\r\n\r\ninline BOOL MListBox::IsEmpty() const\r\n{\r\n    return GetCount() == 0;\r\n}\r\n\r\ninline INT MListBox::GetTopIndex() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETTOPINDEX);\r\n}\r\n\r\ninline INT MListBox::SetTopIndex(INT nIndex)\r\n{\r\n    return (INT)SendMessageDx(LB_SETTOPINDEX, (WPARAM)nIndex);\r\n}\r\n\r\ninline LCID MListBox::GetLocale() const\r\n{\r\n    return (LCID)SendMessageDx(LB_GETLOCALE);\r\n}\r\n\r\ninline LCID MListBox::SetLocale(LCID nNewLocale)\r\n{\r\n    return (LCID)SendMessageDx(LB_SETLOCALE, (WPARAM)nNewLocale);\r\n}\r\n\r\ninline INT MListBox::InitStorage(INT nItems, UINT nBytes)\r\n{\r\n    return (INT)SendMessageDx(LB_INITSTORAGE, (WPARAM)nItems, (LPARAM)nBytes);\r\n}\r\n\r\ninline INT MListBox::ItemFromPoint(POINT pt, BOOL& bOutside) const\r\n{\r\n    DWORD dw = (DWORD)SendMessageDx(LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));\r\n    bOutside = (BOOL) HIWORD(dw);\r\n    return (INT) (SHORT) LOWORD(dw);\r\n}\r\n\r\ninline INT MListBox::GetCurSel() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETCURSEL);\r\n}\r\n\r\ninline INT MListBox::SetCurSel(INT nSelect)\r\n{\r\n    return (INT)SendMessageDx(LB_SETCURSEL, (WPARAM)nSelect);\r\n}\r\n\r\ninline INT MListBox::GetSelCount() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETSELCOUNT);\r\n}\r\n\r\ninline INT MListBox::GetSelItems(INT nMaxItems, LPINT rgIndex) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETSELITEMS, (WPARAM)nMaxItems, (LPARAM)rgIndex);\r\n}\r\n\r\ninline VOID MListBox::SetAnchorIndex(INT nIndex)\r\n{\r\n    SendMessageDx(LB_SETANCHORINDEX, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::GetAnchorIndex() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETANCHORINDEX);\r\n}\r\n\r\ninline DWORD MListBox::GetItemData(INT nIndex) const\r\n{\r\n    return (DWORD)SendMessageDx(LB_GETITEMDATA, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::SetItemData(INT nIndex, DWORD dwItemData)\r\n{\r\n    return (INT)SendMessageDx(LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)dwItemData);\r\n}\r\n\r\ninline LPVOID MListBox::GetItemDataPtr(INT nIndex) const\r\n{\r\n    return (LPVOID)SendMessageDx(LB_GETITEMDATA, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::SetItemDataPtr(INT nIndex, LPVOID pData)\r\n{\r\n    return (INT)SendMessageDx(LB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)pData);\r\n}\r\n\r\ninline INT MListBox::GetItemRect(INT nIndex, LPRECT prc) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETITEMRECT, (WPARAM)nIndex, (LPARAM)prc);\r\n}\r\n\r\ninline INT MListBox::GetText(INT nIndex, LPTSTR lpszBuffer) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETTEXT, (WPARAM)nIndex, (LPARAM)lpszBuffer);\r\n}\r\n\r\ninline INT MListBox::GetTextLen(INT nIndex) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETTEXTLEN, (WPARAM)nIndex);\r\n}\r\n\r\ninline VOID MListBox::SetColumnWidth(INT cxWidth)\r\n{\r\n    SendMessageDx(LB_SETCOLUMNWIDTH, (WPARAM)cxWidth);\r\n}\r\n\r\ninline BOOL MListBox::SetTabStops(INT nTabStops, LPINT rgTabStops)\r\n{\r\n    return (BOOL)SendMessageDx(LB_SETTABSTOPS, (WPARAM)nTabStops, (LPARAM)rgTabStops);\r\n}\r\n\r\ninline VOID MListBox::SetTabStops()\r\n{\r\n    SendMessageDx(LB_SETTABSTOPS);\r\n}\r\n\r\ninline BOOL MListBox::SetTabStops(const INT& cxEachStop)\r\n{\r\n    return (BOOL)SendMessageDx(LB_SETTABSTOPS, 1, (LPARAM)&cxEachStop);\r\n}\r\n\r\ninline INT MListBox::SetItemHeight(INT nIndex, UINT cyItemHeight)\r\n{\r\n    return (INT)SendMessageDx(LB_SETITEMHEIGHT, (WPARAM)nIndex, (LPARAM)cyItemHeight);\r\n}\r\n\r\ninline INT MListBox::GetItemHeight(INT nIndex) const\r\n{\r\n    return (INT)SendMessageDx(LB_GETITEMHEIGHT, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::FindStringExact(\r\n    INT nIndexStart, LPCTSTR lpszFind) const\r\n{\r\n    return (INT)SendMessageDx(LB_FINDSTRINGEXACT, (WPARAM)nIndexStart, (LPARAM)lpszFind);\r\n}\r\n\r\ninline INT MListBox::GetCaretIndex() const\r\n{\r\n    return (INT)SendMessageDx(LB_GETCARETINDEX);\r\n}\r\n\r\ninline INT MListBox::SetCaretIndex(INT nIndex, BOOL bScroll/* = TRUE*/)\r\n{\r\n    return (INT)SendMessageDx(LB_SETCARETINDEX, (WPARAM)nIndex, (LPARAM)bScroll);\r\n}\r\n\r\ninline INT MListBox::AddString(LPCTSTR lpszItem)\r\n{\r\n    return (INT)SendMessageDx(LB_ADDSTRING, 0, (LPARAM)lpszItem);\r\n}\r\n\r\ninline INT MListBox::DeleteString(INT nIndex)\r\n{\r\n    return (INT)SendMessageDx(LB_DELETESTRING, (WPARAM)nIndex);\r\n}\r\n\r\ninline INT MListBox::InsertString(INT nIndex, LPCTSTR lpszItem)\r\n{\r\n    return (INT)SendMessageDx(LB_INSERTSTRING, (WPARAM)nIndex, (LPARAM)lpszItem);\r\n}\r\n\r\ninline VOID MListBox::ResetContent()\r\n{\r\n    SendMessageDx(LB_RESETCONTENT);\r\n}\r\n\r\ninline INT MListBox::Dir(UINT attr, LPCTSTR lpszWildCard)\r\n{\r\n    return (INT)SendMessageDx(LB_DIR, attr, (LPARAM)lpszWildCard);\r\n}\r\n\r\ninline INT MListBox::FindString(INT nStartAfter, LPCTSTR lpszItem) const\r\n{\r\n    return (INT)SendMessageDx(LB_FINDSTRING, (WPARAM)nStartAfter, (LPARAM)lpszItem);\r\n}\r\n\r\ninline INT MListBox::SelectString(INT nStartAfter, LPCTSTR lpszItem)\r\n{\r\n    return (INT)SendMessageDx(LB_SELECTSTRING, (WPARAM)nStartAfter, (LPARAM)lpszItem);\r\n}\r\n\r\ninline INT MListBox::SelItemRange(BOOL bSelect, INT nFirstItem, INT nLastItem)\r\n{\r\n    return (INT)SendMessageDx(LB_SELITEMRANGE, (WPARAM)bSelect, MAKELPARAM(nFirstItem, nLastItem));\r\n}\r\n\r\ninline VOID MListBox::SelectAll()\r\n{\r\n    SelItemRange(TRUE, 0, GetCount());\r\n}\r\n\r\ninline VOID MListBox::SelectNone()\r\n{\r\n    SelItemRange(FALSE, 0, GetCount());\r\n}\r\n\r\ninline BOOL MListBox::GetText(INT nIndex, MString& rString) const\r\n{\r\n    rString.clear();\r\n\r\n    INT cch = GetTextLen(nIndex);\r\n    if (cch == LB_ERR)\r\n        return FALSE;\r\n\r\n    rString.resize(cch);\r\n    cch = GetText(nIndex, &rString[0]);\r\n    if (cch == LB_ERR)\r\n        rString.clear();\r\n\r\n    return cch != LB_ERR;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MLISTBOX_HPP_\r\n
MMainDlg<>MMainDlg<>class MMainDlg : public MDialogBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n\r\n    MMainDlg(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : MDialogBase(1), m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainDlg()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        return INT(DialogBoxDx(NULL));\r\n    }\r\n};\r\n
MMainWnd<>MMainWnd<>class MMainWnd : public MWindowBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n    HACCEL      m_hAccel;       // the access keys\r\n\r\n    MMainWnd(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL), m_hAccel(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainWnd()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MMainWnd Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n        wcx.lpszMenuName = MAKEINTRESOURCE(1);\r\n        wcx.hIcon = m_hIcon;\r\n        wcx.hIconSm = m_hIconSm;\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnDestroy(HWND hwnd)\r\n    {\r\n        ::PostQuitMessage(0);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n        m_hAccel = ::LoadAccelerators(m_hInst, MAKEINTRESOURCE(1));\r\n\r\n        if (!CreateWindowDx(NULL, LoadStringDx(1)))\r\n        {\r\n            MsgBoxDx(TEXT("failure of CreateWindow"), NULL, MB_ICONERROR);\r\n            return FALSE;\r\n        }\r\n\r\n        ::ShowWindow(*this, nCmdShow);\r\n        ::UpdateWindow(*this);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        // message loop\r\n        MSG msg;\r\n        while (::GetMessage(&msg, NULL, 0, 0))\r\n        {\r\n            if (!::TranslateAccelerator(m_hwnd, m_hAccel, &msg))\r\n            {\r\n                ::TranslateMessage(&msg);\r\n                ::DispatchMessage(&msg);\r\n            }\r\n        }\r\n        return INT(msg.wParam);\r\n    }\r\n};\r\n
MMenu.hpp<>MMenu.hpp<>// MAccel.hpp -- Win32API accelerator wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MMENU_HPP_\r\n#define MZC4_MMENU_HPP_     4       /* Version 4 */\r\n\r\nclass MMenu;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n#include "MString.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MMenu\r\n{\r\npublic:\r\n    HMENU   m_hMenu;\r\n\r\n    MMenu();\r\n    MMenu(HMENU hMenu);\r\n    ~MMenu();\r\n\r\n    BOOL Attach(HMENU hMenu);\r\n    HMENU Detach();\r\n    HMENU Handle() const;\r\n\r\n    bool operator!() const;\r\n    operator HMENU() const;\r\n    bool operator!=(const MMenu& menu) const;\r\n    bool operator==(const MMenu& menu) const;\r\n    MMenu& operator=(HMENU hMenu);\r\n\r\n    BOOL AppendMenu(UINT nMF_, UINT_PTR nNewID, LPCTSTR pszItemText = NULL);\r\n    BOOL AppendMenu(UINT nMF_, UINT_PTR nNewID, HBITMAP hbm);\r\n    UINT CheckMenuItem(UINT nItem, UINT nMF_ = MF_CHECKED);\r\n    BOOL CheckMenuRadioItem(UINT first, UINT last, UINT item, UINT nMF_ = MF_BYCOMMAND);\r\n    BOOL CreateMenu();\r\n    BOOL CreatePopupMenu();\r\n    BOOL DeleteMenu(UINT nItem, UINT nMF_ = MF_BYCOMMAND);\r\n    BOOL DestroyMenu();\r\n    UINT EnableMenuItem(UINT nItem, UINT nMF_ = MF_BYCOMMAND | MF_ENABLED);\r\n    UINT GetMenuDefaultItem(BOOL fByPos, UINT nGMDI_);\r\n    DWORD GetMenuContextHelpId() const;\r\n    INT GetMenuItemCount() const;\r\n    UINT GetMenuItemID(INT nPos) const;\r\n    BOOL GetMenuItemInfo(UINT nItem, LPMENUITEMINFO pMII, BOOL fByPos = FALSE);\r\n    UINT GetMenuState(UINT nItem, UINT nMF_ = MF_BYCOMMAND);\r\n    INT GetMenuString(UINT nItem, LPTSTR psz, INT cchMax, UINT nMF_ = MF_BYCOMMAND);\r\n    INT GetMenuString(UINT nItem, MString& str, UINT nMF_ = MF_BYCOMMAND);\r\n    HMENU GetSubMenu(INT nPos) const;\r\n    BOOL InsertMenu(UINT nPos, UINT nMF_, UINT_PTR nNewID, LPCTSTR pszItemText = NULL);\r\n    BOOL InsertMenu(UINT nPos, UINT nMF_, UINT_PTR nNewID, HBITMAP hbm);\r\n    BOOL InsertMenuItem(UINT nItem, LPMENUITEMINFO pMII, BOOL fByPos = FALSE);\r\n    BOOL LoadMenu(HINSTANCE hInst, LPCTSTR pszMenuName);\r\n    BOOL LoadMenu(HINSTANCE hInst, UINT nMenuID);\r\n    BOOL LoadMenu(LPCTSTR pszMenuName);\r\n    BOOL LoadMenu(UINT nMenuID);\r\n    BOOL LoadMenuIndirect(const void *pMenuTemplate);\r\n    BOOL ModifyMenu(UINT nItem, UINT nMF_, UINT_PTR nNewID = 0, LPCTSTR pszMenuText = NULL);\r\n    BOOL ModifyMenu(UINT nItem, UINT nMF_, UINT_PTR nNewID, HBITMAP hbm);\r\n    BOOL RemoveMenu(UINT nItem, UINT nMF_ = MF_BYCOMMAND);\r\n    BOOL SetMenuDefaultItem(UINT nItem, BOOL fByPos = FALSE);\r\n    BOOL SetMenuContextHelpId(DWORD dwContextID);\r\n    BOOL SetMenuItemBitmaps(UINT nItem, UINT nMF_, HBITMAP hbmUnchecked, HBITMAP hbmChecked);\r\n    BOOL SetMenuItemInfo(UINT nItem, LPMENUITEMINFO pMII, BOOL fByPos = FALSE);\r\n    BOOL TrackPopupMenu(UINT nTPM_, INT x, INT y, HWND hwnd, LPCRECT prc = NULL);\r\n    BOOL TrackPopupMenuEx(UINT nTPM_, INT x, INT y, HWND hwnd, TPMPARAMS *params = NULL);\r\n\r\n    virtual VOID DrawItemDx(LPDRAWITEMSTRUCT lpDIS);\r\n    virtual VOID MeasureItemDx(LPMEASUREITEMSTRUCT pMIS);\r\n\r\nprivate:\r\n    // NOTE: MMenu is not copyable.\r\n    MMenu(const MMenu&);\r\n    MMenu& operator=(const MMenu&);\r\n};\r\n\r\ninline MMenu::MMenu() : m_hMenu(NULL)\r\n{\r\n}\r\n\r\ninline MMenu::MMenu(HMENU hMenu) : m_hMenu(hMenu)\r\n{\r\n}\r\n\r\ninline MMenu::~MMenu()\r\n{\r\n    DestroyMenu();\r\n}\r\n\r\ninline BOOL MMenu::Attach(HMENU hMenu)\r\n{\r\n    DestroyMenu();\r\n    m_hMenu = hMenu;\r\n    return m_hMenu != NULL;\r\n}\r\n\r\ninline HMENU MMenu::Detach()\r\n{\r\n    HMENU hMenu = m_hMenu;\r\n    m_hMenu = NULL;\r\n    return hMenu;\r\n}\r\n\r\ninline HMENU MMenu::Handle() const\r\n{\r\n    return (this ? m_hMenu : NULL);\r\n}\r\n\r\ninline bool MMenu::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline MMenu::operator HMENU() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline bool MMenu::operator!=(const MMenu& menu) const\r\n{\r\n    return Handle() != menu.Handle();\r\n}\r\n\r\ninline bool MMenu::operator==(const MMenu& menu) const\r\n{\r\n    return Handle() == menu.Handle();\r\n}\r\n\r\ninline MMenu& MMenu::operator=(HMENU hMenu)\r\n{\r\n    DestroyMenu();\r\n    m_hMenu = hMenu;\r\n    return *this;\r\n}\r\n\r\ninline BOOL\r\nMMenu::AppendMenu(UINT nMF_, UINT_PTR nNewID, LPCTSTR pszItemText/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::AppendMenu(Handle(), nMF_, nNewID, pszItemText);\r\n}\r\n\r\ninline BOOL MMenu::AppendMenu(UINT nMF_, UINT_PTR nNewID, HBITMAP hbm)\r\n{\r\n    assert(Handle());\r\n    return ::AppendMenu(Handle(), nMF_, nNewID, reinterpret_cast<LPTSTR>(hbm));\r\n}\r\n\r\ninline UINT MMenu::CheckMenuItem(UINT nItem, UINT nMF_/* = MF_CHECKED*/)\r\n{\r\n    assert(Handle());\r\n    return ::CheckMenuItem(Handle(), nItem, nMF_);\r\n}\r\n\r\ninline BOOL\r\nMMenu::CheckMenuRadioItem(UINT first, UINT last, UINT item,\r\n                          UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    return ::CheckMenuRadioItem(Handle(), first, last, item, nMF_);\r\n}\r\n\r\ninline BOOL MMenu::CreateMenu()\r\n{\r\n    return Attach(::CreateMenu());\r\n}\r\n\r\ninline BOOL MMenu::CreatePopupMenu()\r\n{\r\n    return Attach(::CreatePopupMenu());\r\n}\r\n\r\ninline BOOL MMenu::DeleteMenu(UINT nItem, UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    return ::DeleteMenu(Handle(), nItem, nMF_);\r\n}\r\n\r\ninline BOOL MMenu::DestroyMenu()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::DestroyMenu(Handle());\r\n        Detach();\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline UINT\r\nMMenu::EnableMenuItem(UINT nItem, UINT nMF_/* = MF_BYCOMMAND | MF_ENABLED*/)\r\n{\r\n    assert(Handle());\r\n    return ::EnableMenuItem(Handle(), nItem, nMF_);\r\n}\r\n\r\ninline UINT\r\nMMenu::GetMenuDefaultItem(BOOL fByPos, UINT nGMDI_)\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuDefaultItem(Handle(), fByPos, nGMDI_);\r\n}\r\n\r\ninline DWORD MMenu::GetMenuContextHelpId() const\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuContextHelpId(Handle());\r\n}\r\n\r\ninline INT MMenu::GetMenuItemCount() const\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuItemCount(Handle());\r\n}\r\n\r\ninline UINT MMenu::GetMenuItemID(INT nPos) const\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuItemID(Handle(), nPos);\r\n}\r\n\r\ninline BOOL\r\nMMenu::GetMenuItemInfo(UINT nItem, LPMENUITEMINFO pMII,\r\n                       BOOL fByPos/* = FALSE*/)\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuItemInfo(Handle(), nItem, fByPos, pMII);\r\n}\r\n\r\ninline UINT\r\nMMenu::GetMenuState(UINT nItem, UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuState(Handle(), nItem, nMF_);\r\n}\r\n\r\ninline INT\r\nMMenu::GetMenuString(UINT nItem, LPTSTR psz, INT cchMax, UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    return ::GetMenuString(Handle(), nItem, psz, cchMax, nMF_);\r\n}\r\n\r\ninline INT\r\nMMenu::GetMenuString(UINT nItem, MString& str, UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    INT cch = GetMenuString(nItem, NULL, 0, nMF_);\r\n    str.resize(cch);\r\n    cch = GetMenuString(nItem, &str[0], cch + 1, nMF_);\r\n    if (cch == 0)\r\n        str.clear();\r\n    return cch;\r\n}\r\n\r\ninline HMENU MMenu::GetSubMenu(INT nPos) const\r\n{\r\n    assert(Handle());\r\n    return ::GetSubMenu(Handle(), nPos);\r\n}\r\n\r\ninline BOOL\r\nMMenu::InsertMenu(UINT nPos, UINT nMF_, UINT_PTR nNewID, LPCTSTR pszItemText/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::InsertMenu(Handle(), nPos, nMF_, nNewID, pszItemText);\r\n}\r\n\r\ninline BOOL MMenu::InsertMenu(UINT nPos, UINT nMF_, UINT_PTR nNewID, HBITMAP hbm)\r\n{\r\n    return InsertMenu(nPos, nMF_, nNewID, reinterpret_cast<LPTSTR>(hbm));\r\n}\r\n\r\ninline BOOL\r\nMMenu::InsertMenuItem(UINT nItem, LPMENUITEMINFO pMII, BOOL fByPos/* = FALSE*/)\r\n{\r\n    assert(Handle());\r\n    return ::InsertMenuItem(Handle(), nItem, fByPos, pMII);\r\n}\r\n\r\ninline BOOL MMenu::LoadMenu(LPCTSTR pszMenuName)\r\n{\r\n    assert(Handle());\r\n    return LoadMenu(::GetModuleHandle(NULL), pszMenuName);\r\n}\r\n\r\ninline BOOL MMenu::LoadMenu(HINSTANCE hInst, LPCTSTR pszMenuName)\r\n{\r\n    return Attach(::LoadMenu(hInst, pszMenuName));\r\n}\r\n\r\ninline BOOL MMenu::LoadMenu(HINSTANCE hInst, UINT nMenuID)\r\n{\r\n    return Attach(::LoadMenu(hInst, MAKEINTRESOURCE(nMenuID)));\r\n}\r\n\r\ninline BOOL MMenu::LoadMenu(UINT nMenuID)\r\n{\r\n    return LoadMenu(MAKEINTRESOURCE(nMenuID));\r\n}\r\n\r\ninline BOOL MMenu::LoadMenuIndirect(const void *pMenuTemplate)\r\n{\r\n    return Attach(::LoadMenuIndirect(reinterpret_cast<const MENUTEMPLATE *>(pMenuTemplate)));\r\n}\r\n\r\ninline BOOL MMenu::ModifyMenu(UINT nItem, UINT nMF_, UINT_PTR nNewID/* = 0*/, LPCTSTR pszMenuText/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::ModifyMenu(Handle(), nItem, nMF_, nNewID, pszMenuText);\r\n}\r\n\r\ninline BOOL MMenu::ModifyMenu(UINT nItem, UINT nMF_, UINT_PTR nNewID, HBITMAP hbm)\r\n{\r\n    assert(Handle());\r\n    return ModifyMenu(nItem, nMF_, nNewID, reinterpret_cast<LPTSTR>(hbm));\r\n}\r\n\r\ninline BOOL MMenu::RemoveMenu(UINT nItem, UINT nMF_/* = MF_BYCOMMAND*/)\r\n{\r\n    assert(Handle());\r\n    return ::RemoveMenu(Handle(), nItem, nMF_);\r\n}\r\n\r\ninline BOOL MMenu::SetMenuDefaultItem(UINT nItem, BOOL fByPos/* = FALSE*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetMenuDefaultItem(Handle(), nItem, fByPos);\r\n}\r\n\r\ninline BOOL MMenu::SetMenuContextHelpId(DWORD dwContextID)\r\n{\r\n    assert(Handle());\r\n    return ::SetMenuContextHelpId(Handle(), dwContextID);\r\n}\r\n\r\ninline BOOL MMenu::SetMenuItemBitmaps(UINT nItem, UINT nMF_, HBITMAP hbmUnchecked, HBITMAP hbmChecked)\r\n{\r\n    assert(Handle());\r\n    return ::SetMenuItemBitmaps(Handle(), nItem, nMF_, hbmUnchecked, hbmChecked);\r\n}\r\n\r\ninline BOOL MMenu::SetMenuItemInfo(UINT nItem, LPMENUITEMINFO pMII, BOOL fByPos/* = FALSE*/)\r\n{\r\n    assert(Handle());\r\n    return ::SetMenuItemInfo(Handle(), nItem, fByPos, pMII);\r\n}\r\n\r\ninline BOOL MMenu::TrackPopupMenu(UINT nTPM_, INT x, INT y, HWND hwnd, LPCRECT prc/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::TrackPopupMenu(Handle(), nTPM_, x, y, 0, hwnd, prc);\r\n}\r\n\r\ninline BOOL MMenu::TrackPopupMenuEx(UINT nTPM_, INT x, INT y, HWND hwnd, TPMPARAMS *params/* = NULL*/)\r\n{\r\n    assert(Handle());\r\n    return ::TrackPopupMenuEx(Handle(), nTPM_, x, y, hwnd, params);\r\n}\r\n\r\ninline /*virtual*/ VOID\r\nMMenu::DrawItemDx(LPDRAWITEMSTRUCT lpDIS)\r\n{\r\n    assert(FALSE);\r\n}\r\n\r\ninline /*virtual*/ VOID\r\nMMenu::MeasureItemDx(LPMEASUREITEMSTRUCT pMIS)\r\n{\r\n    assert(FALSE);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MMENU_HPP_\r\n
MMinMaxInfo.hpp<>MMinMaxInfo.hpp<>// MMinMaxInfo.hpp -- Win32API window min max info wrapper      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MMINMAXINFO_HPP_\r\n#define MZC4_MMINMAXINFO_HPP_       2   /* Version 2 */\r\n\r\nclass MMinMaxInfo;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MPointSizeRect.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MMinMaxInfo : public MINMAXINFO\r\n{\r\npublic:\r\n    MMinMaxInfo();\r\n\r\n    // NOTE: Call MMinMaxInfo::OnGetMinMaxInfo on WM_GETMINMAXINFO\r\n    VOID OnGetMinMaxInfo(LPMINMAXINFO lpMMI);\r\n\r\n    VOID SetMaximizedRect(const MRect& rc);\r\n    VOID SetMinTrackSize(const MSize& psiz);\r\n    VOID SetMaxTrackSize(const MSize& psiz);\r\n    VOID ResetMaximizedRect();\r\n    VOID ResetMinTrackSize();\r\n    VOID ResetMaxTrackSize();\r\n\r\n    // adjust window rect to fit for min max info\r\n    VOID FixWindowRect(HWND hWnd) const;\r\n\r\nprotected:\r\n    bool m_bUseMaxRect;\r\n    bool m_bUseMinTrack;\r\n    bool m_bUseMaxTrack;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MMinMaxInfo::MMinMaxInfo()\r\n{\r\n    m_bUseMaxRect = m_bUseMinTrack = m_bUseMaxTrack = false;\r\n}\r\n\r\ninline VOID MMinMaxInfo::OnGetMinMaxInfo(LPMINMAXINFO lpMMI)\r\n{\r\n    if (m_bUseMaxRect)\r\n    {\r\n        lpMMI->ptMaxPosition = ptMaxPosition;\r\n        lpMMI->ptMaxSize = ptMaxSize;\r\n    }\r\n\r\n    if (m_bUseMinTrack)\r\n        lpMMI->ptMinTrackSize = ptMinTrackSize;\r\n\r\n    if (m_bUseMaxTrack)\r\n        lpMMI->ptMaxTrackSize = ptMaxTrackSize;\r\n}\r\n\r\ninline VOID MMinMaxInfo::SetMaximizedRect(const MRect& rc)\r\n{\r\n    m_bUseMaxRect = true;\r\n    ptMaxPosition = rc.TopLeft();\r\n    ptMaxSize.x = rc.Width();\r\n    ptMaxSize.y = rc.Height();\r\n}\r\n\r\ninline VOID MMinMaxInfo::ResetMaximizedRect()\r\n{\r\n    m_bUseMaxRect = false;\r\n}\r\n\r\ninline VOID MMinMaxInfo::SetMinTrackSize(const MSize& siz)\r\n{\r\n    m_bUseMinTrack = true;\r\n    ptMinTrackSize.x = siz.cx;\r\n    ptMinTrackSize.y = siz.cy;\r\n}\r\n\r\ninline VOID MMinMaxInfo::ResetMinTrackSize()\r\n{\r\n    m_bUseMinTrack = false;\r\n}\r\n\r\ninline VOID MMinMaxInfo::SetMaxTrackSize(const MSize& siz)\r\n{\r\n    m_bUseMaxTrack = true;\r\n    ptMaxTrackSize.x = siz.cx;\r\n    ptMaxTrackSize.y = siz.cy;\r\n}\r\n\r\ninline VOID MMinMaxInfo::ResetMaxTrackSize()\r\n{\r\n    m_bUseMaxTrack = false;\r\n}\r\n\r\ninline VOID MMinMaxInfo::FixWindowRect(HWND hWnd) const\r\n{\r\n    MRect rc;\r\n    ::GetWindowRect(hWnd, &rc);\r\n\r\n    if (::GetWindowLong(hWnd, GWL_STYLE) & WS_MAXIMIZE)\r\n    {\r\n        ::SetWindowPos(hWnd, NULL,\r\n            ptMaxPosition.x, ptMaxPosition.y,\r\n            ptMaxSize.x, ptMaxSize.y,\r\n            SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\r\n        return;\r\n    }\r\n    if (m_bUseMinTrack)\r\n    {\r\n        if (rc.Width() < ptMinTrackSize.x)\r\n            rc.right = rc.left + ptMinTrackSize.x;\r\n        if (rc.Height() < ptMinTrackSize.x)\r\n            rc.bottom = rc.top + ptMinTrackSize.y;\r\n    }\r\n    if (m_bUseMaxTrack)\r\n    {\r\n        if (ptMaxTrackSize.x < rc.Width())\r\n            rc.right = rc.left + ptMaxTrackSize.x;\r\n        if (ptMaxTrackSize.x < rc.Height())\r\n            rc.bottom = rc.top + ptMaxTrackSize.y;\r\n    }\r\n    ::SetWindowPos(hWnd, NULL,\r\n        rc.left, rc.top, rc.Width(), rc.Height(),\r\n        SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\r\n\r\n    CHAR szClsName[16];\r\n    if (::GetClassNameA(hWnd, szClsName, 16) &&\r\n        ::lstrcmpA(szClsName, "#32770") == 0)\r\n    {\r\n        ::SendMessage(hWnd, DM_REPOSITION, 0, 0);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MMINMAXINFO_HPP_\r\n
MMonthCalCtrl.hpp<>MMonthCalCtrl.hpp<>// MAnimateCtrl.hpp -- Win32API month calender control wrapper  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MMONTHCALCTRL_HPP_\r\n#define MZC4_MMONTHCALCTRL_HPP_     2   /* Version 2 */\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MMonthCalCtrl;\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MMonthCalCtrl : public MWindowBase\r\n    {\r\n    public:\r\n        MMonthCalCtrl();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        COLORREF GetColor(INT nColorType) const;\r\n        COLORREF SetColor(INT nColorType, COLORREF clr);\r\n\r\n        BOOL GetCurSel(LPSYSTEMTIME lpSysTime) const;\r\n        BOOL SetCurSel(LPSYSTEMTIME lpSysTime);\r\n\r\n        INT GetFirstDayOfWeek(BOOL* pbLocaleVal = NULL) const;\r\n        INT SetFirstDayOfWeek(INT nDay, BOOL* pbLocaleVal = NULL);\r\n\r\n        INT GetMaxSelCount() const;\r\n        BOOL SetMaxSelCount(INT nMax);\r\n\r\n        INT GetMonthDelta() const;\r\n        INT SetMonthDelta(INT nDelta);\r\n\r\n        DWORD GetRange(LPSYSTEMTIME lprgSysTimeArray) const;\r\n        BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray);\r\n\r\n        BOOL GetSelRange(LPSYSTEMTIME lprgSysTimeArray) const;\r\n        BOOL SetSelRange(LPSYSTEMTIME lprgSysTimeArray);\r\n\r\n        BOOL GetToday(LPSYSTEMTIME lpSysTime) const;\r\n        VOID SetToday(LPSYSTEMTIME lpSysTime);\r\n\r\n        BOOL GetMinReqRect(LPRECT lpRectInfo) const;\r\n        INT GetMaxTodayWidth() const;\r\n        INT GetMonthRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const;\r\n\r\n        BOOL SetDayState(INT nMonths, LPMONTHDAYSTATE lpDayStateArray);\r\n        DWORD HitTest(PMCHITTESTINFO pMCHitTest) const;\r\n\r\n        #if (_WIN32_IE >= 0x0400)\r\n            BOOL GetUnicodeFormat() const;\r\n            BOOL SetUnicodeFormat(BOOL bUnicode = TRUE);\r\n        #endif // (_WIN32_IE >= 0x0400)\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline MMonthCalCtrl::MMonthCalCtrl()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MMonthCalCtrl::GetWndClassNameDx() const\r\n    {\r\n        return MONTHCAL_CLASS;\r\n    }\r\n\r\n    inline COLORREF MMonthCalCtrl::GetColor(INT nColorType) const\r\n    {\r\n        return (COLORREF)SendMessageDx(MCM_GETCOLOR, (WPARAM)nColorType);\r\n    }\r\n\r\n    inline COLORREF MMonthCalCtrl::SetColor(INT nColorType, COLORREF clr)\r\n    {\r\n        return (COLORREF)SendMessageDx(MCM_SETCOLOR, (WPARAM)nColorType, (LPARAM)clr);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::GetCurSel(LPSYSTEMTIME lpSysTime) const\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_GETCURSEL, 0, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::SetCurSel(LPSYSTEMTIME lpSysTime)\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_SETCURSEL, 0, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::GetFirstDayOfWeek(\r\n        BOOL* pbLocaleVal/* = NULL*/) const\r\n    {\r\n        DWORD dwRet = (DWORD)SendMessageDx(MCM_GETFIRSTDAYOFWEEK);\r\n        if(pbLocaleVal != NULL)\r\n            *pbLocaleVal = (BOOL) HIWORD(dwRet);\r\n        return (INT)(SHORT) LOWORD(dwRet);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::SetFirstDayOfWeek(\r\n        INT nDay, BOOL* pbLocaleVal/* = NULL*/)\r\n    {\r\n        DWORD dwRet = (DWORD)SendMessageDx(MCM_SETFIRSTDAYOFWEEK, 0, nDay);\r\n        if(pbLocaleVal != NULL)\r\n            *pbLocaleVal = (BOOL) HIWORD(dwRet);\r\n        return (INT)(SHORT) LOWORD(dwRet);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::GetMaxSelCount() const\r\n    {\r\n        return (INT)SendMessageDx(MCM_GETMAXSELCOUNT);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::SetMaxSelCount(INT nMax)\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_SETMAXSELCOUNT, (WPARAM)nMax);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::GetMonthDelta() const\r\n    {\r\n        return (INT)SendMessageDx(MCM_GETMONTHDELTA);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::SetMonthDelta(INT nDelta)\r\n    {\r\n        return (INT)SendMessageDx(MCM_SETMONTHDELTA, (WPARAM)nDelta);\r\n    }\r\n\r\n    inline DWORD MMonthCalCtrl::GetRange(\r\n        LPSYSTEMTIME lprgSysTimeArray) const\r\n    {\r\n        return (DWORD)SendMessageDx(MCM_GETRANGE, 0, (LPARAM)lprgSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::SetRange(\r\n        DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray)\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_SETRANGE, dwFlags, (LPARAM)lprgSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::GetSelRange(\r\n        LPSYSTEMTIME lprgSysTimeArray) const\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_GETSELRANGE, 0, (LPARAM)lprgSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::SetSelRange(LPSYSTEMTIME lprgSysTimeArray)\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_SETSELRANGE, 0, (LPARAM)lprgSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::GetToday(LPSYSTEMTIME lpSysTime) const\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_GETTODAY, 0, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline VOID MMonthCalCtrl::SetToday(LPSYSTEMTIME lpSysTime)\r\n    {\r\n        SendMessageDx(MCM_SETTODAY, 0, (LPARAM)lpSysTime);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::GetMinReqRect(LPRECT lpRectInfo) const\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_GETMINREQRECT, 0, (LPARAM)lpRectInfo);\r\n    }\r\n\r\n    inline INT MMonthCalCtrl::GetMaxTodayWidth() const\r\n    {\r\n        return (INT)SendMessageDx(MCM_GETMAXTODAYWIDTH);\r\n    }\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        inline BOOL MMonthCalCtrl::GetUnicodeFormat() const\r\n        {\r\n            return (BOOL)SendMessageDx(MCM_GETUNICODEFORMAT);\r\n        }\r\n\r\n        inline BOOL MMonthCalCtrl::SetUnicodeFormat(\r\n            BOOL bUnicode/* = TRUE*/)\r\n        {\r\n            return (BOOL)SendMessageDx(MCM_SETUNICODEFORMAT, (WPARAM)bUnicode);\r\n        }\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    inline INT MMonthCalCtrl::GetMonthRange(\r\n        DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const\r\n    {\r\n        return (INT)SendMessageDx(MCM_GETMONTHRANGE, dwFlags, (LPARAM)lprgSysTimeArray);\r\n    }\r\n\r\n    inline BOOL MMonthCalCtrl::SetDayState(\r\n        INT nMonths, LPMONTHDAYSTATE lpDayStateArray)\r\n    {\r\n        return (BOOL)SendMessageDx(MCM_SETDAYSTATE, (WPARAM)nMonths, (LPARAM)lpDayStateArray);\r\n    }\r\n\r\n    inline DWORD MMonthCalCtrl::HitTest(PMCHITTESTINFO pMCHitTest) const\r\n    {\r\n        return (DWORD)SendMessageDx(MCM_HITTEST, 0, (LPARAM)pMCHitTest);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MMONTHCALCTRL_HPP_\r\n
MMutex.hpp<>MMutex.hpp<>// MMutex.hpp -- Win32API mutex object wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MMUTEX_HPP_\r\n#define MZC4_MMUTEX_HPP_        3   /* Version 3 */\r\n\r\nclass MMutex;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MSyncBase.hpp"\r\n\r\nclass MMutex : public MSyncBase\r\n{\r\npublic:\r\n    MMutex();\r\n    MMutex(BOOL bInitiallyOwn, LPCTSTR lpszName = NULL,\r\n           LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);\r\n    MMutex(HANDLE hMutex);\r\n    MMutex(const MMutex& m);\r\n    MMutex& operator=(HANDLE hMutex);\r\n    MMutex& operator=(const MMutex& m);\r\n\r\n    BOOL CreateMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,\r\n           LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);\r\n    virtual BOOL Unlock();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MMutex::MMutex()\r\n{\r\n}\r\n\r\ninline MMutex::MMutex(HANDLE hMutex) : MSyncBase(hMutex)\r\n{\r\n}\r\n\r\ninline MMutex::MMutex(const MMutex& m) : MSyncBase(CloneHandleDx(m))\r\n{\r\n}\r\n\r\ninline MMutex& MMutex::operator=(HANDLE hMutex)\r\n{\r\n    if (Handle() != hMutex)\r\n    {\r\n        Attach(hMutex);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MMutex& MMutex::operator=(const MMutex& m)\r\n{\r\n    if (Handle() != m.Handle())\r\n    {\r\n        HANDLE hMutex = CloneHandleDx(m);\r\n        Attach(hMutex);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MMutex::MMutex(BOOL bInitiallyOwn/* = FALSE*/,\r\n                      LPCTSTR lpszName/* = NULL*/,\r\n                      LPSECURITY_ATTRIBUTES lpsaAttribute/* = NULL*/)\r\n    : MSyncBase(::CreateMutex(lpsaAttribute, bInitiallyOwn, lpszName))\r\n{\r\n    assert(Handle());\r\n}\r\n\r\ninline BOOL MMutex::CreateMutex(BOOL bInitiallyOwn/* = FALSE*/,\r\n    LPCTSTR lpszName/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpsaAttribute/* = NULL*/)\r\n{\r\n    return Attach(::CreateMutex(lpsaAttribute, bInitiallyOwn, lpszName));\r\n}\r\n\r\ninline /*virtual*/ BOOL MMutex::Unlock()\r\n{\r\n    return ::ReleaseMutex(m_hObject);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MMUTEX_HPP_\r\n
MNotifyIcon.hpp<>MNotifyIcon.hpp<>// MNotifyIcon.hpp -- task bar notification icon                -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MNOTIFYICON_HPP_\r\n#define MZC4_MNOTIFYICON_HPP_       2   /* Version 2 */\r\n\r\nclass MNotifyIcon;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_SHELLAPI\r\n    #include <shellapi.h>\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MNotifyIcon : public NOTIFYICONDATA\r\n{\r\npublic:\r\n    MNotifyIcon();\r\n    MNotifyIcon(HWND hWnd_, HICON hIcon_, UINT uID_, LPCTSTR pszTip = NULL);\r\n    ~MNotifyIcon();\r\n\r\n    VOID Init(HWND hWnd_, HICON hIcon_, UINT uID_, LPCTSTR pszTip = NULL);\r\n    BOOL Add();\r\n    BOOL Delete();\r\n    BOOL Modify();\r\n    BOOL ModifyIcon(HICON hIcon);\r\n    BOOL ModifyTip(LPCTSTR pszTip);\r\n    static UINT GetTaskbarCreatedMessage();\r\n};\r\n\r\n#ifndef MZC_WM_NOTIFYICON\r\n    #define MZC_WM_NOTIFYICON   (WM_USER + 666)\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MNotifyIcon::MNotifyIcon()\r\n{\r\n    ZeroMemory(this, sizeof(NOTIFYICONDATA));\r\n}\r\n\r\ninline MNotifyIcon::MNotifyIcon(HWND hWnd_, HICON hIcon_, UINT uID_, LPCTSTR pszTip_/* = NULL*/)\r\n{\r\n    Init(hWnd_, hIcon_, uID_, pszTip_);\r\n}\r\n\r\ninline VOID\r\nMNotifyIcon::Init(HWND hWnd_, HICON hIcon_, UINT uID_, LPCTSTR pszTip_/* = NULL*/)\r\n{\r\n    assert(hWnd_);\r\n    assert(::IsWindow(hWnd_));\r\n    assert(hIcon_ != NULL);\r\n    assert(pszTip_ == NULL || lstrlen(pszTip_) + 1 < (int)_countof(szTip));\r\n\r\n    ZeroMemory(this, sizeof(NOTIFYICONDATA));\r\n    cbSize = sizeof(NOTIFYICONDATA);\r\n    hWnd = hWnd_;\r\n    uID = uID_;\r\n    uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;\r\n    uCallbackMessage = MZC_WM_NOTIFYICON;\r\n    hIcon = hIcon_;\r\n\r\n    if (pszTip_)\r\n        ::lstrcpyn(szTip, pszTip_, _countof(szTip));\r\n    else\r\n        szTip[0] = TEXT('\\0');\r\n}\r\n\r\ninline MNotifyIcon::~MNotifyIcon()\r\n{\r\n    ::DestroyIcon(hIcon);\r\n}\r\n\r\ninline BOOL MNotifyIcon::Add()\r\n{\r\n    return ::Shell_NotifyIcon(NIM_ADD, this);\r\n}\r\n\r\ninline BOOL MNotifyIcon::Delete()\r\n{\r\n    return ::Shell_NotifyIcon(NIM_DELETE, this);\r\n}\r\n\r\ninline BOOL MNotifyIcon::Modify()\r\n{\r\n    return ::Shell_NotifyIcon(NIM_MODIFY, this);\r\n}\r\n\r\ninline BOOL MNotifyIcon::ModifyIcon(HICON hIcon_)\r\n{\r\n    assert(hIcon_ != NULL);\r\n    ::DestroyIcon(hIcon);\r\n    hIcon = hIcon_;\r\n    return Modify();\r\n}\r\n\r\ninline BOOL MNotifyIcon::ModifyTip(LPCTSTR pszTip)\r\n{\r\n    assert(pszTip == NULL || lstrlen(pszTip) + 1 < (int)_countof(szTip));\r\n    if (pszTip == NULL)\r\n        szTip[0] = TEXT('\\0');\r\n    else\r\n        ::lstrcpyn(szTip, pszTip, _countof(szTip));\r\n    return Modify();\r\n}\r\n\r\ninline /*static*/ UINT MNotifyIcon::GetTaskbarCreatedMessage()\r\n{\r\n    static UINT uTaskbarCreatedMsg =\r\n        ::RegisterWindowMessage(TEXT("TaskbarCreated"));\r\n    return uTaskbarCreatedMsg;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MNOTIFYICON_HPP_\r\n
MPagerCtrl.hpp<>MPagerCtrl.hpp<>// MPagerCtrl.hpp -- Win32API pager control wrapper         -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPAGERCTRL_HPP_\r\n#define MZC4_MPAGERCTRL_HPP_        2   /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    class MPagerCtrl : public MWindowBase\r\n    {\r\n    public:\r\n        MPagerCtrl();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        INT GetButtonSize() const;\r\n        INT SetButtonSize(INT nButtonSize);\r\n\r\n        DWORD GetButtonState(INT nButton) const;\r\n\r\n        COLORREF GetBkColor() const;\r\n        COLORREF SetBkColor(COLORREF clrBk);\r\n\r\n        INT GetBorder() const;\r\n        INT SetBorder(INT nBorderSize);\r\n\r\n        INT GetPos() const;\r\n        INT SetPos(INT nPos);\r\n\r\n        VOID SetChild(HWND hWndChild);\r\n        VOID ForwardMouse(BOOL bForward = TRUE);\r\n        VOID RecalcSize();\r\n        VOID GetDropTarget(IDropTarget** ppDropTarget);\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline MPagerCtrl::MPagerCtrl()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MPagerCtrl::GetWndClassNameDx() const\r\n    {\r\n        return WC_PAGESCROLLER;\r\n    }\r\n\r\n    inline INT MPagerCtrl::GetButtonSize() const\r\n    {\r\n        return (INT)SendMessageDx(PGM_GETBUTTONSIZE);\r\n    }\r\n\r\n    inline INT MPagerCtrl::SetButtonSize(INT nButtonSize)\r\n    {\r\n        return (INT)SendMessageDx(PGM_SETBUTTONSIZE, 0, nButtonSize);\r\n    }\r\n\r\n    inline DWORD MPagerCtrl::GetButtonState(INT nButton) const\r\n    {\r\n        assert(nButton == PGB_TOPORLEFT || nButton == PGB_BOTTOMORRIGHT);\r\n        return (DWORD)SendMessageDx(PGM_GETBUTTONSTATE, 0, nButton);\r\n    }\r\n\r\n    inline COLORREF MPagerCtrl::GetBkColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(PGM_GETBKCOLOR);\r\n    }\r\n\r\n    inline COLORREF MPagerCtrl::SetBkColor(COLORREF clrBk)\r\n    {\r\n        return (COLORREF)SendMessageDx(PGM_SETBKCOLOR, 0, (LPARAM)clrBk);\r\n    }\r\n\r\n    inline INT MPagerCtrl::GetBorder() const\r\n    {\r\n        return (INT)SendMessageDx(PGM_GETBORDER);\r\n    }\r\n\r\n    inline INT MPagerCtrl::SetBorder(INT nBorderSize)\r\n    {\r\n        return (INT)SendMessageDx(PGM_SETBORDER, 0, nBorderSize);\r\n    }\r\n\r\n    inline INT MPagerCtrl::GetPos() const\r\n    {\r\n        return (INT)SendMessageDx(PGM_GETPOS);\r\n    }\r\n\r\n    inline INT MPagerCtrl::SetPos(INT nPos)\r\n    {\r\n        return (INT)SendMessageDx(PGM_SETPOS, 0, nPos);\r\n    }\r\n\r\n    inline VOID MPagerCtrl::SetChild(HWND hWndChild)\r\n    {\r\n        SendMessageDx(PGM_SETCHILD, 0, (LPARAM)hWndChild);\r\n    }\r\n\r\n    inline VOID MPagerCtrl::ForwardMouse(BOOL bForward/* = TRUE*/)\r\n    {\r\n        SendMessageDx(PGM_FORWARDMOUSE, (WPARAM)bForward);\r\n    }\r\n\r\n    inline VOID MPagerCtrl::RecalcSize()\r\n    {\r\n        SendMessageDx(PGM_RECALCSIZE);\r\n    }\r\n\r\n    inline VOID MPagerCtrl::GetDropTarget(IDropTarget** ppDropTarget)\r\n    {\r\n        assert(ppDropTarget);\r\n        SendMessageDx(PGM_GETDROPTARGET, 0, (LPARAM)ppDropTarget);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPAGERCTRL_HPP_\r\n
MPalette.hpp<>MPalette.hpp<>// MPalette.hpp -- Win32API palette object wrapper              -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPALETTE_HPP_\r\n#define MZC4_MPALETTE_HPP_     5   /* Version 5 */\r\n\r\nclass MPalette;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n\r\nclass MPalette : public MGdiObject\r\n{\r\npublic:\r\n    MPalette();\r\n    MPalette(HPALETTE hPal);\r\n    MPalette(const MPalette& pal);\r\n    MPalette& operator=(HPALETTE hPalette);\r\n    MPalette& operator=(const MPalette& pal);\r\n\r\n    HPALETTE Handle() const;\r\n    operator HPALETTE() const;\r\n\r\n    BOOL Attach(HPALETTE hPalette);\r\n    HPALETTE Detach(VOID);\r\n\r\n    WORD GetEntryCount(VOID) const;\r\n    LOGPALETTE *GetLogPalette(VOID) const;\r\n\r\n    BOOL CreatePalette(CONST LOGPALETTE *lplp);\r\n    BOOL CreateHalftonePalette(HDC hDC);\r\n    BOOL CreateDefaultPalette();\r\n\r\n    UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,\r\n        LPPALETTEENTRY lpPaletteColors) const;\r\n    UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,\r\n        LPPALETTEENTRY lpPaletteColors);\r\n    UINT GetNearestPaletteIndex(COLORREF crColor) const;\r\n    VOID AnimatePalette(UINT nStartIndex, UINT nNumEntries,\r\n        LPPALETTEENTRY lpPaletteColors);\r\n    BOOL ResizePalette(UINT nNumEntries);\r\n\r\n    static HPALETTE CloneHandleDx(HPALETTE hPalette);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ HPALETTE MPalette::CloneHandleDx(HPALETTE hPalette)\r\n{\r\n    if (hPalette == NULL)\r\n        return NULL;\r\n\r\n    MPalette pal(hPalette);\r\n    LOGPALETTE *lp = pal.GetLogPalette();\r\n    HPALETTE hPaletteNew = ::CreatePalette(lp);\r\n    ::LocalFree(lp);\r\n    pal.Detach();\r\n    return hPaletteNew;\r\n}\r\n\r\ninline MPalette::MPalette()\r\n{\r\n}\r\n\r\ninline MPalette::MPalette(HPALETTE hPal) : MGdiObject(hPal)\r\n{\r\n}\r\n\r\ninline MPalette::MPalette(const MPalette& pal)\r\n    : MGdiObject(CloneHandleDx(pal))\r\n{\r\n}\r\n\r\ninline HPALETTE MPalette::Handle() const\r\n{\r\n    return (this ? (HPALETTE)m_hGdiObj : NULL);\r\n}\r\n\r\ninline MPalette::operator HPALETTE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline MPalette& MPalette::operator=(HPALETTE hPalette)\r\n{\r\n    assert(hPalette == NULL || ::GetObjectType(hPalette) == OBJ_PAL);\r\n    if (Handle() != hPalette)\r\n    {\r\n        Attach(hPalette);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MPalette& MPalette::operator=(const MPalette& pal)\r\n{\r\n    if (Handle() != pal.Handle())\r\n    {\r\n        HPALETTE hPal = CloneHandleDx(pal);\r\n        Attach(hPal);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MPalette::Attach(HPALETTE hPalette)\r\n{\r\n    assert(::GetObjectType(hPalette) == OBJ_PAL);\r\n    return MGdiObject::Attach(hPalette);\r\n}\r\n\r\ninline HPALETTE MPalette::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HPALETTE>(MGdiObject::Detach());\r\n}\r\n\r\ninline WORD MPalette::GetEntryCount(VOID) const\r\n{\r\n    WORD w;\r\n    ::GetObject(Handle(), sizeof(WORD), &w);\r\n    return w;\r\n}\r\n\r\ninline LOGPALETTE *MPalette::GetLogPalette(VOID) const\r\n{\r\n    assert(Handle());\r\n    WORD wCount = GetEntryCount();\r\n    DWORD cb = 2 * sizeof(WORD) + wCount * sizeof(PALETTEENTRY);\r\n    LOGPALETTE *pal = (LOGPALETTE *)::LocalAlloc(LPTR, cb);\r\n    assert(pal);\r\n    pal->palVersion  = 0x300;\r\n    pal->palNumEntries  = wCount;\r\n    ::GetPaletteEntries(Handle(), 0, wCount, pal->palPalEntry);\r\n    return pal;\r\n}\r\n\r\ninline BOOL MPalette::CreatePalette(CONST LOGPALETTE *lplp)\r\n{\r\n    return Attach(::CreatePalette(lplp));\r\n}\r\n\r\ninline BOOL MPalette::CreateHalftonePalette(HDC hDC)\r\n{\r\n    return Attach(::CreateHalftonePalette(hDC));\r\n}\r\n\r\ninline BOOL MPalette::CreateDefaultPalette()\r\n{\r\n    return Attach((HPALETTE)::GetStockObject(DEFAULT_PALETTE));\r\n}\r\n\r\ninline UINT MPalette::GetPaletteEntries(\r\n    UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const\r\n{\r\n    assert(Handle());\r\n    return ::GetPaletteEntries(Handle(), nStartIndex, nNumEntries,\r\n                               lpPaletteColors);\r\n}\r\n\r\ninline UINT MPalette::SetPaletteEntries(\r\n    UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)\r\n{\r\n    assert(Handle());\r\n    return ::SetPaletteEntries(Handle(),\r\n        nStartIndex, nNumEntries, lpPaletteColors);\r\n}\r\n\r\ninline UINT MPalette::GetNearestPaletteIndex(COLORREF crColor) const\r\n{\r\n    assert(Handle());\r\n    return ::GetNearestPaletteIndex(Handle(), crColor);\r\n}\r\n\r\ninline VOID MPalette::AnimatePalette(\r\n    UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)\r\n{\r\n    assert(Handle());\r\n    ::AnimatePalette(Handle(), nStartIndex, nNumEntries, lpPaletteColors);\r\n}\r\n\r\ninline BOOL MPalette::ResizePalette(UINT nNumEntries)\r\n{\r\n    assert(Handle());\r\n    return ::ResizePalette(Handle(), nNumEntries);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPALETTE_HPP_\r\n
MPen.hpp<>MPen.hpp<>// MPen.hpp -- Win32API pen object wrapper                      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPEN_HPP_\r\n#define MZC4_MPEN_HPP_      3   /* Version 3 */\r\n\r\nclass MPen;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n\r\nclass MPen : public MGdiObject\r\n{\r\npublic:\r\n    MPen();\r\n    MPen(HPEN hPen);\r\n    MPen(const MPen& pen);\r\n    MPen& operator=(HPEN hPen);\r\n    MPen& operator=(const MPen& pen);\r\n\r\n    HPEN Handle() const;\r\n    operator HPEN() const;\r\n\r\n    INT GetLogPen(LOGPEN *lplp) const;\r\n\r\n\r\n    BOOL Attach(HPEN hPen);\r\n    HPEN Detach(VOID);\r\n\r\n    BOOL CreatePen(COLORREF crColor = RGB(0, 0, 0), INT nWidth = 0,\r\n                   INT fnPenStyle = PS_SOLID);\r\n    BOOL CreatePenIndirect(CONST LOGPEN *lplp);\r\n    BOOL ExtCreatePen(DWORD dwPenStyle, DWORD dwWidth, CONST LOGBRUSH *lplb,\r\n                      DWORD dwStyleCount = 0, CONST DWORD *lpStyle = NULL);\r\n    BOOL CreateBlackPen();\r\n    BOOL CreateWhitePen();\r\n    BOOL CreateNullPen();\r\n\r\n    static HPEN CloneHandleDx(HPEN hPen);\r\n};\r\n\r\nHPEN CreateBlackPenDx();\r\nHPEN CreateWhitePenDx();\r\nHPEN CreateNullPenDx();\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MPen::MPen()\r\n{\r\n}\r\n\r\ninline MPen::MPen(HPEN hPen) : MGdiObject(hPen)\r\n{\r\n}\r\n\r\ninline MPen::MPen(const MPen& pen)\r\n    : MGdiObject(CloneHandleDx(pen))\r\n{\r\n}\r\n\r\ninline HPEN MPen::Handle() const\r\n{\r\n    return (this ? (HPEN)m_hGdiObj : NULL);\r\n}\r\n\r\ninline MPen::operator HPEN() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline INT MPen::GetLogPen(LOGPEN *lplp) const\r\n{\r\n    assert(Handle());\r\n    return ::GetObject(Handle(), sizeof(LOGPEN), lplp);\r\n}\r\n\r\ninline MPen& MPen::operator=(HPEN hPen)\r\n{\r\n    assert(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN);\r\n    if (Handle() != hPen)\r\n    {\r\n        Attach(hPen);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MPen& MPen::operator=(const MPen& pen)\r\n{\r\n    if (Handle() != pen.Handle())\r\n    {\r\n        HPEN hPen = CloneHandleDx(pen);\r\n        Attach(hPen);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MPen::Attach(HPEN hPen)\r\n{\r\n    assert(::GetObjectType(hPen) == OBJ_PEN);\r\n    return MGdiObject::Attach(hPen);\r\n}\r\n\r\ninline HPEN MPen::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HPEN>(MGdiObject::Detach());\r\n}\r\n\r\ninline BOOL MPen::CreatePen(COLORREF crColor/* = RGB(0, 0, 0)*/,\r\n    INT nWidth/* = 0*/, INT fnPenStyle/* = PS_SOLID*/)\r\n{\r\n    return Attach(::CreatePen(fnPenStyle, nWidth, crColor));\r\n}\r\n\r\ninline BOOL MPen::CreatePenIndirect(CONST LOGPEN *lplp)\r\n{\r\n    return Attach(::CreatePenIndirect(lplp));\r\n}\r\n\r\ninline BOOL MPen::ExtCreatePen(DWORD dwPenStyle, DWORD dwWidth,\r\n    CONST LOGBRUSH *lplb, DWORD dwStyleCount/* = 0*/,\r\n    CONST DWORD *lpStyle/* = NULL*/)\r\n{\r\n    return Attach(::ExtCreatePen(dwPenStyle, dwWidth, lplb, dwStyleCount, lpStyle));\r\n}\r\n\r\ninline /*static*/ HPEN MPen::CloneHandleDx(HPEN hPen)\r\n{\r\n    LOGPEN lp;\r\n    EXTLOGPEN elp;\r\n\r\n    if (hPen == NULL)\r\n        return NULL;\r\n\r\n    if (::GetObject(hPen, sizeof(EXTLOGPEN), &elp) != 0)\r\n    {\r\n        LOGBRUSH lb;\r\n        lb.lbStyle = elp.elpBrushStyle;\r\n        lb.lbColor = elp.elpColor;\r\n        lb.lbHatch = elp.elpHatch;\r\n        return ::ExtCreatePen(elp.elpPenStyle,\r\n            elp.elpWidth, &lb, elp.elpNumEntries, elp.elpStyleEntry);\r\n    }\r\n    else\r\n    {\r\n        ::GetObject(hPen, sizeof(LOGPEN), &lp);\r\n        return ::CreatePenIndirect(&lp);\r\n    }\r\n}\r\n\r\ninline BOOL MPen::CreateBlackPen()\r\n{\r\n    return Attach(CreateBlackPenDx());\r\n}\r\n\r\ninline BOOL MPen::CreateWhitePen()\r\n{\r\n    return Attach(CreateWhitePenDx());\r\n}\r\n\r\ninline BOOL MPen::CreateNullPen()\r\n{\r\n    return Attach(CreateNullPenDx());\r\n}\r\n\r\ninline HPEN CreateBlackPenDx()\r\n{\r\n    return (HPEN)::GetStockObject(BLACK_PEN);\r\n}\r\n\r\ninline HPEN CreateWhitePenDx()\r\n{\r\n    return (HPEN)::GetStockObject(WHITE_PEN);\r\n}\r\n\r\ninline HPEN CreateNullPenDx()\r\n{\r\n    return (HPEN)::GetStockObject(NULL_PEN);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPEN_HPP_\r\n
MPointSizeRect.hpp<>MPointSizeRect.hpp<>// MPointSizeRect.hpp -- Win32API point, size and rectangle     -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPOINTSIZERECT_HPP_\r\n#define MZC4_MPOINTSIZERECT_HPP_    4   /* Version 4 */\r\n\r\nclass MPoint;\r\nclass MSize;\r\nclass MRect;\r\n//VOID NormalizeRectDx(LPRECT prc);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_WINDOWSX\r\n    #include <windowsx.h>   // macro API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline VOID GetScreenRectDx(LPRECT prc)\r\n{\r\n#ifndef SM_XVIRTUALSCREEN\r\n    #define SM_XVIRTUALSCREEN   76\r\n    #define SM_YVIRTUALSCREEN   77\r\n    #define SM_CXVIRTUALSCREEN  78\r\n    #define SM_CYVIRTUALSCREEN  79\r\n#endif\r\n    INT x = GetSystemMetrics(SM_XVIRTUALSCREEN);\r\n    INT y = GetSystemMetrics(SM_YVIRTUALSCREEN);\r\n    INT cx = GetSystemMetrics(SM_CXVIRTUALSCREEN);\r\n    INT cy = GetSystemMetrics(SM_CYVIRTUALSCREEN);\r\n    if (cx)\r\n    {\r\n        SetRect(prc, x, y, x + cx, y + cy);\r\n    }\r\n    else\r\n    {\r\n        cx = GetSystemMetrics(SM_CXSCREEN);\r\n        cy = GetSystemMetrics(SM_CYSCREEN);\r\n        SetRect(prc, 0, 0, cx, cy);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MPoint : public POINT\r\n{\r\npublic:\r\n    MPoint();\r\n    MPoint(INT x_, INT y_);\r\n    MPoint(POINT pt);\r\n    MPoint(SIZE siz);\r\n    MPoint(DWORD dwPoint);\r\n    VOID    Offset(INT dx, INT dy);\r\n    VOID    Offset(POINT pt);\r\n    VOID    Offset(SIZE siz);\r\n    operator LPPOINT();\r\n    operator const POINT *() const;\r\n    BOOL    operator==(POINT pt) const;\r\n    BOOL    operator!=(POINT pt) const;\r\n    VOID    operator+=(SIZE siz);\r\n    VOID    operator-=(SIZE siz);\r\n    VOID    operator+=(POINT pt);\r\n    VOID    operator-=(POINT pt);\r\n    VOID    SetPoint(INT x_, INT y_);\r\n    MPoint  operator+(SIZE siz) const;\r\n    MPoint  operator-(SIZE siz) const;\r\n    MPoint  operator-() const;\r\n    MPoint  operator+(POINT pt) const;\r\n    MSize   operator-(POINT pt) const;\r\n    MRect   operator+(LPCRECT prc) const;\r\n    MRect   operator-(LPCRECT prc) const;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MSize : public SIZE\r\n{\r\npublic:\r\n    MSize();\r\n    MSize(INT cx_, INT cy_);\r\n    MSize(SIZE siz);\r\n    MSize(POINT pt);\r\n    MSize(DWORD dwSize);\r\n    operator LPSIZE();\r\n    operator const SIZE *() const;\r\n    BOOL    operator==(SIZE siz) const;\r\n    BOOL    operator!=(SIZE siz) const;\r\n    VOID    operator+=(SIZE siz);\r\n    VOID    operator-=(SIZE siz);\r\n    VOID    SetSize(INT cx_, INT cy_);\r\n    MSize   operator+(SIZE siz) const;\r\n    MSize   operator-(SIZE siz) const;\r\n    MSize   operator-() const;\r\n    MPoint  operator+(POINT pt) const;\r\n    MPoint  operator-(POINT pt) const;\r\n    MRect   operator+(LPCRECT prc) const;\r\n    MRect   operator-(LPCRECT prc) const;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MRect : public RECT\r\n{\r\npublic:\r\n    MRect();\r\n    MRect(INT l, INT t, INT r, INT b);\r\n    MRect(const RECT& rcSrc);\r\n    MRect(LPCRECT lpSrcRect);\r\n    MRect(POINT pt, SIZE siz);\r\n    MRect(POINT topLeft, POINT bottomRight);\r\n    operator LPRECT();\r\n    operator LPCRECT() const;\r\n\r\n    INT   Width() const;\r\n    INT   Height() const;\r\n    MSize Size() const;\r\n\r\n    MPoint&       TopLeft();\r\n    const MPoint& TopLeft() const;\r\n    MPoint&       BottomRight();\r\n    const MPoint& BottomRight() const;\r\n    MPoint        CenterPoint() const;\r\n\r\n    BOOL IsRectEmpty() const;\r\n    BOOL IsRectNull() const;\r\n    BOOL PtInRect(POINT pt) const;\r\n    VOID SetRect(INT x1, INT y1, INT x2, INT y2);\r\n    VOID SetRect(POINT topLeft, POINT bottomRight);\r\n    VOID SetRectEmpty();\r\n    VOID CopyRect(LPCRECT lpSrcRect);\r\n    BOOL EqualRect(LPCRECT prc) const;\r\n    VOID InflateRect(INT x, INT y);\r\n    VOID InflateRect(SIZE siz);\r\n    VOID InflateRect(LPCRECT prc);\r\n    VOID InflateRect(INT l, INT t, INT r, INT b);\r\n    VOID DeflateRect(INT x, INT y);\r\n    VOID DeflateRect(SIZE siz);\r\n    VOID DeflateRect(LPCRECT prc);\r\n    VOID DeflateRect(INT l, INT t, INT r, INT b);\r\n    VOID OffsetRect(INT x, INT y);\r\n    VOID OffsetRect(SIZE siz);\r\n    VOID OffsetRect(POINT pt);\r\n    VOID NormalizeRect();\r\n    VOID MoveToX(INT x);\r\n    VOID MoveToY(INT y);\r\n    VOID MoveToXY(INT x, INT y);\r\n    VOID MoveToXY(POINT pt);\r\n    BOOL IntersectRect(LPCRECT prc1, LPCRECT prc2);\r\n    BOOL UnionRect(LPCRECT prc1, LPCRECT prc2);\r\n    BOOL SubtractRect(LPCRECT prcSrc1, LPCRECT prcSrc2);\r\n\r\n    VOID operator=(const RECT& rcSrc);\r\n    BOOL operator==(const RECT& rc) const;\r\n    BOOL operator!=(const RECT& rc) const;\r\n    VOID operator+=(POINT pt);\r\n    VOID operator+=(SIZE siz);\r\n    VOID operator+=(LPCRECT prc);\r\n    VOID operator-=(POINT pt);\r\n    VOID operator-=(SIZE siz);\r\n    VOID operator-=(LPCRECT prc);\r\n    VOID operator&=(const RECT& rc);\r\n    VOID operator|=(const RECT& rc);\r\n    MRect operator+(POINT pt) const;\r\n    MRect operator-(POINT pt) const;\r\n    MRect operator+(LPCRECT prc) const;\r\n    MRect operator+(SIZE siz) const;\r\n    MRect operator-(SIZE siz) const;\r\n    MRect operator-(LPCRECT prc) const;\r\n    MRect operator&(const RECT& rc2) const;\r\n    MRect operator|(const RECT& rc2) const;\r\n    MRect MulDiv(INT nMultiplier, INT nDivisor) const;\r\n};\r\n\r\nVOID NormalizeRectDx(LPRECT prc);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MPoint::MPoint()\r\n    { x = y = 0; }\r\n\r\ninline MPoint::MPoint(INT x_, INT y_)\r\n    { x = x_; y = y_; }\r\n\r\ninline MPoint::MPoint(POINT pt)\r\n    { *reinterpret_cast<POINT *>(this) = pt; }\r\n\r\ninline MPoint::MPoint(SIZE siz)\r\n    { *reinterpret_cast<SIZE *>(this) = siz; }\r\n\r\ninline MPoint::MPoint(DWORD dwPoint)\r\n    { x = GET_X_LPARAM(dwPoint); y = GET_Y_LPARAM(dwPoint); }\r\n\r\ninline VOID MPoint::Offset(INT dx, INT dy)\r\n    { x += dx; y += dy; }\r\n\r\ninline VOID MPoint::Offset(POINT pt)\r\n    { x += pt.x; y += pt.y; }\r\n\r\ninline VOID MPoint::Offset(SIZE siz)\r\n    { x += siz.cx; y += siz.cy; }\r\n\r\ninline MPoint::operator LPPOINT()\r\n    { return reinterpret_cast<LPPOINT>(this); }\r\n\r\ninline MPoint::operator const POINT *() const\r\n    { return reinterpret_cast<const POINT *>(this); }\r\n\r\ninline BOOL MPoint::operator==(POINT pt) const\r\n    { return (x == pt.x && y == pt.y); }\r\n\r\ninline BOOL MPoint::operator!=(POINT pt) const\r\n    { return (x != pt.x || y != pt.y); }\r\n\r\ninline VOID MPoint::operator+=(SIZE siz)\r\n    { x += siz.cx; y += siz.cy; }\r\n\r\ninline VOID MPoint::operator-=(SIZE siz)\r\n    { x -= siz.cx; y -= siz.cy; }\r\n\r\ninline VOID MPoint::operator+=(POINT pt)\r\n    { x += pt.x; y += pt.y; }\r\n\r\ninline VOID MPoint::operator-=(POINT pt)\r\n    { x -= pt.x; y -= pt.y; }\r\n\r\ninline VOID MPoint::SetPoint(INT x_, INT y_)\r\n    { x = x_; y = y_; }\r\n\r\ninline MPoint MPoint::operator+(SIZE siz) const\r\n    { return MPoint(x + siz.cx, y + siz.cy); }\r\n\r\ninline MPoint MPoint::operator-(SIZE siz) const\r\n    { return MPoint(x - siz.cx, y - siz.cy); }\r\n\r\ninline MPoint MPoint::operator-() const\r\n    { return MPoint(-x, -y); }\r\n\r\ninline MPoint MPoint::operator+(POINT pt) const\r\n    { return MPoint(x + pt.x, y + pt.y); }\r\n\r\ninline MSize MPoint::operator-(POINT pt) const\r\n    { return MSize(x - pt.x, y - pt.y); }\r\n\r\ninline MRect MPoint::operator+(LPCRECT prc) const\r\n    { return MRect(prc) + *this; }\r\n\r\ninline MRect MPoint::operator-(LPCRECT prc) const\r\n    { return MRect(prc) - *this; }\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MSize::MSize()\r\n    { cx = cy = 0; }\r\n\r\ninline MSize::MSize(INT cx_, INT cy_)\r\n    { cx = cx_; cy = cy_; }\r\n\r\ninline MSize::MSize(SIZE siz)\r\n    { *reinterpret_cast<SIZE *>(this) = siz; }\r\n\r\ninline MSize::MSize(POINT pt)\r\n    { *reinterpret_cast<POINT *>(this) = pt; }\r\n\r\ninline MSize::MSize(DWORD dwSize)\r\n    { cx = GET_X_LPARAM(dwSize); cy = GET_Y_LPARAM(dwSize); }\r\n\r\ninline MSize::operator LPSIZE()\r\n    { return reinterpret_cast<LPSIZE>(this); }\r\n\r\ninline MSize::operator const SIZE *() const\r\n    { return reinterpret_cast<const SIZE *>(this); }\r\n\r\ninline BOOL MSize::operator==(SIZE siz) const\r\n    { return (cx == siz.cx && cy == siz.cy); }\r\n\r\ninline BOOL MSize::operator!=(SIZE siz) const\r\n    { return (cx != siz.cx || cy != siz.cy); }\r\n\r\ninline VOID MSize::operator+=(SIZE siz)\r\n    { cx += siz.cx; cy += siz.cy; }\r\n\r\ninline VOID MSize::operator-=(SIZE siz)\r\n    { cx -= siz.cx; cy -= siz.cy; }\r\n\r\ninline VOID MSize::SetSize(INT cx_, INT cy_)\r\n    { cx = cx_; cy = cy_; }\r\n\r\ninline MSize MSize::operator+(SIZE siz) const\r\n    { return MSize(cx + siz.cx, cy + siz.cy); }\r\n\r\ninline MSize MSize::operator-(SIZE siz) const\r\n    { return MSize(cx - siz.cx, cy - siz.cy); }\r\n\r\ninline MSize MSize::operator-() const\r\n    { return MSize(-cx, -cy); }\r\n\r\ninline MPoint MSize::operator+(POINT pt) const\r\n    { return MPoint(cx + pt.x, cy + pt.y); }\r\n\r\ninline MPoint MSize::operator-(POINT pt) const\r\n    { return MPoint(cx - pt.x, cy - pt.y); }\r\n\r\ninline MRect MSize::operator+(LPCRECT prc) const\r\n    { return MRect(prc) + *this; }\r\n\r\ninline MRect MSize::operator-(LPCRECT prc) const\r\n    { return MRect(prc) - *this; }\r\n\r\ntemplate <class Number>\r\ninline MSize operator*(SIZE s, Number n)\r\n    { return MSize((INT)(s.cx * n), (INT)(s.cy * n)); }\r\n\r\ntemplate <class Number>\r\ninline VOID operator*=(SIZE & s, Number n)\r\n    { s = s * n; }\r\n\r\ntemplate <class Number>\r\ninline MSize operator/(SIZE s, Number n) \r\n    { return MSize((INT)(s.cx / n), (INT)(s.cy / n)); }\r\n\r\ntemplate <class Number>\r\ninline VOID operator/=(SIZE & s, Number n)\r\n    { s = s / n; }\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MRect::MRect()\r\n    { left = top = right = bottom = 0; }\r\n\r\ninline MRect::MRect(INT l, INT t, INT r, INT b)\r\n    { left = l; top = t; right = r; bottom = b; }\r\n\r\ninline MRect::MRect(const RECT& rcSrc)\r\n    { ::CopyRect(this, &rcSrc); }\r\n\r\ninline MRect::MRect(LPCRECT lpSrcRect)\r\n    { ::CopyRect(this, lpSrcRect); }\r\n\r\ninline MRect::MRect(POINT pt, SIZE siz)\r\n{\r\n    right = (left = pt.x) + siz.cx;\r\n    bottom = (top = pt.y) + siz.cy;\r\n}\r\n\r\ninline MRect::MRect(POINT topLeft, POINT bottomRight)\r\n{\r\n    left = topLeft.x;\r\n    top = topLeft.y;\r\n    right = bottomRight.x;\r\n    bottom = bottomRight.y;\r\n}\r\n\r\ninline VOID MRect::InflateRect(LPCRECT prc)\r\n{\r\n    left -= prc->left;\r\n    top -= prc->top;\r\n    right += prc->right;\r\n    bottom += prc->bottom;\r\n}\r\n\r\ninline VOID MRect::InflateRect(INT l, INT t, INT r, INT b)\r\n{\r\n    left -= l;\r\n    top -= t;\r\n    right += r;\r\n    bottom += b;\r\n}\r\n\r\ninline VOID MRect::DeflateRect(LPCRECT prc)\r\n{\r\n    left += prc->left;\r\n    top += prc->top;\r\n    right -= prc->right;\r\n    bottom -= prc->bottom;\r\n}\r\n\r\ninline VOID MRect::DeflateRect(INT l, INT t, INT r, INT b)\r\n{\r\n    left += l;\r\n    top += t;\r\n    right -= r;\r\n    bottom -= b;\r\n}\r\n\r\ninline VOID MRect::NormalizeRect()\r\n{\r\n    INT nTemp;\r\n    if (left > right)\r\n    {\r\n        nTemp = left;\r\n        left = right;\r\n        right = nTemp;\r\n    }\r\n    if (top > bottom)\r\n    {\r\n        nTemp = top;\r\n        top = bottom;\r\n        bottom = nTemp;\r\n    }\r\n}\r\n\r\ninline MRect MRect::operator+(POINT pt) const\r\n{\r\n    MRect rc(*this);\r\n    ::OffsetRect(&rc, pt.x, pt.y);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator-(POINT pt) const\r\n{\r\n    MRect rc(*this);\r\n    ::OffsetRect(&rc, -pt.x, -pt.y);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator+(LPCRECT prc) const\r\n{\r\n    MRect rc(this);\r\n    rc.InflateRect(prc);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator+(SIZE siz) const\r\n{\r\n    MRect rc(*this);\r\n    ::OffsetRect(&rc, siz.cx, siz.cy);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator-(SIZE siz) const\r\n{\r\n    MRect rc(*this);\r\n    ::OffsetRect(&rc, -siz.cx, -siz.cy);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator-(LPCRECT prc) const\r\n{\r\n    MRect rc(this);\r\n    rc.DeflateRect(prc);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator&(const RECT& rc2) const\r\n{\r\n    MRect rc;\r\n    ::IntersectRect(&rc, this, &rc2);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::operator|(const RECT& rc2) const\r\n{\r\n    MRect rc;\r\n    ::UnionRect(&rc, this, &rc2);\r\n    return rc;\r\n}\r\n\r\ninline MRect MRect::MulDiv(INT nMultiplier, INT nDivisor) const\r\n{\r\n    return MRect(\r\n        ::MulDiv(left, nMultiplier, nDivisor),\r\n        ::MulDiv(top, nMultiplier, nDivisor),\r\n        ::MulDiv(right, nMultiplier, nDivisor),\r\n        ::MulDiv(bottom, nMultiplier, nDivisor));\r\n}\r\n\r\ninline INT MRect::Width() const\r\n    { return right - left; }\r\n\r\ninline INT MRect::Height() const\r\n    { return bottom - top; }\r\n\r\ninline MSize MRect::Size() const\r\n    { return MSize(right - left, bottom - top); }\r\n\r\ninline MPoint& MRect::TopLeft()\r\n    { return *((MPoint*) this); }\r\n\r\ninline MPoint& MRect::BottomRight()\r\n    { return *((MPoint*) this + 1); }\r\n\r\ninline const MPoint& MRect::TopLeft() const\r\n    { return *((MPoint*) this); }\r\n\r\ninline const MPoint& MRect::BottomRight() const\r\n    { return *((MPoint*) this + 1); }\r\n\r\ninline MPoint MRect::CenterPoint() const\r\n    { return MPoint((left + right) / 2, (top + bottom) / 2); }\r\n\r\ninline MRect::operator LPRECT()\r\n    { return this; }\r\n\r\ninline MRect::operator LPCRECT() const\r\n    { return this; }\r\n\r\ninline BOOL MRect::IsRectEmpty() const\r\n    { return ::IsRectEmpty(this); }\r\n\r\ninline BOOL MRect::IsRectNull() const\r\n    { return (left == 0 && right == 0 && top == 0 && bottom == 0); }\r\n\r\ninline BOOL MRect::PtInRect(POINT pt) const\r\n    { return ::PtInRect(this, pt); }\r\n\r\ninline VOID MRect::SetRect(INT x1, INT y1, INT x2, INT y2)\r\n    { ::SetRect(this, x1, y1, x2, y2); }\r\n\r\ninline VOID MRect::SetRect(POINT topLeft, POINT bottomRight)\r\n{\r\n    ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);\r\n}\r\n\r\ninline VOID MRect::SetRectEmpty()\r\n    { ::SetRectEmpty(this); }\r\n\r\ninline VOID MRect::CopyRect(LPCRECT lpSrcRect)\r\n    { ::CopyRect(this, lpSrcRect); }\r\n\r\ninline BOOL MRect::EqualRect(LPCRECT prc) const\r\n    { return ::EqualRect(this, prc); }\r\n\r\ninline VOID MRect::InflateRect(INT x, INT y)\r\n    { ::InflateRect(this, x, y); }\r\n\r\ninline VOID MRect::InflateRect(SIZE siz)\r\n    { ::InflateRect(this, siz.cx, siz.cy); }\r\n\r\ninline VOID MRect::DeflateRect(INT x, INT y)\r\n    { ::InflateRect(this, -x, -y); }\r\n\r\ninline VOID MRect::DeflateRect(SIZE siz)\r\n    { ::InflateRect(this, -siz.cx, -siz.cy); }\r\n\r\ninline VOID MRect::OffsetRect(INT x, INT y)\r\n    { ::OffsetRect(this, x, y); }\r\n\r\ninline VOID MRect::OffsetRect(SIZE siz)\r\n    { ::OffsetRect(this, siz.cx, siz.cy); }\r\n\r\ninline VOID MRect::OffsetRect(POINT pt)\r\n    { ::OffsetRect(this, pt.x, pt.y); }\r\n\r\ninline VOID MRect::MoveToX(INT x)\r\n    { right = Width() + x; left = x; }\r\n\r\ninline VOID MRect::MoveToY(INT y)\r\n    { bottom = Height() + y; top = y; }\r\n\r\ninline VOID MRect::MoveToXY(INT x, INT y)\r\n    { MoveToX(x); MoveToY(y); }\r\n\r\ninline VOID MRect::MoveToXY(POINT pt)\r\n    { MoveToX(pt.x); MoveToY(pt.y); }\r\n\r\ninline BOOL MRect::IntersectRect(LPCRECT prc1, LPCRECT prc2)\r\n    { return ::IntersectRect(this, prc1, prc2); }\r\n\r\ninline BOOL MRect::UnionRect(LPCRECT prc1, LPCRECT prc2)\r\n    { return ::UnionRect(this, prc1, prc2); }\r\n\r\ninline BOOL MRect::SubtractRect(LPCRECT prcSrc1, LPCRECT prcSrc2)\r\n    { return ::SubtractRect(this, prcSrc1, prcSrc2); }\r\n\r\ninline VOID MRect::operator=(const RECT& rcSrc)\r\n    { ::CopyRect(this, &rcSrc); }\r\n\r\ninline BOOL MRect::operator==(const RECT& rc) const\r\n    { return ::EqualRect(this, &rc); }\r\n\r\ninline BOOL MRect::operator!=(const RECT& rc) const\r\n    { return !::EqualRect(this, &rc); }\r\n\r\ninline VOID MRect::operator+=(POINT pt)\r\n    { ::OffsetRect(this, pt.x, pt.y); }\r\n\r\ninline VOID MRect::operator+=(SIZE siz)\r\n    { ::OffsetRect(this, siz.cx, siz.cy); }\r\n\r\ninline VOID MRect::operator+=(LPCRECT prc)\r\n    { InflateRect(prc); }\r\n\r\ninline VOID MRect::operator-=(POINT pt)\r\n    { ::OffsetRect(this, -pt.x, -pt.y); }\r\n\r\ninline VOID MRect::operator-=(SIZE siz)\r\n    { ::OffsetRect(this, -siz.cx, -siz.cy); }\r\n\r\ninline VOID MRect::operator-=(LPCRECT prc)\r\n    { DeflateRect(prc); }\r\n\r\ninline VOID MRect::operator&=(const RECT& rc)\r\n    { ::IntersectRect(this, this, &rc); }\r\n\r\ninline VOID MRect::operator|=(const RECT& rc)\r\n    { ::UnionRect(this, this, &rc); }\r\n\r\ninline VOID NormalizeRectDx(LPRECT prc)\r\n{\r\n    INT nTemp;\r\n    if (prc->left > prc->right)\r\n    {\r\n        nTemp = prc->left;\r\n        prc->left = prc->right;\r\n        prc->right = nTemp;\r\n    }\r\n    if (prc->top > prc->bottom)\r\n    {\r\n        nTemp = prc->top;\r\n        prc->top = prc->bottom;\r\n        prc->bottom = nTemp;\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPOINTSIZERECT_HPP_\r\n
MPrintDialog.hpp<>MPrintDialog.hpp<>// MPrintDialog.hpp -- printer dialog wrapper                   -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPRINTDIALOG_HPP_\r\n#define MZC4_MPRINTDIALOG_HPP_      4       /* Version 4 */\r\n\r\nclass MPrintDialog;\r\nstruct MDevNames;\r\nstruct MDevMode;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCommonDialog.hpp"\r\n\r\nHDC MZCAPI CreatePrinterDCDx(HGLOBAL hDevNames, HGLOBAL hDevMode);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MDevNames and MDevMode\r\n\r\nstruct MDevNames : DEVNAMES\r\n{\r\n    LPCTSTR GetDriverName() const;\r\n    LPCTSTR GetDeviceName() const;\r\n    LPCTSTR GetPortName() const;\r\n    BOOL IsDefault() const;\r\n    static HGLOBAL CreateDevNames(LPCTSTR pszDriverName,\r\n        LPCTSTR pszDeviceName, LPCTSTR pszPortName, WORD wDefault = 0);\r\n    static HGLOBAL CloneHandleDx(HGLOBAL hDevNames);\r\n};\r\n\r\nstruct MDevMode : DEVMODE\r\n{\r\n    LPCTSTR GetDeviceName() const;\r\n    VOID SetDeviceName(LPCTSTR pszDevName);\r\n    BOOL GetOrientation(SHORT& sDMORIENT_) const;\r\n    VOID SetOrientation(SHORT sDMORIENT_);\r\n    BOOL GetPaperSize(SHORT& sDMPAPER_) const;\r\n    VOID SetPaperSize(SHORT sDMPAPER_);\r\n    BOOL GetPaperLength(SHORT& sTenthsOfMillimeter) const;\r\n    VOID SetPaperLength(SHORT sTenthsOfMillimeter);\r\n    BOOL GetPaperWidth(SHORT& sTenthsOfMillimeter) const;\r\n    VOID SetPaperWidth(SHORT sTenthsOfMillimeter);\r\n    BOOL GetScale(SHORT& s) const;\r\n    VOID SetScale(SHORT s);\r\n    BOOL GetCopies(SHORT& sNumber) const;\r\n    VOID SetCopies(SHORT sNumber);\r\n    BOOL GetDefaultSource(SHORT& s) const;\r\n    VOID SetDefaultSource(SHORT s);\r\n    BOOL GetPrintQuality(SHORT& sDMRES_) const;\r\n    VOID SetPrintQuality(SHORT sDMRES_);\r\n    BOOL GetColor(SHORT& sDMCOLOR_) const;\r\n    VOID SetColor(SHORT sDMCOLOR_);\r\n    BOOL GetDuplex(SHORT& sDMDUP_) const;\r\n    VOID SetDuplex(SHORT sDMDUP_);\r\n    BOOL GetYResolution(SHORT& sDotsPerInch) const;\r\n    VOID SetYResolution(SHORT sDotsPerInch);\r\n    BOOL GetTTOption(SHORT& sDMTT_) const;\r\n    VOID SetTTOption(SHORT sDMTT_);\r\n    BOOL GetCollate(SHORT& sDMCOLLATE_) const;\r\n    VOID SetCollate(SHORT sDMCOLLATE_);\r\n    LPCTSTR GetFormName() const;\r\n    VOID SetFormName(LPCTSTR pszFormName);\r\n    BOOL GetLogPixels(WORD& wPixelsPerInch) const;\r\n    VOID SetLogPixels(WORD wPixelsPerInch);\r\n    BOOL GetBitsPerPel(DWORD& dwBitsPerPixel) const;\r\n    VOID SetBitsPerPel(DWORD dwBitsPerPixel);\r\n    BOOL GetPelsWidth(DWORD& dwPixels) const;\r\n    VOID SetPelsWidth(DWORD dwPixels);\r\n    BOOL GetPelsHeight(DWORD& dwPixels) const;\r\n    VOID SetPelsHeight(DWORD dwPixels);\r\n    BOOL GetDisplayFlags(DWORD& dwDM_GRAYSCALEorINTERLACED) const;\r\n    VOID SetDisplayFlags(DWORD dwDM_GRAYSCALEorINTERLACED);\r\n    BOOL GetDisplayFrequency(DWORD& dwHertz) const;\r\n    VOID SetDisplayFrequency(DWORD dwHertz);\r\n#if (WINVER >= 0x0400) \r\n    BOOL GetICMMethod(DWORD& dwDMICMMETHOD_) const;\r\n    VOID SetICMMethod(DWORD dwDMICMMETHOD_);\r\n    BOOL GetICMIntent(DWORD& dwDMICM_) const;\r\n    VOID SetICMIntent(DWORD dwDMICM_);\r\n    BOOL GetMediaType(DWORD& dwDMMEDIA_) const;\r\n    VOID SetMediaType(DWORD dwDMMEDIA_);\r\n    BOOL GetDitherType(DWORD& dwDMDITHER_) const;\r\n    VOID SetDitherType(DWORD dwDMDITHER_);\r\n#endif  // (WINVER >= 0x0400) \r\n#if (WINVER >= 0x0500 || _WIN32_WINNT >= 0x0400)\r\n    BOOL GetPanningWidth(DWORD& dw) const;\r\n    VOID SetPanningWidth(DWORD dw);\r\n    BOOL GetPanningHeight(DWORD& dw) const;\r\n    VOID SetPanningHeight(DWORD dw);\r\n#endif  // (WINVER >= 0x0500 || _WIN32_WINNT >= 0x0400)\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MPrintDialog : public MCommonDialog\r\n{\r\npublic:\r\n    PRINTDLG m_pd;\r\n\r\n    /* before main */\r\n    MPrintDialog(HWND hwndOwner,\r\n                 DWORD dwPD_ = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS |\r\n                               PD_HIDEPRINTTOFILE | PD_NOSELECTION,\r\n                 BOOL bPrintSetup = FALSE);\r\n    virtual ~MPrintDialog();\r\n\r\n    /* main */\r\n    BOOL PrintDlg();\r\n    BOOL GetDefaults();\r\n\r\n    /* after main */\r\n    HDC CreatePrinterDC();\r\n    HDC GetPrinterDC() const;\r\n    HGLOBAL DetachDevNames();\r\n    HGLOBAL DetachDevMode();\r\n\r\n    MString GetDriverName() const;\r\n    MString GetDeviceName() const;\r\n    MString GetPortName() const;\r\n\r\n    INT GetCopies() const;\r\n    INT GetFromPage() const;\r\n    INT GetToPage() const;\r\n    BOOL PrintAll() const;\r\n    BOOL PrintCollate() const;\r\n    BOOL PrintRange() const;\r\n    BOOL PrintSelection() const;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline HDC MZCAPI CreatePrinterDCDx(HGLOBAL hDevNames, HGLOBAL hDevMode)\r\n{\r\n    HDC hPrinterDC = NULL;\r\n    MDevNames *pDevNames = (MDevNames *)GlobalLock(hDevNames);\r\n    if (pDevNames)\r\n    {\r\n        MDevMode *pDevMode = (MDevMode *)GlobalLock(hDevMode);\r\n        hPrinterDC = ::CreateDC(pDevNames->GetDriverName(),\r\n                                pDevNames->GetDeviceName(),\r\n                                pDevNames->GetPortName(),\r\n                                pDevMode);\r\n        GlobalUnlock(hDevMode);\r\n    }\r\n    GlobalUnlock(hDevNames);\r\n    return hPrinterDC;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline LPCTSTR MDevNames::GetDriverName() const\r\n{\r\n    const TCHAR *psz = reinterpret_cast<const TCHAR *>(this);\r\n    return psz + wDriverOffset;\r\n}\r\n\r\ninline LPCTSTR MDevNames::GetDeviceName() const\r\n{\r\n    const TCHAR *psz = reinterpret_cast<const TCHAR *>(this);\r\n    return psz + wDeviceOffset;\r\n}\r\n\r\ninline LPCTSTR MDevNames::GetPortName() const\r\n{\r\n    const TCHAR *psz = reinterpret_cast<const TCHAR *>(this);\r\n    return psz + wOutputOffset;\r\n}\r\n\r\ninline BOOL MDevNames::IsDefault() const\r\n{\r\n    return (wDefault & DN_DEFAULTPRN);\r\n}\r\n\r\ninline /*static*/ HGLOBAL MDevNames::CloneHandleDx(HGLOBAL hDevNames)\r\n{\r\n    MDevNames *pDevNames = reinterpret_cast<MDevNames *>(::GlobalLock(hDevNames));\r\n    return MDevNames::CreateDevNames(pDevNames->GetDriverName(),\r\n        pDevNames->GetDeviceName(), pDevNames->GetPortName());\r\n}\r\n\r\ninline /*static*/ HGLOBAL MDevNames::CreateDevNames(\r\n    LPCTSTR pszDriverName, LPCTSTR pszDeviceName, LPCTSTR pszPortName,\r\n    WORD wDefault/* = 0*/)\r\n{\r\n    if (!pszDriverName || !pszDeviceName || !pszPortName)\r\n        return NULL;\r\n\r\n    const INT cchDriverName = lstrlen(pszDriverName);\r\n    const INT cchDeviceName = lstrlen(pszDeviceName);\r\n    const INT cchPortName = lstrlen(pszPortName);\r\n    const DWORD cb = 4 * sizeof(WORD) + (\r\n        cchDriverName + 1 + cchDeviceName + 1 + cchPortName + 1) * sizeof(TCHAR);\r\n    HGLOBAL hDevNames = ::GlobalAlloc(GPTR, cb);\r\n    if (hDevNames == NULL)\r\n        return NULL;\r\n\r\n    LPDEVNAMES pDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);\r\n    if (pDevNames)\r\n    {\r\n        LPTSTR psz = reinterpret_cast<LPTSTR>(pDevNames);\r\n\r\n        pDevNames->wDriverOffset = sizeof(WORD) * 4;\r\n        lstrcpy(psz + pDevNames->wDriverOffset, pszDriverName);\r\n\r\n        pDevNames->wDeviceOffset = pDevNames->wDriverOffset + (cchDriverName + 1);\r\n        pDevNames->wDeviceOffset += (cchDriverName + 1) * sizeof(TCHAR);\r\n        lstrcpy(psz + pDevNames->wDeviceOffset, pszDeviceName);\r\n\r\n        pDevNames->wOutputOffset = pDevNames->wDeviceOffset + (cchDeviceName + 1);\r\n        pDevNames->wOutputOffset += (cchDeviceName + 1) * sizeof(TCHAR);\r\n        lstrcpy(psz + pDevNames->wOutputOffset, pszPortName);\r\n\r\n        pDevNames->wDefault = wDefault;\r\n        ::GlobalUnlock(hDevNames);\r\n    }\r\n\r\n    return hDevNames;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline LPCTSTR MDevMode::GetDeviceName() const\r\n{\r\n    return LPCTSTR(dmDeviceName[0] ? dmDeviceName : NULL);\r\n}\r\n\r\ninline VOID MDevMode::SetDeviceName(LPCTSTR pszDevName)\r\n{\r\n    lstrcpyn(LPTSTR(dmDeviceName), pszDevName, CCHDEVICENAME);\r\n}\r\n\r\ninline BOOL MDevMode::GetOrientation(SHORT& sDMORIENT_) const\r\n{\r\n    if (dmFields & DM_ORIENTATION)\r\n    {\r\n        sDMORIENT_ = dmOrientation;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetOrientation(SHORT sDMORIENT_)\r\n{\r\n    assert(sDMORIENT_ == DMORIENT_LANDSCAPE ||\r\n           sDMORIENT_ == DMORIENT_PORTRAIT);\r\n    dmFields |= DM_ORIENTATION;\r\n    dmOrientation = sDMORIENT_;\r\n}\r\n\r\ninline BOOL MDevMode::GetPaperSize(SHORT& sDMPAPER_) const\r\n{\r\n    if (dmFields & DM_PAPERSIZE)\r\n    {\r\n        sDMPAPER_ = dmPaperSize;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPaperSize(SHORT sDMPAPER_)\r\n{\r\n    dmFields |= DM_PAPERSIZE;\r\n    dmPaperSize = sDMPAPER_;\r\n}\r\n\r\ninline BOOL MDevMode::GetPaperLength(SHORT& sTenthsOfMillimeter) const\r\n{\r\n    if (dmFields & DM_PAPERLENGTH)\r\n    {\r\n        sTenthsOfMillimeter = dmPaperLength;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPaperLength(SHORT sTenthsOfMillimeter)\r\n{\r\n    dmFields |= DM_PAPERLENGTH;\r\n    dmPaperLength = sTenthsOfMillimeter;\r\n}\r\n\r\ninline BOOL MDevMode::GetPaperWidth(SHORT& sTenthsOfMillimeter) const\r\n{\r\n    if (dmFields & DM_PAPERWIDTH)\r\n    {\r\n        sTenthsOfMillimeter = dmPaperWidth;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPaperWidth(SHORT sTenthsOfMillimeter)\r\n{\r\n    dmFields |= DM_PAPERWIDTH;\r\n    dmPaperWidth = sTenthsOfMillimeter;\r\n}\r\n\r\ninline BOOL MDevMode::GetScale(SHORT& s) const\r\n{\r\n    if (dmFields & DM_SCALE)\r\n    {\r\n        s = dmScale;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetScale(SHORT s)\r\n{\r\n    dmFields |= DM_SCALE;\r\n    dmScale = s;\r\n}\r\n\r\ninline BOOL MDevMode::GetCopies(SHORT& sNumber) const\r\n{\r\n    if (dmFields & DM_COPIES)\r\n    {\r\n        sNumber = dmCopies;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetCopies(SHORT sNumber)\r\n{\r\n    dmFields |= DM_COPIES;\r\n    dmCopies = sNumber;\r\n}\r\n\r\ninline BOOL MDevMode::GetDefaultSource(SHORT& s) const\r\n{\r\n    if (dmFields & DM_DEFAULTSOURCE)\r\n    {\r\n        s = dmDefaultSource;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetDefaultSource(SHORT s)\r\n{\r\n    dmFields |= DM_DEFAULTSOURCE;\r\n    dmDefaultSource = s;\r\n}\r\n\r\ninline BOOL MDevMode::GetPrintQuality(SHORT& sDMRES_) const\r\n{\r\n    if (dmFields & DM_PRINTQUALITY)\r\n    {\r\n        sDMRES_ = dmPrintQuality;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPrintQuality(SHORT sDMRES_)\r\n{\r\n    dmFields |= DM_PRINTQUALITY;\r\n    dmPrintQuality = sDMRES_;\r\n}\r\n\r\ninline BOOL MDevMode::GetColor(SHORT& sDMCOLOR_) const\r\n{\r\n    if (dmFields & DM_COLOR)\r\n    {\r\n        sDMCOLOR_ = dmColor;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetColor(SHORT sDMCOLOR_)\r\n{\r\n    assert(sDMCOLOR_ == DMCOLOR_MONOCHROME || sDMCOLOR_ == DMCOLOR_COLOR);\r\n    dmFields |= DM_COLOR;\r\n    dmColor = sDMCOLOR_;\r\n}\r\n\r\ninline BOOL MDevMode::GetDuplex(SHORT& sDMDUP_) const\r\n{\r\n    if (dmFields & DM_DUPLEX)\r\n    {\r\n        sDMDUP_ = dmDuplex;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetDuplex(SHORT sDMDUP_)\r\n{\r\n    assert(sDMDUP_ == DMDUP_SIMPLEX || sDMDUP_ == DMDUP_VERTICAL ||\r\n           sDMDUP_ == DMDUP_HORIZONTAL);\r\n    dmFields |= DM_DUPLEX;\r\n    dmDuplex = sDMDUP_;\r\n}\r\n\r\ninline BOOL MDevMode::GetYResolution(SHORT& sDotsPerInch) const\r\n{\r\n    if (dmFields & DM_YRESOLUTION)\r\n    {\r\n        sDotsPerInch = dmYResolution;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetYResolution(SHORT sDotsPerInch)\r\n{\r\n    dmFields |= DM_YRESOLUTION;\r\n    dmYResolution = sDotsPerInch;\r\n}\r\n\r\ninline BOOL MDevMode::GetTTOption(SHORT& sDMTT_) const\r\n{\r\n    if (dmFields & DM_TTOPTION)\r\n    {\r\n        sDMTT_ = dmTTOption;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetTTOption(SHORT sDMTT_)\r\n{\r\n    dmFields |= DM_TTOPTION;\r\n    dmTTOption = sDMTT_;\r\n}\r\n\r\ninline BOOL MDevMode::GetCollate(SHORT& sDMCOLLATE_) const\r\n{\r\n    if (dmFields & DM_COLLATE)\r\n    {\r\n        sDMCOLLATE_ = dmCollate;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetCollate(SHORT sDMCOLLATE_)\r\n{\r\n    dmFields |= DM_COLLATE;\r\n    dmCollate = sDMCOLLATE_;\r\n}\r\n\r\ninline LPCTSTR MDevMode::GetFormName() const\r\n{\r\n    return LPCTSTR(dmFormName[0] ? dmFormName : NULL);\r\n}\r\n\r\ninline VOID MDevMode::SetFormName(LPCTSTR pszFormName)\r\n{\r\n    lstrcpyn(LPTSTR(dmFormName), pszFormName, CCHFORMNAME);\r\n}\r\n\r\ninline BOOL MDevMode::GetLogPixels(WORD& wPixelsPerInch) const\r\n{\r\n    if (dmFields & DM_LOGPIXELS)\r\n    {\r\n        wPixelsPerInch = dmLogPixels;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetLogPixels(WORD wPixelsPerInch)\r\n{\r\n    dmFields |= DM_LOGPIXELS;\r\n    dmLogPixels = wPixelsPerInch;\r\n}\r\n\r\ninline BOOL MDevMode::GetBitsPerPel(DWORD& dwBitsPerPixel) const\r\n{\r\n    if (dmFields & DM_BITSPERPEL)\r\n    {\r\n        dwBitsPerPixel = dmBitsPerPel;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetBitsPerPel(DWORD dwBitsPerPixel)\r\n{\r\n    dmFields |= DM_BITSPERPEL;\r\n    dmBitsPerPel = dwBitsPerPixel;\r\n}\r\n\r\ninline BOOL MDevMode::GetPelsWidth(DWORD& dwPixels) const\r\n{\r\n    if (dmFields & DM_PELSWIDTH)\r\n    {\r\n        dwPixels = dmPelsWidth;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPelsWidth(DWORD dwPixels)\r\n{\r\n    dmFields |= DM_PELSWIDTH;\r\n    dmPelsWidth = dwPixels;\r\n}\r\n\r\ninline BOOL MDevMode::GetPelsHeight(DWORD& dwPixels) const\r\n{\r\n    if (dmFields & DM_PELSHEIGHT)\r\n    {\r\n        dwPixels = dmPelsHeight;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetPelsHeight(DWORD dwPixels)\r\n{\r\n    dmFields |= DM_PELSHEIGHT;\r\n    dmPelsHeight = dwPixels;\r\n}\r\n\r\ninline BOOL MDevMode::GetDisplayFlags(DWORD& dwDM_GRAYSCALEorINTERLACED) const\r\n{\r\n    if (dmFields & DM_DISPLAYFLAGS)\r\n    {\r\n        dwDM_GRAYSCALEorINTERLACED = dmDisplayFlags;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetDisplayFlags(DWORD dwDM_GRAYSCALEorINTERLACED)\r\n{\r\n#ifndef DM_GRAYSCALE\r\n    #define DM_GRAYSCALE    0x00000001\r\n#endif\r\n#ifndef DM_INTERLACED\r\n    #define DM_INTERLACED   0x00000002\r\n#endif\r\n    assert(dwDM_GRAYSCALEorINTERLACED == DM_GRAYSCALE ||\r\n           dwDM_GRAYSCALEorINTERLACED == DM_INTERLACED);\r\n    dmFields |= DM_DISPLAYFLAGS;\r\n    dmDisplayFlags = dwDM_GRAYSCALEorINTERLACED;\r\n}\r\n\r\ninline BOOL MDevMode::GetDisplayFrequency(DWORD& dwHertz) const\r\n{\r\n    if (dmFields & DM_DISPLAYFREQUENCY)\r\n    {\r\n        dwHertz = dmDisplayFrequency;\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline VOID MDevMode::SetDisplayFrequency(DWORD dwHertz)\r\n{\r\n    dmFields |= DM_DISPLAYFREQUENCY;\r\n    dmDisplayFrequency = dwHertz;\r\n}\r\n\r\n#if (WINVER >= 0x0400) \r\n    inline BOOL MDevMode::GetICMMethod(DWORD& dwDMICMMETHOD_) const\r\n    {\r\n        if (dmFields & DM_ICMMETHOD)\r\n        {\r\n            dwDMICMMETHOD_ = dmICMMethod;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetICMMethod(DWORD dwDMICMMETHOD_)\r\n    {\r\n        dmFields |= DM_ICMMETHOD;\r\n        dmICMMethod = dwDMICMMETHOD_;\r\n    }\r\n\r\n    inline BOOL MDevMode::GetICMIntent(DWORD& dwDMICM_) const\r\n    {\r\n        if (dmFields & DM_ICMINTENT)\r\n        {\r\n            dwDMICM_ = dmICMIntent;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetICMIntent(DWORD dwDMICM_)\r\n    {\r\n        dmFields |= DM_ICMINTENT;\r\n        dmICMIntent = dwDMICM_;\r\n    }\r\n\r\n    inline BOOL MDevMode::GetMediaType(DWORD& dwDMMEDIA_) const\r\n    {\r\n        if (dmFields & DM_MEDIATYPE)\r\n        {\r\n            dwDMMEDIA_ = dmMediaType;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetMediaType(DWORD dwDMMEDIA_)\r\n    {\r\n        dmFields |= DM_MEDIATYPE;\r\n        dmMediaType = dwDMMEDIA_;\r\n    }\r\n\r\n    inline BOOL MDevMode::GetDitherType(DWORD& dwDMDITHER_) const\r\n    {\r\n        if (dmFields & DM_DITHERTYPE)\r\n        {\r\n            dwDMDITHER_ = dmDitherType;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetDitherType(DWORD dwDMDITHER_)\r\n    {\r\n        dmFields |= DM_DITHERTYPE;\r\n        dmDitherType = dwDMDITHER_;\r\n    }\r\n#endif  // (WINVER >= 0x0400) \r\n\r\n#if (WINVER >= 0x0500 || _WIN32_WINNT >= 0x0400)\r\n    inline BOOL MDevMode::GetPanningWidth(DWORD& dw) const\r\n    {\r\n        if (dmFields & DM_PANNINGWIDTH)\r\n        {\r\n            dw = dmPanningWidth;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetPanningWidth(DWORD dw)\r\n    {\r\n        dmFields |= DM_PANNINGWIDTH;\r\n        dmPanningWidth = dw;\r\n    }\r\n\r\n    inline BOOL MDevMode::GetPanningHeight(DWORD& dw) const\r\n    {\r\n        if (dmFields & DM_PANNINGHEIGHT)\r\n        {\r\n            dw = dmPanningHeight;\r\n            return TRUE;\r\n        }\r\n        return FALSE;\r\n    }\r\n\r\n    inline VOID MDevMode::SetPanningHeight(DWORD dw)\r\n    {\r\n        dmFields |= DM_PANNINGHEIGHT;\r\n        dmPanningHeight = dw;\r\n    }\r\n#endif  // (WINVER >= 0x0500 || _WIN32_WINNT >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MPrintDialog::MPrintDialog(\r\n    HWND hwndOwner,\r\n    DWORD dwPD_/* = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | \\\r\n                    PD_HIDEPRINTTOFILE | PD_NOSELECTION*/,\r\n    BOOL bPrintSetup/* = FALSE*/) : MCommonDialog(hwndOwner)\r\n{\r\n    m_bModal = TRUE;\r\n    ZeroMemory(&m_pd, sizeof(m_pd));\r\n    m_pd.lStructSize = sizeof(m_pd);\r\n    m_pd.hwndOwner = hwndOwner;\r\n    m_pd.Flags = dwPD_ | PD_RETURNDC;\r\n    if (bPrintSetup)\r\n        m_pd.Flags |= PD_PRINTSETUP;\r\n}\r\n\r\ninline /*virtual*/ MPrintDialog::~MPrintDialog()\r\n{\r\n    GlobalFree(m_pd.hDevMode);\r\n    GlobalFree(m_pd.hDevNames);\r\n    DeleteDC(m_pd.hDC);\r\n}\r\n\r\ninline BOOL MPrintDialog::PrintDlg()\r\n{\r\n    return ::PrintDlg(&m_pd);\r\n}\r\n\r\ninline INT MPrintDialog::GetFromPage() const\r\n{\r\n    return m_pd.nFromPage;\r\n}\r\n\r\ninline INT MPrintDialog::GetToPage() const\r\n{\r\n    return m_pd.nToPage;\r\n}\r\n\r\ninline HDC MPrintDialog::CreatePrinterDC()\r\n{\r\n    ::DeleteDC(m_pd.hDC);\r\n    m_pd.hDC = CreatePrinterDCDx(m_pd.hDevNames, m_pd.hDevMode);\r\n    return m_pd.hDC;\r\n}\r\n\r\ninline HDC MPrintDialog::GetPrinterDC() const\r\n{\r\n    assert(m_pd.Flags & PD_RETURNDC);\r\n    return m_pd.hDC;\r\n}\r\n\r\ninline HGLOBAL MPrintDialog::DetachDevNames()\r\n{\r\n    HGLOBAL hDevNames = m_pd.hDevNames;\r\n    m_pd.hDevNames = NULL;\r\n    return hDevNames;\r\n}\r\n\r\ninline HGLOBAL MPrintDialog::DetachDevMode()\r\n{\r\n    HGLOBAL hDevMode = m_pd.hDevMode;\r\n    m_pd.hDevMode = NULL;\r\n    return hDevMode;\r\n}\r\n\r\ninline BOOL MPrintDialog::GetDefaults()\r\n{\r\n    m_pd.Flags |= PD_RETURNDEFAULT;\r\n    return ::PrintDlg(&m_pd);\r\n}\r\n\r\ninline MString MPrintDialog::GetDriverName() const\r\n{\r\n    MString str;\r\n    if (m_pd.hDevNames)\r\n    {\r\n        MDevNames *pDevNames = (MDevNames *)GlobalLock(m_pd.hDevNames);\r\n        str = pDevNames->GetDriverName();\r\n        GlobalUnlock(m_pd.hDevNames);\r\n    }\r\n    return str;\r\n}\r\n\r\ninline MString MPrintDialog::GetDeviceName() const\r\n{\r\n    MString str;\r\n    if (m_pd.hDevNames)\r\n    {\r\n        MDevNames *pDevNames = (MDevNames *)GlobalLock(m_pd.hDevNames);\r\n        str = pDevNames->GetDeviceName();\r\n        GlobalUnlock(m_pd.hDevNames);\r\n    }\r\n    return str;\r\n}\r\n\r\ninline MString MPrintDialog::GetPortName() const\r\n{\r\n    MString str;\r\n    if (m_pd.hDevNames)\r\n    {\r\n        MDevNames *pDevNames = (MDevNames *)GlobalLock(m_pd.hDevNames);\r\n        str = pDevNames->GetPortName();\r\n        GlobalUnlock(m_pd.hDevNames);\r\n    }\r\n    return str;\r\n}\r\n\r\ninline INT MPrintDialog::GetCopies() const\r\n{\r\n    return m_pd.nCopies;\r\n}\r\n\r\ninline BOOL MPrintDialog::PrintAll() const\r\n{\r\n    return (m_pd.Flags & PD_ALLPAGES) != 0;\r\n}\r\n\r\ninline BOOL MPrintDialog::PrintCollate() const\r\n{\r\n    return (m_pd.Flags & PD_COLLATE) != 0;\r\n}\r\n\r\ninline BOOL MPrintDialog::PrintRange() const\r\n{\r\n    return (m_pd.Flags & PD_PAGENUMS) != 0;\r\n}\r\n\r\ninline BOOL MPrintDialog::PrintSelection() const\r\n{\r\n    return (m_pd.Flags & PD_SELECTION) != 0;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPRINTDIALOG_HPP_\r\n
MProcessMaker.hpp<>MProcessMaker.hpp<>// MProcessMaker.hpp -- Win32API process maker                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPROCESSMAKER_HPP_\r\n#define MZC4_MPROCESSMAKER_HPP_     10   /* Version 10 */\r\n\r\n#include "MFile.hpp"\r\n#include <tchar.h>\r\n#include <string>\r\n#include <cstring>\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MProcessMaker\r\n{\r\npublic:\r\n    MProcessMaker();\r\n    MProcessMaker(LPCTSTR pszAppName, LPCTSTR pszCommandLine = NULL,\r\n                  LPCTSTR pszzEnvironment = NULL, BOOL bInherit = TRUE,\r\n                  LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,\r\n                  LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);\r\n    virtual ~MProcessMaker();\r\n\r\n    bool operator!() const;\r\n    operator HANDLE() const;\r\n    HANDLE Handle() const;\r\n\r\n    HANDLE  GetProcessHandle() const;\r\n    HANDLE  GetThreadHandle() const;\r\n    DWORD   GetExitCode() const;\r\n\r\n    // set attributes for child process\r\n    void SetShowWindow(INT nCmdShow = SW_HIDE);\r\n    void SetCreationFlags(DWORD dwFlags = CREATE_NEW_CONSOLE);\r\n    void SetCurrentDirectory(LPCTSTR pszCurDir);\r\n    void SetDesktop(LPTSTR lpDesktop);\r\n    void SetTitle(LPTSTR lpTitle);\r\n    void SetPosition(DWORD dwX, DWORD dwY);\r\n    void SetSize(DWORD dwXSize, DWORD dwYSize);\r\n    void SetCountChars(DWORD dwXCountChars, DWORD dwYCountChars);\r\n    void SetFillAttirbutes(DWORD dwFillAttribute);\r\n\r\n    void SetStdInput(HANDLE hStdIn);\r\n    void SetStdOutput(HANDLE hStdOut);\r\n    void SetStdError(HANDLE hStdErr);\r\n\r\n    BOOL PrepareForRedirect(PHANDLE phInputWrite, PHANDLE phOutputRead);\r\n    BOOL PrepareForRedirect(PHANDLE phInputWrite, PHANDLE phOutputRead,\r\n                            PHANDLE phErrorRead);\r\n\r\n    BOOL CreateProcessDx(LPCTSTR pszAppName, LPCTSTR pszCommandLine = NULL,\r\n                         LPCTSTR pszzEnvironment = NULL, BOOL bInherit = TRUE,\r\n                         LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,\r\n                         LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);\r\n    BOOL CreateProcessAsUserDx(HANDLE hToken, LPCTSTR pszAppName,\r\n                               LPCTSTR pszCommandLine = NULL,\r\n                               LPCTSTR pszzEnvironment = NULL,\r\n                               BOOL bInherit = TRUE,\r\n                               LPSECURITY_ATTRIBUTES lpProcessAttributes = NULL,\r\n                               LPSECURITY_ATTRIBUTES lpThreadAttributes = NULL);\r\n    DWORD WaitForSingleObject(DWORD dwTimeout = INFINITE);\r\n    DWORD WaitForSingleObjectEx(DWORD dwTimeout = INFINITE,\r\n                                BOOL bAlertable = TRUE);\r\n    BOOL TerminateProcess(UINT uExitCode);\r\n    BOOL IsRunning() const;\r\n\r\n    void CloseProcessHandle();\r\n    void CloseThreadHandle();\r\n    void CloseStdInput();\r\n    void CloseStdOutput();\r\n    void CloseStdError();\r\n\r\n    void CloseAll();\r\n\r\n          PROCESS_INFORMATION& ProcessInfo();\r\n    const PROCESS_INFORMATION& ProcessInfo() const;\r\n          STARTUPINFO& StartupInfo();\r\n    const STARTUPINFO& StartupInfo() const;\r\n\r\n    void ReadAll(std::string& strOutput, MFile& hOutputRead);\r\n\r\nprotected:\r\n    PROCESS_INFORMATION     m_pi;\r\n    STARTUPINFO             m_si;\r\n    DWORD                   m_dwCreationFlags;\r\n    LPCTSTR                 m_pszCurDir;\r\n\r\n    void Init();\r\n\r\nprivate:\r\n    // NOTE: MProcessMaker is not copyable.\r\n    MProcessMaker(const MProcessMaker&);\r\n    MProcessMaker& operator=(const MProcessMaker&);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MProcessMaker::MProcessMaker()\r\n{\r\n    Init();\r\n}\r\n\r\ninline /*virtual*/ MProcessMaker::~MProcessMaker()\r\n{\r\n    CloseAll();\r\n}\r\n\r\ninline MProcessMaker::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline HANDLE MProcessMaker::Handle() const\r\n{\r\n    return (this ? m_pi.hProcess : NULL);\r\n}\r\n\r\ninline BOOL MProcessMaker::TerminateProcess(UINT uExitCode)\r\n{\r\n    return ::TerminateProcess(m_pi.hProcess, uExitCode);\r\n}\r\n\r\ninline void MProcessMaker::SetStdInput(HANDLE hStdIn)\r\n{\r\n    m_si.hStdInput = hStdIn;\r\n    if (hStdIn)\r\n        m_si.dwFlags |= STARTF_USESTDHANDLES;\r\n}\r\n\r\ninline void MProcessMaker::SetStdOutput(HANDLE hStdOut)\r\n{\r\n    m_si.hStdOutput = hStdOut;\r\n    if (hStdOut)\r\n        m_si.dwFlags |= STARTF_USESTDHANDLES;\r\n}\r\n\r\ninline void MProcessMaker::SetStdError(HANDLE hStdErr)\r\n{\r\n    m_si.hStdError = hStdErr;\r\n    if (hStdErr)\r\n        m_si.dwFlags |= STARTF_USESTDHANDLES;\r\n}\r\n\r\ninline void MProcessMaker::SetShowWindow(INT nCmdShow/* = SW_HIDE*/)\r\n{\r\n    m_si.wShowWindow = static_cast<WORD>(nCmdShow);\r\n    m_si.dwFlags |= STARTF_USESHOWWINDOW;\r\n}\r\n\r\ninline void MProcessMaker::SetCreationFlags(\r\n    DWORD dwFlags/* = CREATE_NEW_CONSOLE*/)\r\n{\r\n    m_dwCreationFlags = dwFlags;\r\n}\r\n\r\ninline void MProcessMaker::SetCurrentDirectory(LPCTSTR pszCurDir)\r\n{\r\n    m_pszCurDir = pszCurDir;\r\n}\r\n\r\ninline void MProcessMaker::SetDesktop(LPTSTR lpDesktop)\r\n{\r\n    m_si.lpDesktop = lpDesktop;\r\n}\r\n\r\ninline void MProcessMaker::SetTitle(LPTSTR lpTitle)\r\n{\r\n    m_si.lpTitle = lpTitle;\r\n}\r\n\r\ninline void MProcessMaker::SetPosition(DWORD dwX, DWORD dwY)\r\n{\r\n    m_si.dwX = dwX;\r\n    m_si.dwY = dwY;\r\n    m_si.dwFlags |= STARTF_USEPOSITION;\r\n}\r\n\r\ninline void MProcessMaker::SetSize(DWORD dwXSize, DWORD dwYSize)\r\n{\r\n    m_si.dwXSize = dwXSize;\r\n    m_si.dwYSize = dwYSize;\r\n    m_si.dwFlags |= STARTF_USESIZE;\r\n}\r\n\r\ninline void MProcessMaker::SetCountChars(\r\n    DWORD dwXCountChars, DWORD dwYCountChars)\r\n{\r\n    m_si.dwXCountChars = dwXCountChars;\r\n    m_si.dwYCountChars = dwYCountChars;\r\n    m_si.dwFlags |= STARTF_USECOUNTCHARS;\r\n}\r\n\r\ninline void MProcessMaker::SetFillAttirbutes(DWORD dwFillAttribute)\r\n{\r\n    m_si.dwFillAttribute = dwFillAttribute;\r\n    m_si.dwFlags |= STARTF_USEFILLATTRIBUTE;\r\n}\r\n\r\ninline HANDLE MProcessMaker::GetProcessHandle() const\r\n{\r\n    return (this ? m_pi.hProcess : NULL);\r\n}\r\n\r\ninline HANDLE MProcessMaker::GetThreadHandle() const\r\n{\r\n    return (this ? m_pi.hThread : NULL);\r\n}\r\n\r\ninline DWORD MProcessMaker::GetExitCode() const\r\n{\r\n    assert(m_pi.hProcess);\r\n    DWORD dwExitCode;\r\n    ::GetExitCodeProcess(m_pi.hProcess, &dwExitCode);\r\n    return dwExitCode;\r\n}\r\n\r\ninline DWORD MProcessMaker::WaitForSingleObject(DWORD dwTimeout/* = INFINITE*/)\r\n{\r\n    assert(m_pi.hProcess);\r\n    return ::WaitForSingleObject(m_pi.hProcess, dwTimeout);\r\n}\r\n\r\ninline DWORD MProcessMaker::WaitForSingleObjectEx(\r\n    DWORD dwTimeout/* = INFINITE*/, BOOL bAlertable/* = TRUE*/)\r\n{\r\n    assert(m_pi.hProcess);\r\n    return ::WaitForSingleObjectEx(m_pi.hProcess, dwTimeout, bAlertable);\r\n}\r\n\r\ninline BOOL MProcessMaker::IsRunning() const\r\n{\r\n    return (GetProcessHandle() &&\r\n            ::WaitForSingleObject(m_pi.hProcess, 0) == WAIT_TIMEOUT);\r\n}\r\n\r\ninline bool MProcessMaker::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline PROCESS_INFORMATION& MProcessMaker::ProcessInfo()\r\n{\r\n    return m_pi;\r\n}\r\n\r\ninline STARTUPINFO& MProcessMaker::StartupInfo()\r\n{\r\n    return m_si;\r\n}\r\n\r\ninline const PROCESS_INFORMATION& MProcessMaker::ProcessInfo() const\r\n{\r\n    return m_pi;\r\n}\r\n\r\ninline const STARTUPINFO& MProcessMaker::StartupInfo() const\r\n{\r\n    return m_si;\r\n}\r\n\r\ninline void MProcessMaker::CloseProcessHandle()\r\n{\r\n    if (m_pi.hProcess != NULL)\r\n    {\r\n        ::CloseHandle(m_pi.hProcess);\r\n        m_pi.hProcess = NULL;\r\n    }\r\n}\r\n\r\ninline void MProcessMaker::CloseThreadHandle()\r\n{\r\n    if (m_pi.hThread != NULL)\r\n    {\r\n        ::CloseHandle(m_pi.hThread);\r\n        m_pi.hThread = NULL;\r\n    }\r\n}\r\n\r\ninline void MProcessMaker::CloseStdInput()\r\n{\r\n    HANDLE hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\r\n    if (m_si.hStdInput != hStdInput)\r\n    {\r\n        ::CloseHandle(m_si.hStdInput);\r\n        m_si.hStdInput = hStdInput;\r\n    }\r\n}\r\n\r\ninline void MProcessMaker::CloseStdOutput()\r\n{\r\n    HANDLE hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\r\n    if (m_si.hStdOutput != hStdOutput)\r\n    {\r\n        ::CloseHandle(m_si.hStdOutput);\r\n        m_si.hStdOutput = hStdOutput;\r\n    }\r\n}\r\n\r\ninline void MProcessMaker::CloseStdError()\r\n{\r\n    HANDLE hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\r\n    if (m_si.hStdError != hStdError)\r\n    {\r\n        ::CloseHandle(m_si.hStdError);\r\n        m_si.hStdError = hStdError;\r\n    }\r\n}\r\n\r\ninline void MProcessMaker::CloseAll()\r\n{\r\n    CloseProcessHandle();\r\n    CloseThreadHandle();\r\n    CloseStdInput();\r\n    CloseStdOutput();\r\n    CloseStdError();\r\n}\r\n\r\ninline BOOL MProcessMaker::PrepareForRedirect(\r\n    PHANDLE phInputWrite, PHANDLE phOutputRead)\r\n{\r\n    return PrepareForRedirect(phInputWrite, phOutputRead, phOutputRead);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline void MProcessMaker::Init()\r\n{\r\n    ZeroMemory(&m_si, sizeof(m_si));\r\n    m_si.cb = sizeof(STARTUPINFO);\r\n\r\n    ZeroMemory(&m_pi, sizeof(m_pi));\r\n    m_dwCreationFlags = 0;\r\n    m_pszCurDir = NULL;\r\n    m_si.hStdInput = ::GetStdHandle(STD_INPUT_HANDLE);\r\n    m_si.hStdOutput = ::GetStdHandle(STD_OUTPUT_HANDLE);\r\n    m_si.hStdError = ::GetStdHandle(STD_ERROR_HANDLE);\r\n}\r\n\r\ninline MProcessMaker::MProcessMaker(\r\n    LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,\r\n    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,\r\n    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)\r\n{\r\n    Init();\r\n    CreateProcessDx(pszAppName, pszCommandLine, pszzEnvironment,\r\n        bInherit, lpProcessAttributes, lpThreadAttributes);\r\n}\r\n\r\ninline BOOL MProcessMaker::CreateProcessDx(\r\n    LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,\r\n    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,\r\n    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)\r\n{\r\n    using namespace std;\r\n    BOOL b;\r\n    LPTSTR pszCmdLine = _tcsdup(pszCommandLine);\r\n    LPCVOID pcEnv = reinterpret_cast<LPCVOID>(pszzEnvironment);\r\n    LPVOID pEnv = const_cast<LPVOID>(pcEnv);\r\n    DWORD dwCreationFlags = m_dwCreationFlags;\r\n    if (pszCmdLine)\r\n    {\r\n        #ifdef UNICODE\r\n            if (pEnv)\r\n                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;\r\n            b = ::CreateProcess(pszAppName, pszCmdLine, \r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #else\r\n            b = ::CreateProcess(pszAppName, pszCmdLine, \r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv,\r\n                m_pszCurDir, &m_si, &m_pi);\r\n        #endif\r\n        free(pszCmdLine);\r\n    }\r\n    else\r\n    {\r\n        #ifdef UNICODE\r\n            if (pEnv)\r\n                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;\r\n            b = ::CreateProcess(pszAppName, NULL,\r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags,\r\n                pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #else\r\n            b = ::CreateProcess(pszAppName, NULL,\r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv,\r\n                m_pszCurDir, &m_si, &m_pi);\r\n        #endif\r\n    }\r\n    return b;\r\n}\r\n\r\ninline BOOL MProcessMaker::CreateProcessAsUserDx(\r\n    HANDLE hToken, LPCTSTR pszAppName, LPCTSTR pszCommandLine/* = NULL*/,\r\n    LPCTSTR pszzEnvironment/* = NULL*/, BOOL bInherit/* = TRUE*/,\r\n    LPSECURITY_ATTRIBUTES lpProcessAttributes/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpThreadAttributes/* = NULL*/)\r\n{\r\n    using namespace std;\r\n    BOOL b;\r\n    LPTSTR pszCmdLine = _tcsdup(pszCommandLine);\r\n    LPCVOID pcEnv = reinterpret_cast<LPCVOID>(pszzEnvironment);\r\n    LPVOID pEnv = const_cast<LPVOID>(pcEnv);\r\n    DWORD dwCreationFlags = m_dwCreationFlags;\r\n    if (pszCmdLine)\r\n    {\r\n        LPTSTR pszCmdLine = const_cast<LPTSTR>(pszCommandLine);\r\n        #ifdef UNICODE\r\n            if (pEnv)\r\n                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;\r\n            b = ::CreateProcessAsUser(hToken, pszAppName, pszCmdLine,\r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #else\r\n            b = ::CreateProcessAsUser(hToken, pszAppName, pszCmdLine,\r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #endif\r\n        free(pszCmdLine);\r\n    }\r\n    else\r\n    {\r\n        #ifdef UNICODE\r\n            if (pEnv)\r\n                dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;\r\n            b = ::CreateProcessAsUser(hToken, pszAppName, NULL, \r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #else\r\n            b = ::CreateProcessAsUser(hToken, pszAppName, NULL, \r\n                lpProcessAttributes, lpThreadAttributes,\r\n                bInherit, dwCreationFlags, pEnv, m_pszCurDir, &m_si, &m_pi);\r\n        #endif\r\n    }\r\n    return b;\r\n}\r\n\r\ninline BOOL MProcessMaker::PrepareForRedirect(\r\n    PHANDLE phInputWrite, PHANDLE phOutputRead, PHANDLE phErrorRead)\r\n{\r\n    SECURITY_ATTRIBUTES sa;\r\n    sa.nLength = sizeof(sa);\r\n    sa.lpSecurityDescriptor = NULL;\r\n    sa.bInheritHandle = TRUE;\r\n\r\n    MFile hInputRead, hInputWriteTmp;\r\n    MFile hOutputReadTmp, hOutputWrite;\r\n    MFile hErrorReadTmp, hErrorWrite;\r\n\r\n    if (phInputWrite)\r\n    {\r\n        if (::CreatePipe(&hInputRead, &hInputWriteTmp, &sa, 0))\r\n        {\r\n            if (!hInputWriteTmp.DuplicateHandle(phInputWrite, FALSE))\r\n                return FALSE;\r\n            hInputWriteTmp.CloseHandle();\r\n        }\r\n        else\r\n            return FALSE;\r\n    }\r\n\r\n    if (phOutputRead)\r\n    {\r\n        if (::CreatePipe(&hOutputReadTmp, &hOutputWrite, &sa, 0))\r\n        {\r\n            if (!hOutputReadTmp.DuplicateHandle(phOutputRead, FALSE))\r\n                return FALSE;\r\n            hOutputReadTmp.CloseHandle();\r\n        }\r\n        else\r\n            return FALSE;\r\n    }\r\n\r\n    if (phOutputRead && phOutputRead == phErrorRead)\r\n    {\r\n        if (!hOutputWrite.DuplicateHandle(&hErrorWrite, TRUE))\r\n            return FALSE;\r\n    }\r\n    else if (phErrorRead)\r\n    {\r\n        if (::CreatePipe(&hErrorReadTmp, &hErrorWrite, &sa, 0))\r\n        {\r\n            if (!hErrorReadTmp.DuplicateHandle(phErrorRead, FALSE))\r\n                return FALSE;\r\n            hErrorReadTmp.CloseHandle();\r\n        }\r\n        else\r\n            return FALSE;\r\n    }\r\n\r\n    if (phInputWrite != NULL)\r\n        SetStdInput(hInputRead.Detach());\r\n    if (phOutputRead != NULL)\r\n        SetStdOutput(hOutputWrite.Detach());\r\n    if (phErrorRead != NULL)\r\n        SetStdError(hErrorWrite.Detach());\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline void\r\nMProcessMaker::ReadAll(std::string& strOutput, MFile& hOutputRead)\r\n{\r\n    strOutput.clear();\r\n\r\n    DWORD cbAvail, cbRead;\r\n    CHAR szBuf[1024];\r\n    while (hOutputRead.PeekNamedPipe(NULL, 0, NULL, &cbAvail))\r\n    {\r\n        if (cbAvail == 0)\r\n        {\r\n            if (!IsRunning())\r\n                break;\r\n\r\n            continue;\r\n        }\r\n\r\n        if (cbAvail > sizeof(szBuf))\r\n            cbAvail = sizeof(szBuf);\r\n        else if (cbAvail == 0)\r\n            continue;\r\n\r\n        if (hOutputRead.ReadFile(szBuf, cbAvail, &cbRead))\r\n        {\r\n            if (cbRead == 0)\r\n                continue;\r\n\r\n            strOutput.append(szBuf, cbRead);\r\n        }\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPROCESSMAKER_HPP_\r\n
MProgressBar.hpp<>MProgressBar.hpp<>// MProgressBar.hpp -- Win32API progress bar wrapper            -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MPROGRESSBAR_HPP_\r\n#define MZC4_MPROGRESSBAR_HPP_      2       /* Version 2 */\r\n\r\nclass MProgressBar;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MProgressBar : public MWindowBase\r\n{\r\npublic:\r\n    MProgressBar();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    VOID SetRange(SHORT nLower, SHORT nUpper);\r\n#if (_WIN32_IE >= 0x0300)\r\n    VOID GetRange(INT& nLower, INT& nUpper);\r\n    VOID SetRange32(INT nLower, INT nUpper);\r\n\r\n    INT GetPos();\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n    INT SetPos(INT nPos);\r\n    INT OffsetPos(INT nPos);\r\n    INT SetStep(INT nStep);\r\n    INT StepIt();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MProgressBar::MProgressBar()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MProgressBar::GetWndClassNameDx() const\r\n{\r\n    return PROGRESS_CLASS;\r\n}\r\n\r\ninline VOID MProgressBar::SetRange(SHORT nLower, SHORT nUpper)\r\n{\r\n    SendMessageDx(PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline VOID MProgressBar::SetRange32(INT nLower, INT nUpper)\r\n    {\r\n        SendMessageDx(PBM_SETRANGE32, (WPARAM)nLower, (LPARAM)nUpper);\r\n    }\r\n\r\n    inline VOID MProgressBar::GetRange(INT& nLower, INT& nUpper)\r\n    {\r\n        PBRANGE range;\r\n        ZeroMemory(&range, sizeof(range));\r\n        SendMessageDx(PBM_GETRANGE, TRUE, (LPARAM)&range);\r\n        nLower = range.iLow;\r\n        nUpper = range.iHigh;\r\n    }\r\n\r\n    inline INT MProgressBar::GetPos()\r\n    {\r\n        return (INT)SendMessageDx(PBM_GETPOS);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline INT MProgressBar::SetPos(INT nPos)\r\n{\r\n    return (INT)SendMessageDx(PBM_SETPOS, (WPARAM)nPos);\r\n}\r\n\r\ninline INT MProgressBar::OffsetPos(INT nPos)\r\n{\r\n    return (INT)SendMessageDx(PBM_DELTAPOS, (WPARAM)nPos);\r\n}\r\n\r\ninline INT MProgressBar::SetStep(INT nStep)\r\n{\r\n    return (INT)SendMessageDx(PBM_SETSTEP, (WPARAM)nStep);\r\n}\r\n\r\ninline INT MProgressBar::StepIt()\r\n{\r\n    return (INT)SendMessageDx(PBM_STEPIT);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MPROGRESSBAR_HPP_\r\n
MReBarCtrl.hpp<>MReBarCtrl.hpp<>// MReBarCtrl.hpp -- Win32API rebar control wrapper             -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MREBARCTRL_HPP_\r\n#define MZC4_MREBARCTRL_HPP_        2       /* Version 2 */\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MReBarCtrl;\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    class MReBarCtrl : public MWindowBase\r\n    {\r\n    public:\r\n        MReBarCtrl();\r\n        virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n        virtual HWND SetParent(HWND hWndNewParent);\r\n\r\n        UINT GetBandCount() const;\r\n\r\n        BOOL GetBandInfo(UINT uBand, REBARBANDINFO* prbbi) const;\r\n        BOOL SetBandInfo(UINT uBand, REBARBANDINFO* prbbi);\r\n\r\n        BOOL GetBarInfo(REBARINFO* prbi) const;\r\n        BOOL SetBarInfo(REBARINFO* prbi);\r\n\r\n        HIMAGELIST GetImageList() const;\r\n        BOOL SetImageList(HIMAGELIST hImageList);\r\n\r\n        INT GetRowCount() const;\r\n        INT GetRowHeight(UINT uRow) const;\r\n\r\n        BOOL InsertBand(INT nIndex, REBARBANDINFO* prbbi);\r\n        BOOL AddBand(LPREBARBANDINFO lprbbi);\r\n        BOOL DeleteBand(INT nIndex);\r\n\r\n        HWND SetNotifyWnd(HWND hWnd);\r\n\r\n        VOID AutoSize();\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        COLORREF GetTextColor() const;\r\n        COLORREF SetTextColor(COLORREF clr);\r\n\r\n        BOOL GetColorScheme(COLORSCHEME* lpcs);\r\n        VOID SetColorScheme(const COLORSCHEME* lpcs);\r\n\r\n        COLORREF GetBkColor() const;\r\n        COLORREF SetBkColor(COLORREF clr);\r\n\r\n        UINT GetBarHeight() const;\r\n        BOOL GetRect(UINT uBand, LPRECT prc) const;\r\n\r\n        HWND GetToolTips() const;\r\n        VOID SetToolTips(HWND hwndToolTips);\r\n\r\n        VOID GetBandBorders(UINT uBand, LPRECT prc) const;\r\n\r\n        HPALETTE GetPalette() const;\r\n        HPALETTE SetPalette(HPALETTE hPal);\r\n\r\n        VOID BeginDrag(INT nIndex, DWORD dwPos = (DWORD)-1);\r\n        VOID BeginDrag(INT nIndex, INT xPos, INT yPos);\r\n        VOID EndDrag();\r\n        VOID DragMove(DWORD dwPos = (DWORD)-1);\r\n        VOID DragMove(INT xPos, INT yPos);\r\n\r\n        VOID MaximizeBand(UINT uBand, BOOL bIdeal = FALSE);\r\n        VOID MinimizeBand(UINT uBand);\r\n\r\n        BOOL SizeToRect(LPRECT prc);\r\n        INT IDToIndex(UINT uBandID) const;\r\n\r\n        BOOL ShowBand(INT nBand, BOOL fShow = TRUE);\r\n        BOOL MoveBand(INT nFrom, INT nTo);\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n    #if (_WIN32_IE >= 0x0500)\r\n        INT HitTest(RBHITTESTINFO *prbht);\r\n    #endif  // (_WIN32_IE >= 0x0500)\r\n    };\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline MReBarCtrl::MReBarCtrl()\r\n    {\r\n    }\r\n\r\n    inline /*virtual*/ LPCTSTR MReBarCtrl::GetWndClassNameDx() const\r\n    {\r\n        return REBARCLASSNAME;\r\n    }\r\n\r\n    inline UINT MReBarCtrl::GetBandCount() const\r\n    {\r\n        return (UINT)SendMessageDx(RB_GETBANDCOUNT);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::GetBandInfo(UINT uBand, REBARBANDINFO* prbbi) const\r\n    {\r\n        return (BOOL)SendMessageDx(RB_GETBANDINFO, uBand, (LPARAM)prbbi);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::SetBandInfo(UINT uBand, REBARBANDINFO* prbbi)\r\n    {\r\n        return (BOOL)SendMessageDx(RB_SETBANDINFO, uBand, (LPARAM)prbbi);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::GetBarInfo(REBARINFO* prbi) const\r\n    {\r\n        return (BOOL)SendMessageDx(RB_GETBARINFO, 0, (LPARAM)prbi);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::SetBarInfo(REBARINFO* prbi)\r\n    {\r\n        return (BOOL)SendMessageDx(RB_SETBARINFO, 0, (LPARAM)prbi);\r\n    }\r\n\r\n    inline HIMAGELIST MReBarCtrl::GetImageList() const\r\n    {\r\n        REBARINFO rbi;\r\n        ZeroMemory(&rbi, sizeof(REBARINFO));\r\n        rbi.cbSize = sizeof(REBARINFO);\r\n        rbi.fMask = RBIM_IMAGELIST;\r\n        if (!(BOOL)SendMessageDx(RB_GETBARINFO, 0, (LPARAM)&rbi))\r\n            return NULL;\r\n        return rbi.himl;\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::SetImageList(HIMAGELIST hImageList)\r\n    {\r\n        REBARINFO rbi;\r\n        ZeroMemory(&rbi, sizeof(REBARINFO));\r\n        rbi.cbSize = sizeof(REBARINFO);\r\n        rbi.fMask = RBIM_IMAGELIST;\r\n        rbi.himl = hImageList;\r\n        return (BOOL)SendMessageDx(RB_SETBARINFO, 0, (LPARAM)&rbi);\r\n    }\r\n\r\n    inline INT MReBarCtrl::GetRowCount() const\r\n    {\r\n        return (INT)SendMessageDx(RB_GETROWCOUNT);\r\n    }\r\n\r\n    inline INT MReBarCtrl::GetRowHeight(UINT uRow) const\r\n    {\r\n        return (INT)SendMessageDx(RB_GETROWHEIGHT, uRow);\r\n    }\r\n\r\n    inline VOID MReBarCtrl::AutoSize()\r\n    {\r\n        SendMessageDx(WM_SIZE);\r\n    }\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        inline COLORREF MReBarCtrl::GetTextColor() const\r\n        {\r\n            return (COLORREF)SendMessageDx(RB_GETTEXTCOLOR);\r\n        }\r\n\r\n        inline COLORREF MReBarCtrl::SetTextColor(COLORREF clr)\r\n        {\r\n            return (COLORREF)SendMessageDx(RB_SETTEXTCOLOR, 0, (LPARAM)clr);\r\n        }\r\n\r\n        inline BOOL MReBarCtrl::GetColorScheme(COLORSCHEME* lpcs)\r\n        {\r\n            assert(lpcs);\r\n            return (BOOL)SendMessageDx(RB_GETCOLORSCHEME, 0, (LPARAM)lpcs);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::SetColorScheme(const COLORSCHEME* lpcs)\r\n        {\r\n            assert(lpcs);\r\n            SendMessageDx(RB_SETCOLORSCHEME, 0, (LPARAM)lpcs);\r\n        }\r\n\r\n        inline COLORREF MReBarCtrl::GetBkColor() const\r\n        {\r\n            return (COLORREF)SendMessageDx(RB_GETBKCOLOR);\r\n        }\r\n\r\n        inline COLORREF MReBarCtrl::SetBkColor(COLORREF clr)\r\n        {\r\n            return (COLORREF)SendMessageDx(RB_SETBKCOLOR, 0, (LPARAM)clr);\r\n        }\r\n\r\n        inline UINT MReBarCtrl::GetBarHeight() const\r\n        {\r\n            return (UINT)SendMessageDx(RB_GETBARHEIGHT);\r\n        }\r\n\r\n        inline BOOL MReBarCtrl::GetRect(UINT uBand, LPRECT prc) const\r\n        {\r\n            assert(prc);\r\n            return (BOOL)SendMessageDx(RB_GETRECT, uBand, (LPARAM)prc);\r\n        }\r\n\r\n        inline HWND MReBarCtrl::GetToolTips() const\r\n        {\r\n            return (HWND)SendMessageDx(RB_GETTOOLTIPS);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::SetToolTips(HWND hwndToolTips)\r\n        {\r\n            SendMessageDx(RB_SETTOOLTIPS, (WPARAM)hwndToolTips);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::GetBandBorders(UINT uBand, LPRECT prc) const\r\n        {\r\n            assert(prc);\r\n            SendMessageDx(RB_GETBANDBORDERS, uBand, (LPARAM)prc);\r\n        }\r\n\r\n        inline HPALETTE MReBarCtrl::GetPalette() const\r\n        {\r\n            return (HPALETTE)SendMessageDx(RB_GETPALETTE);\r\n        }\r\n\r\n        inline HPALETTE MReBarCtrl::SetPalette(HPALETTE hPal)\r\n        {\r\n            return (HPALETTE)SendMessageDx(RB_SETPALETTE, 0, (LPARAM)hPal);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::BeginDrag(INT nIndex, DWORD dwPos/* = (DWORD)-1*/)\r\n        {\r\n            SendMessageDx(RB_BEGINDRAG, (WPARAM)nIndex, (LPARAM)dwPos);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::BeginDrag(INT nIndex, INT xPos, INT yPos)\r\n        {\r\n            return BeginDrag(nIndex, MAKELONG(xPos, yPos));\r\n        }\r\n\r\n        inline VOID MReBarCtrl::EndDrag()\r\n        {\r\n            SendMessageDx(RB_ENDDRAG);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::DragMove(DWORD dwPos/* = (DWORD)-1*/)\r\n        {\r\n            SendMessageDx(RB_DRAGMOVE, 0, (LPARAM)dwPos);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::DragMove(INT xPos, INT yPos)\r\n        {\r\n            DragMove(MAKELONG(xPos, yPos));\r\n        }\r\n\r\n        inline VOID MReBarCtrl::MaximizeBand(UINT uBand, BOOL bIdeal/* = FALSE*/)\r\n        {\r\n            SendMessageDx(RB_MAXIMIZEBAND, uBand, bIdeal);\r\n        }\r\n\r\n        inline VOID MReBarCtrl::MinimizeBand(UINT uBand)\r\n        {\r\n            SendMessageDx(RB_MINIMIZEBAND, uBand);\r\n        }\r\n\r\n        inline BOOL MReBarCtrl::SizeToRect(LPRECT prc)\r\n        {\r\n            return (BOOL)SendMessageDx(RB_SIZETORECT, 0, (LPARAM)prc);\r\n        }\r\n\r\n        inline INT MReBarCtrl::IDToIndex(UINT uBandID) const\r\n        {\r\n            return (INT)SendMessageDx(RB_IDTOINDEX, uBandID);\r\n        }\r\n\r\n        inline BOOL MReBarCtrl::ShowBand(INT nBand, BOOL fShow/* = TRUE*/)\r\n        {\r\n            return (BOOL)SendMessageDx(RB_SHOWBAND, (WPARAM)nBand, (LPARAM)fShow);\r\n        }\r\n\r\n        inline BOOL MReBarCtrl::MoveBand(INT nFrom, INT nTo)\r\n        {\r\n            assert(0 <= nTo && nTo < (INT) GetBandCount());\r\n            return (BOOL)SendMessageDx(RB_MOVEBAND, (WPARAM)nFrom, (LPARAM)nTo);\r\n        }\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    inline BOOL MReBarCtrl::InsertBand(INT nIndex, REBARBANDINFO* prbbi)\r\n    {\r\n        return (BOOL)SendMessageDx(RB_INSERTBAND, (WPARAM)nIndex, (LPARAM)prbbi);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::AddBand(REBARBANDINFO* prbbi)\r\n    {\r\n        return InsertBand(-1, prbbi);\r\n    }\r\n\r\n    inline BOOL MReBarCtrl::DeleteBand(INT nIndex)\r\n    {\r\n        return (BOOL)SendMessageDx(RB_DELETEBAND, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline HWND MReBarCtrl::SetNotifyWnd(HWND hWnd)\r\n    {\r\n        assert(::IsWindow(hWnd));\r\n        return (HWND)SendMessageDx(RB_SETPARENT, (WPARAM)hWnd);\r\n    }\r\n\r\n    #if (_WIN32_IE >= 0x0500)\r\n        inline INT MReBarCtrl::HitTest(RBHITTESTINFO *prbht)\r\n        {\r\n            return (INT)SendMessageDx(RB_HITTEST, 0, (LPARAM)prbht);\r\n        }\r\n    #endif  // (_WIN32_IE >= 0x0500)\r\n\r\n    inline /*virtual*/ HWND MReBarCtrl::SetParent(HWND hWndNewParent)\r\n    {\r\n        HWND hWnd2 = ::SetParent(m_hwnd, hWndNewParent);\r\n        HWND hWnd = (HWND)SendMessageDx(RB_SETPARENT, (WPARAM)hWndNewParent);\r\n        if (hWnd2)\r\n            hWnd = hWnd2;\r\n        return hWnd;\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MREBARCTRL_HPP_\r\n
MRegKey.hpp<>MRegKey.hpp<>// MRegKey.hpp -- Win32API registry key manipulator             -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MREGKEY_HPP_\r\n#define MZC4_MREGKEY_HPP_       7   /* Version 7 */\r\n\r\n#ifndef HKCR\r\n    #define HKCR    HKEY_CLASSES_ROOT\r\n    #define HKCU    HKEY_CURRENT_USER\r\n    #define HKLM    HKEY_LOCAL_MACHINE\r\n    #define HKU     HKEY_USERS\r\n    #define HKPD    HKEY_PERFORMANCE_DATA\r\n    #define HKCC    HKEY_CURRENT_CONFIG\r\n    #define HKDD    HKEY_DYN_DATA\r\n#endif\r\n\r\nclass MRegKey;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n#include <new>              // std::nothrow\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n// NOTE: RegDeleteTreeDx deletes all value entries if pszSubKey == NULL.\r\n// NOTE: RegDeleteTreeDx cannot delete opening keys.\r\nLONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey/* = NULL*/);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MRegKey\r\n{\r\npublic:\r\n    MRegKey();\r\n    MRegKey(HKEY hKey);\r\n    MRegKey(MRegKey& key);\r\n    MRegKey(HKEY hBaseKey, LPCTSTR pszSubKey, BOOL bCreate = FALSE);\r\n    virtual ~MRegKey();\r\n\r\n    operator HKEY() const;\r\n    bool operator!() const;\r\n    bool operator==(HKEY hKey) const;\r\n    bool operator!=(HKEY hKey) const;\r\n    MRegKey& operator=(HKEY hKey);\r\n    MRegKey& operator=(MRegKey& key);\r\n\r\n    BOOL Attach(HKEY hKey);\r\n    HKEY Detach();\r\n    HKEY Handle() const;\r\n\r\n    LONG RegCreateKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey, DWORD dwReserved = 0,\r\n                        LPTSTR lpClass = NULL, DWORD dwOptions = 0,\r\n                        REGSAM samDesired = KEY_ALL_ACCESS,\r\n                        LPSECURITY_ATTRIBUTES lpsa = NULL,\r\n                        LPDWORD lpdwDisposition = NULL);\r\n    LONG RegOpenKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey, DWORD dwOptions = 0,\r\n                      REGSAM samDesired = KEY_READ);\r\n\r\n    LONG RegConnectRegistry(LPCTSTR lpMachineName, HKEY hBaseKey);\r\n\r\n    LONG RegCloseKey();\r\n\r\n    LONG RegQueryValueEx(LPCTSTR pszValueName = NULL,\r\n                         LPDWORD lpReserved = NULL, LPDWORD lpType = NULL,\r\n                         LPBYTE lpData = NULL, LPDWORD lpcbData = NULL);\r\n\r\n    LONG QueryBinary(LPCTSTR pszValueName, LPVOID pvValue, DWORD cb);\r\n    LONG QueryDword(LPCTSTR pszValueName, DWORD& dw);\r\n    LONG QueryDwordLE(LPCTSTR pszValueName, DWORD& dw);\r\n    LONG QueryDwordBE(LPCTSTR pszValueName, DWORD& dw);\r\n    LONG QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);\r\n    LONG QueryExpandSz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue);\r\n    LONG QueryMultiSz(LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues);\r\n    template <typename T_CONTAINER>\r\n    LONG QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container);\r\n    template <typename T_STRUCT>\r\n    LONG QueryStruct(LPCTSTR pszValueName, T_STRUCT& data);\r\n\r\n    template <typename T_STRING>\r\n    LONG QuerySz(LPCTSTR pszValueName, T_STRING& strValue);\r\n    template <typename T_STRING>\r\n    LONG QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue);\r\n\r\n    LONG RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved,\r\n        DWORD dwType, CONST BYTE *lpData, DWORD cbData);\r\n\r\n    LONG SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb);\r\n    LONG SetDword(LPCTSTR pszValueName, DWORD dw);\r\n    LONG SetDwordLE(LPCTSTR pszValueName, DWORD dw);\r\n    LONG SetDwordBE(LPCTSTR pszValueName, DWORD dw);\r\n    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);\r\n    LONG SetSz(LPCTSTR pszValueName, LPCTSTR pszValue);\r\n    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue);\r\n    LONG SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue);\r\n    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues);\r\n    LONG SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues);\r\n    template <typename T_CONTAINER>\r\n    LONG SetMultiSz(LPCTSTR pszValueName, const T_CONTAINER& container);\r\n    template <typename T_STRUCT>\r\n    LONG SetStruct(LPCTSTR pszValueName, const T_STRUCT& data);\r\n\r\n    LONG RegDeleteValue(LPCTSTR pszValueName);\r\n    LONG RegDeleteTreeDx(LPCTSTR pszSubKey);\r\n    LONG RegEnumKeyEx(DWORD dwIndex, LPTSTR lpName, LPDWORD lpcchName,\r\n                      LPDWORD lpReserved = NULL, LPTSTR lpClass = NULL,\r\n                      LPDWORD lpcchClass = NULL,\r\n                      PFILETIME lpftLastWriteTime = NULL);\r\n    LONG RegEnumValue(DWORD dwIndex, LPTSTR lpName, LPDWORD lpcchName,\r\n                      LPDWORD lpReserved = NULL, LPDWORD lpType = NULL,\r\n                      LPBYTE lpData = NULL, LPDWORD lpcbData = NULL);\r\n\r\n    LONG RegFlushKey();\r\n    LONG RegGetKeySecurity(SECURITY_INFORMATION si,\r\n                           PSECURITY_DESCRIPTOR pSD, LPDWORD pcbSD);\r\n\r\n    LONG RegNotifyChangeKeyValue(BOOL bWatchSubTree = TRUE,\r\n        DWORD dwFilter = REG_LEGAL_CHANGE_FILTER,\r\n        HANDLE hEvent = NULL, BOOL bAsyncronous = FALSE);\r\n\r\n    LONG RegQueryInfoKey(LPTSTR lpClass = NULL,\r\n        LPDWORD lpcchClass = NULL,\r\n        LPDWORD lpReserved = NULL,\r\n        LPDWORD lpcSubKeys = NULL,\r\n        LPDWORD lpcchMaxSubKeyLen = NULL,\r\n        LPDWORD lpcchMaxClassLen = NULL,\r\n        LPDWORD lpcValues = NULL,\r\n        LPDWORD lpcchMaxValueNameLen = NULL,\r\n        LPDWORD lpcbMaxValueLen = NULL,\r\n        LPDWORD lpcbSecurityDescriptor = NULL,\r\n        PFILETIME lpftLastWriteTime = NULL);\r\n\r\n    LONG RegQueryMultipleValues(PVALENT val_list, DWORD num_vals,\r\n                                LPTSTR lpValueBuf, LPDWORD lpdwTotsize);\r\n    LONG RegSetKeySecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR psd);\r\n    \r\n    static LONG RegLoadKey(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszFile);\r\n    static LONG RegUnLoadKey(HKEY hKey, LPCTSTR pszSubKey);\r\n    static LONG RegSaveKey(HKEY hKey, LPCTSTR pszFile,\r\n                           LPSECURITY_ATTRIBUTES lpsa = NULL);\r\n    static LONG RegRestoreKey(HKEY hKey, LPCTSTR pszFile, DWORD dwFlags);\r\n    static LONG RegReplaceKey(HKEY hKey, LPCTSTR pszSubKey,\r\n                              LPCTSTR pszNewFile, LPCTSTR pszOldFile);\r\n    static LONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey);\r\n    static DWORD MultiSzSizeDx(LPCTSTR pszz);\r\n\r\n    static HKEY CloneHandleDx(HKEY hKey);\r\n\r\nprotected:\r\n    HKEY m_hKey;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T_STRUCT>\r\ninline LONG MRegKey::QueryStruct(LPCTSTR pszValueName, T_STRUCT& data)\r\n{\r\n    assert(m_hKey);\r\n    DWORD cbData = static_cast<DWORD>(sizeof(data));\r\n    LONG result = ::RegQueryValueEx(m_hKey, pszValueName, NULL, NULL,\r\n        reinterpret_cast<LPBYTE>(&data), &cbData);\r\n    if (result == ERROR_SUCCESS && cbData != sizeof(data))\r\n        result = ERROR_INVALID_DATA;\r\n    return result;\r\n}\r\n\r\ntemplate <typename T_STRUCT>\r\ninline LONG MRegKey::SetStruct(LPCTSTR pszValueName, const T_STRUCT& data)\r\n{\r\n    assert(m_hKey);\r\n    const DWORD cbData = static_cast<DWORD>(sizeof(data));\r\n    return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_BINARY,\r\n        reinterpret_cast<const BYTE *>(&data), cbData);\r\n}\r\n\r\ntemplate <typename T_CONTAINER>\r\nLONG MRegKey::QueryMultiSz(LPCTSTR pszValueName, T_CONTAINER& container)\r\n{\r\n    container.clear();\r\n\r\n    LONG result;\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_MULTI_SZ);\r\n    #endif\r\n\r\n    DWORD cbData;\r\n    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);\r\n    if (result != ERROR_SUCCESS)\r\n        return result;\r\n\r\n    const DWORD cch = static_cast<DWORD>(cbData / sizeof(TCHAR) + 1);\r\n    LPTSTR pszz = new(std::nothrow) TCHAR[cch];\r\n    if (pszz)\r\n    {\r\n        result = QueryMultiSz(pszValueName, pszz, cch);\r\n        if (result == ERROR_SUCCESS)\r\n        {\r\n            for (LPTSTR pch = pszz; *pch; pch += lstrlen(pch) + 1)\r\n            {\r\n                #if (__cplusplus >= 201103L)\r\n                    container.emplace_back(pch);\r\n                #else\r\n                    container.push_back(pch);\r\n                #endif\r\n            }\r\n        }\r\n        delete[] pszz;\r\n    }\r\n    else\r\n        result = ERROR_OUTOFMEMORY;\r\n\r\n    return result;\r\n}\r\n\r\ntemplate <typename T_CONTAINER>\r\ninline LONG MRegKey::SetMultiSz(\r\n    LPCTSTR pszValueName, const T_CONTAINER& container)\r\n{\r\n    typename T_CONTAINER::value_type         str;\r\n    typename T_CONTAINER::const_iterator     it, end;\r\n\r\n    it = container.begin();\r\n    end = container.end();\r\n    if (it != end)\r\n    {\r\n        for (; it != end; ++it)\r\n        {\r\n            str += *it;\r\n            str += TEXT('\\0');\r\n        }\r\n    }\r\n    else\r\n    {\r\n        str += TEXT('\\0');\r\n    }\r\n\r\n    const DWORD cchValues = static_cast<DWORD>(str.size() + 1);\r\n    return SetMultiSz(pszValueName, str.c_str(), cchValues);\r\n}\r\n\r\ntemplate <typename T_STRING>\r\nLONG MRegKey::QuerySz(LPCTSTR pszValueName, T_STRING& strValue)\r\n{\r\n    LONG result;\r\n    strValue.clear();\r\n\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_SZ);\r\n    #endif\r\n\r\n    DWORD cbData;\r\n    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);\r\n    if (result != ERROR_SUCCESS)\r\n        return result;\r\n\r\n    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];\r\n    assert(psz);\r\n    if (psz)\r\n    {\r\n        result = RegQueryValueEx(pszValueName, NULL, NULL,\r\n                                 reinterpret_cast<LPBYTE>(psz), &cbData);\r\n        if (result != ERROR_SUCCESS)\r\n        {\r\n            strValue = psz;\r\n        }\r\n        delete[] psz;\r\n    }\r\n    return result;\r\n}\r\n\r\ntemplate <typename T_STRING>\r\nLONG MRegKey::QueryExpandSz(LPCTSTR pszValueName, T_STRING& strValue)\r\n{\r\n    LONG result;\r\n    strValue.clear();\r\n\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_EXPAND_SZ);\r\n    #endif\r\n\r\n    DWORD cbData;\r\n    result = RegQueryValueEx(pszValueName, NULL, NULL, NULL, &cbData);\r\n    if (result != ERROR_SUCCESS)\r\n        return result;\r\n\r\n    LPTSTR psz = new(std::nothrow) TCHAR[cbData / sizeof(TCHAR) + 1];\r\n    assert(psz);\r\n    if (psz)\r\n    {\r\n        result = RegQueryValueEx(pszValueName, NULL, NULL,\r\n                                 reinterpret_cast<LPBYTE>(psz), &cbData);\r\n        if (result != ERROR_SUCCESS)\r\n        {\r\n            strValue = psz;\r\n        }\r\n        delete[] psz;\r\n    }\r\n    return result;\r\n}\r\n\r\ninline MRegKey::MRegKey() : m_hKey(NULL)\r\n{\r\n}\r\n\r\ninline MRegKey::MRegKey(HKEY hKey) : m_hKey(hKey)\r\n{\r\n}\r\n\r\ninline MRegKey::MRegKey(\r\n    HKEY hBaseKey, LPCTSTR pszSubKey,\r\n    BOOL bCreate/* = FALSE*/) : m_hKey(NULL)\r\n{\r\n    if (bCreate)\r\n        RegCreateKeyEx(hBaseKey, pszSubKey);\r\n    else\r\n        RegOpenKeyEx(hBaseKey, pszSubKey);\r\n}\r\n\r\ninline MRegKey::MRegKey(MRegKey& key) : m_hKey(CloneHandleDx(key))\r\n{\r\n}\r\n\r\ninline /*virtual*/ MRegKey::~MRegKey()\r\n{\r\n    RegCloseKey();\r\n}\r\n\r\ninline HKEY MRegKey::Handle() const\r\n{\r\n    return (this ? m_hKey : NULL);\r\n}\r\n\r\ninline MRegKey::operator HKEY() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline bool MRegKey::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline bool MRegKey::operator==(HKEY hKey) const\r\n{\r\n    return Handle() == hKey;\r\n}\r\n\r\ninline bool MRegKey::operator!=(HKEY hKey) const\r\n{\r\n    return Handle() != hKey;\r\n}\r\n\r\ninline MRegKey& MRegKey::operator=(HKEY hKey)\r\n{\r\n    if (Handle() != hKey)\r\n    {\r\n        Attach(hKey);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MRegKey& MRegKey::operator=(MRegKey& key)\r\n{\r\n    if (Handle() != key.m_hKey)\r\n    {\r\n        HKEY hKey = CloneHandleDx(key);\r\n        Attach(hKey);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MRegKey::Attach(HKEY hKey)\r\n{\r\n    RegCloseKey();\r\n    m_hKey = hKey;\r\n    return m_hKey != NULL;\r\n}\r\n\r\ninline HKEY MRegKey::Detach()\r\n{\r\n    HKEY hKey = m_hKey;\r\n    m_hKey = NULL;\r\n    return hKey;\r\n}\r\n\r\ninline LONG MRegKey::RegCreateKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey,\r\n    DWORD dwReserved/* = 0*/, LPTSTR lpClass/* = NULL*/,\r\n    DWORD dwOptions/* = 0*/, REGSAM samDesired/* = KEY_ALL_ACCESS*/,\r\n    LPSECURITY_ATTRIBUTES lpsa/* = NULL*/,\r\n    LPDWORD lpdwDisposition/* = NULL*/)\r\n{\r\n    assert(m_hKey == NULL);\r\n    return ::RegCreateKeyEx(hBaseKey, pszSubKey, dwReserved,\r\n        lpClass, dwOptions, samDesired, lpsa, &m_hKey, lpdwDisposition);\r\n}\r\n\r\ninline LONG MRegKey::RegOpenKeyEx(HKEY hBaseKey, LPCTSTR pszSubKey,\r\n    DWORD dwOptions/* = 0*/, REGSAM samDesired/* = KEY_READ*/)\r\n{\r\n    assert(m_hKey == NULL);\r\n    return ::RegOpenKeyEx(hBaseKey, pszSubKey, dwOptions, samDesired,\r\n                          &m_hKey);\r\n}\r\n\r\ninline LONG\r\nMRegKey::RegConnectRegistry(LPCTSTR lpMachineName, HKEY hBaseKey)\r\n{\r\n    assert(m_hKey == NULL);\r\n    return ::RegConnectRegistry(lpMachineName, hBaseKey, &m_hKey);\r\n}\r\n\r\ninline LONG MRegKey::RegCloseKey()\r\n{\r\n    if (Handle())\r\n    {\r\n        LONG result = ::RegCloseKey(Detach());\r\n        return result;\r\n    }\r\n    return ERROR_INVALID_HANDLE;\r\n}\r\n\r\ninline LONG MRegKey::RegQueryValueEx(LPCTSTR pszValueName/* = NULL*/,\r\n    LPDWORD lpReserved/* = NULL*/, LPDWORD lpType/* = NULL*/,\r\n    LPBYTE lpData/* = NULL*/, LPDWORD lpcbData/* = NULL*/)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegQueryValueEx(m_hKey, pszValueName, lpReserved,\r\n        lpType, lpData, lpcbData);\r\n}\r\n\r\n\r\ninline LONG MRegKey::QueryBinary(\r\n    LPCTSTR pszValueName, LPVOID pvValue, DWORD cb)\r\n{\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,\r\n                                      NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_BINARY);\r\n    #endif\r\n    DWORD cbData = cb;\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(pvValue),\r\n                           &cbData);\r\n}\r\n\r\ninline LONG MRegKey::QueryDword(LPCTSTR pszValueName, DWORD& dw)\r\n{\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,\r\n                                      NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_DWORD);\r\n    #endif\r\n    DWORD cbData = sizeof(DWORD);\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(&dw), &cbData);\r\n}\r\n\r\ninline LONG MRegKey::QueryDwordLE(LPCTSTR pszValueName, DWORD& dw)\r\n{\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,\r\n                                      NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_DWORD_LITTLE_ENDIAN);\r\n    #endif\r\n    DWORD cbData = sizeof(DWORD);\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(&dw), &cbData);\r\n}\r\n\r\ninline LONG MRegKey::QueryDwordBE(LPCTSTR pszValueName, DWORD& dw)\r\n{\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,\r\n                                      NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_DWORD_BIG_ENDIAN);\r\n    #endif\r\n    DWORD cbData = sizeof(DWORD);\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(&dw), &cbData);\r\n}\r\n\r\ninline LONG\r\nMRegKey::QuerySz(LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)\r\n{\r\n    #ifndef NDEBUG\r\n        DWORD dwType;\r\n        LONG result = RegQueryValueEx(pszValueName, NULL, &dwType,\r\n                                      NULL, NULL);\r\n        assert(result == ERROR_SUCCESS);\r\n        assert(dwType == REG_SZ);\r\n    #endif\r\n    DWORD cbData = cchValue * sizeof(TCHAR);\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(pszValue), &cbData);\r\n}\r\n\r\ninline LONG MRegKey::QueryExpandSz(\r\n    LPCTSTR pszValueName, LPTSTR pszValue, DWORD cchValue)\r\n{\r\n#ifndef NDEBUG\r\n    DWORD dwType;\r\n    LONG result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);\r\n    assert(result == ERROR_SUCCESS);\r\n    assert(dwType == REG_EXPAND_SZ);\r\n#endif\r\n    DWORD cbData = cchValue * sizeof(TCHAR);\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(pszValue), &cbData);\r\n}\r\n\r\ninline LONG MRegKey::QueryMultiSz(\r\n    LPCTSTR pszValueName, LPTSTR pszzValues, DWORD cchValues)\r\n{\r\n#ifndef NDEBUG\r\n    DWORD dwType;\r\n    LONG result = RegQueryValueEx(pszValueName, NULL, &dwType, NULL, NULL);\r\n    assert(result == ERROR_SUCCESS);\r\n    assert(dwType == REG_MULTI_SZ);\r\n#endif\r\n    DWORD cbData = sizeof(TCHAR) * cchValues;\r\n    return RegQueryValueEx(pszValueName, NULL, NULL,\r\n                           reinterpret_cast<LPBYTE>(pszzValues), &cbData);\r\n}\r\n\r\ninline LONG MRegKey::RegSetValueEx(LPCTSTR pszValueName, DWORD dwReserved,\r\n    DWORD dwType, CONST BYTE *lpData, DWORD cbData)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegSetValueEx(m_hKey, pszValueName, dwReserved, dwType,\r\n        lpData, cbData);\r\n}\r\n\r\ninline LONG MRegKey::SetBinary(LPCTSTR pszValueName, LPCVOID pvValue, DWORD cb)\r\n{\r\n    return RegSetValueEx(pszValueName, 0, REG_BINARY,\r\n        reinterpret_cast<const BYTE *>(pvValue), cb);\r\n}\r\n\r\ninline LONG MRegKey::SetDword(LPCTSTR pszValueName, DWORD dw)\r\n{\r\n    DWORD dwValue = dw;\r\n    return RegSetValueEx(pszValueName, 0, REG_DWORD,\r\n        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));\r\n}\r\n\r\ninline LONG MRegKey::SetDwordLE(LPCTSTR pszValueName, DWORD dw)\r\n{\r\n    DWORD dwValue = dw;\r\n    return RegSetValueEx(pszValueName, 0, REG_DWORD_LITTLE_ENDIAN,\r\n        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));\r\n}\r\n\r\ninline LONG MRegKey::SetDwordBE(LPCTSTR pszValueName, DWORD dw)\r\n{\r\n    DWORD dwValue = dw;\r\n    return RegSetValueEx(pszValueName, 0, REG_DWORD_BIG_ENDIAN,\r\n        reinterpret_cast<const BYTE *>(&dwValue), sizeof(DWORD));\r\n}\r\n\r\ninline LONG\r\nMRegKey::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)\r\n{\r\n    return RegSetValueEx(pszValueName, 0, REG_SZ,\r\n        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));\r\n}\r\n\r\ninline LONG\r\nMRegKey::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD cchValue)\r\n{\r\n    return RegSetValueEx(pszValueName, 0, REG_EXPAND_SZ,\r\n        reinterpret_cast<const BYTE *>(pszValue), cchValue * sizeof(TCHAR));\r\n}\r\n\r\ninline LONG\r\nMRegKey::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues)\r\n{\r\n    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ,\r\n        reinterpret_cast<const BYTE *>(pszzValues),\r\n        MRegKey::MultiSzSizeDx(pszzValues));\r\n}\r\n\r\ninline LONG\r\nMRegKey::SetMultiSz(LPCTSTR pszValueName, LPCTSTR pszzValues, DWORD cchValues)\r\n{\r\n    DWORD cb = static_cast<DWORD>(sizeof(TCHAR) * cchValues);\r\n    return RegSetValueEx(pszValueName, 0, REG_MULTI_SZ,\r\n        reinterpret_cast<const BYTE *>(pszzValues), cb);\r\n}\r\n\r\ninline LONG MRegKey::RegDeleteValue(LPCTSTR pszValueName)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegDeleteValue(m_hKey, pszValueName);\r\n}\r\n\r\ninline LONG MRegKey::RegEnumKeyEx(DWORD dwIndex, LPTSTR lpName,\r\n    LPDWORD lpcchName, LPDWORD lpReserved/* = NULL*/,\r\n    LPTSTR lpClass/* = NULL*/, LPDWORD lpcchClass/* = NULL*/,\r\n    PFILETIME lpftLastWriteTime/* = NULL*/)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegEnumKeyEx(m_hKey, dwIndex, lpName, lpcchName,\r\n        lpReserved, lpClass, lpcchClass, lpftLastWriteTime);\r\n}\r\n\r\ninline LONG MRegKey::RegEnumValue(DWORD dwIndex, LPTSTR lpName,\r\n    LPDWORD lpcchName, LPDWORD lpReserved/* = NULL*/, LPDWORD lpType/* = NULL*/,\r\n    LPBYTE lpData/* = NULL*/, LPDWORD lpcbData/* = NULL*/)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegEnumValue(m_hKey, dwIndex, lpName, lpcchName, lpReserved,\r\n        lpType, lpData, lpcbData);\r\n}\r\n\r\ninline LONG MRegKey::RegFlushKey()\r\n{\r\n    assert(m_hKey);\r\n    return ::RegFlushKey(m_hKey);\r\n}\r\n\r\ninline LONG MRegKey::RegGetKeySecurity(SECURITY_INFORMATION si,\r\n    PSECURITY_DESCRIPTOR pSD, LPDWORD pcbSD)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegGetKeySecurity(m_hKey, si, pSD, pcbSD);\r\n}\r\n\r\ninline LONG MRegKey::RegNotifyChangeKeyValue(BOOL bWatchSubTree/* = TRUE*/,\r\n    DWORD dwFilter/* = REG_LEGAL_CHANGE_FILTER*/,\r\n    HANDLE hEvent/* = NULL*/, BOOL bAsyncronous/* = FALSE*/)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegNotifyChangeKeyValue(m_hKey, bWatchSubTree, dwFilter,\r\n        hEvent, bAsyncronous);\r\n}\r\n\r\ninline LONG MRegKey::RegQueryInfoKey(LPTSTR lpClass/* = NULL*/,\r\n    LPDWORD lpcchClass/* = NULL*/,\r\n    LPDWORD lpReserved/* = NULL*/,\r\n    LPDWORD lpcSubKeys/* = NULL*/,\r\n    LPDWORD lpcchMaxSubKeyLen/* = NULL*/,\r\n    LPDWORD lpcchMaxClassLen/* = NULL*/,\r\n    LPDWORD lpcValues/* = NULL*/,\r\n    LPDWORD lpcchMaxValueNameLen/* = NULL*/,\r\n    LPDWORD lpcbMaxValueLen/* = NULL*/,\r\n    LPDWORD lpcbSecurityDescriptor/* = NULL*/,\r\n    PFILETIME lpftLastWriteTime/* = NULL*/)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegQueryInfoKey(m_hKey, lpClass, lpcchClass,\r\n        lpReserved, lpcSubKeys, lpcchMaxSubKeyLen, lpcchMaxClassLen,\r\n        lpcValues, lpcchMaxValueNameLen, lpcbMaxValueLen,\r\n        lpcbSecurityDescriptor, lpftLastWriteTime);\r\n}\r\n\r\ninline LONG MRegKey::RegQueryMultipleValues(PVALENT val_list, DWORD num_vals,\r\n                            LPTSTR lpValueBuf, LPDWORD lpdwTotsize)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegQueryMultipleValues(\r\n        m_hKey, val_list, num_vals, lpValueBuf, lpdwTotsize);\r\n}\r\n\r\ninline LONG\r\nMRegKey::RegSetKeySecurity(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR psd)\r\n{\r\n    assert(m_hKey);\r\n    return ::RegSetKeySecurity(m_hKey, si, psd);\r\n}\r\n\r\ninline /*static*/ LONG\r\nMRegKey::RegLoadKey(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszFile)\r\n{\r\n    assert(pszSubKey);\r\n    assert(pszFile);\r\n    return ::RegLoadKey(hKey, pszSubKey, pszFile);\r\n}\r\n\r\ninline /*static*/ LONG MRegKey::RegUnLoadKey(HKEY hKey, LPCTSTR pszSubKey)\r\n{\r\n    assert(pszSubKey);\r\n    return ::RegUnLoadKey(hKey, pszSubKey);\r\n}\r\n\r\ninline /*static*/ LONG\r\nMRegKey::RegSaveKey(HKEY hKey, LPCTSTR pszFile,\r\n                    LPSECURITY_ATTRIBUTES lpsa/* = NULL*/)\r\n{\r\n    assert(pszFile);\r\n    return ::RegSaveKey(hKey, pszFile, lpsa);\r\n}\r\n\r\ninline /*static*/\r\nLONG MRegKey::RegRestoreKey(HKEY hKey, LPCTSTR pszFile, DWORD dwFlags)\r\n{\r\n    assert(pszFile);\r\n    return ::RegRestoreKey(hKey, pszFile, dwFlags);\r\n}\r\n\r\ninline /*static*/ LONG MRegKey::RegReplaceKey(\r\n    HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszNewFile, LPCTSTR pszOldFile)\r\n{\r\n    assert(pszNewFile);\r\n    assert(pszOldFile);\r\n    return ::RegReplaceKey(hKey, pszSubKey, pszNewFile, pszOldFile);\r\n}\r\n\r\ninline /*static*/ LONG MRegKey::RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey)\r\n{\r\n    return RegDeleteTreeDx(hKey, pszSubKey);\r\n}\r\n\r\ninline LONG MRegKey::SetSz(LPCTSTR pszValueName, LPCTSTR pszValue)\r\n{\r\n    return SetSz(pszValueName, pszValue, lstrlen(pszValue) + 1);\r\n}\r\n\r\ninline LONG MRegKey::SetExpandSz(LPCTSTR pszValueName, LPCTSTR pszValue)\r\n{\r\n    return SetExpandSz(pszValueName, pszValue, lstrlen(pszValue) + 1);\r\n}\r\n\r\ninline LONG MRegKey::RegDeleteTreeDx(LPCTSTR pszSubKey)\r\n{\r\n    assert(m_hKey);\r\n    return RegDeleteTreeDx(m_hKey, pszSubKey);\r\n}\r\n\r\ninline LONG RegDeleteTreeDx(HKEY hKey, LPCTSTR pszSubKey/* = NULL*/)\r\n{\r\n    LONG ret;\r\n    DWORD cchSubKeyMax, cchValueMax;\r\n    DWORD cchMax, cch;\r\n    TCHAR szNameBuf[MAX_PATH], *pszName = szNameBuf;\r\n    HKEY hSubKey = hKey;\r\n\r\n    if (pszSubKey != NULL)\r\n    {\r\n        ret = ::RegOpenKeyEx(hKey, pszSubKey, 0, KEY_READ, &hSubKey);\r\n        if (ret)\r\n            return ret;\r\n    }\r\n\r\n    ret = ::RegQueryInfoKey(hSubKey, NULL, NULL, NULL, NULL,\r\n        &cchSubKeyMax, NULL, NULL, &cchValueMax, NULL, NULL, NULL);\r\n    if (ret)\r\n        goto cleanup;\r\n\r\n    cchSubKeyMax++;\r\n    cchValueMax++;\r\n    if (cchSubKeyMax < cchValueMax)\r\n        cchMax = cchValueMax;\r\n    else\r\n        cchMax = cchSubKeyMax;\r\n    if (cchMax > sizeof(szNameBuf) / sizeof(TCHAR))\r\n    {\r\n        pszName = new(std::nothrow) TCHAR[cchMax * sizeof(TCHAR)];\r\n        if (pszName == NULL)\r\n            goto cleanup;\r\n    }\r\n\r\n    for(;;)\r\n    {\r\n        cch = cchMax;\r\n        if (::RegEnumKeyEx(hSubKey, 0, pszName, &cch, NULL,\r\n                           NULL, NULL, NULL))\r\n        {\r\n            break;\r\n        }\r\n\r\n        ret = RegDeleteTreeDx(hSubKey, pszName);\r\n        if (ret)\r\n            goto cleanup;\r\n    }\r\n\r\n    if (pszSubKey != NULL)\r\n    {\r\n        ret = ::RegDeleteKey(hKey, pszSubKey);\r\n    }\r\n    else\r\n    {\r\n        // NOTE: if pszSubKey was NULL, then delete value entries.\r\n        for (;;)\r\n        {\r\n            cch = cchMax;\r\n            if (::RegEnumValue(hKey, 0, pszName, &cch,\r\n                               NULL, NULL, NULL, NULL))\r\n            {\r\n                break;\r\n            }\r\n\r\n            ret = ::RegDeleteValue(hKey, pszName);\r\n            if (ret)\r\n                goto cleanup;\r\n        }\r\n    }\r\n\r\ncleanup:\r\n    if (pszSubKey != NULL)\r\n        ::RegCloseKey(hSubKey);\r\n    if (pszName != szNameBuf)\r\n        delete[] pszName;\r\n    return ret;\r\n}\r\n\r\ninline /*static*/ DWORD MRegKey::MultiSzSizeDx(LPCTSTR pszz)\r\n{\r\n    DWORD siz = 0;\r\n    if (*pszz)\r\n    {\r\n        do\r\n        {\r\n            INT len = lstrlen(pszz);\r\n            siz += len + 1;\r\n            pszz += len + 1;\r\n        }\r\n        while (*pszz);\r\n    }\r\n    else\r\n    {\r\n        ++siz;\r\n    }\r\n    ++siz;\r\n    siz *= static_cast<DWORD>(sizeof(TCHAR));\r\n    return siz;\r\n}\r\n\r\ninline /*static*/ HKEY MRegKey::CloneHandleDx(HKEY hKey)\r\n{\r\n    if (hKey == NULL)\r\n        return NULL;\r\n\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    HANDLE hDup = NULL;\r\n    ::DuplicateHandle(hProcess, hKey, hProcess, &hDup, 0,\r\n                      FALSE, DUPLICATE_SAME_ACCESS);\r\n    return reinterpret_cast<HKEY>(hDup);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MREGKEY_HPP_\r\n
MResizable.hpp<>MResizable.hpp<>// MResizable.hpp -- Win32 dynamic layout resizable window/dialog -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MRESIZABLE_HPP_\r\n#define MZC4_MRESIZABLE_HPP_        4   /* Version 4 */\r\n\r\nstruct MCtrlLayout;\r\nclass MResizable;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MPointSizeRect.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// layout anchors for MResizable::SetLayoutAnchor\r\n\r\n#define mzcLA_NO_ANCHOR        MSize(-1, -1)    // don't resize\r\n#define mzcLA_TOP_LEFT         MSize(0, 0)      // upper left\r\n#define mzcLA_TOP_CENTER       MSize(50, 0)     // upper center\r\n#define mzcLA_TOP_RIGHT        MSize(100, 0)    // upper right\r\n#define mzcLA_MIDDLE_LEFT      MSize(0, 50)     // middle left\r\n#define mzcLA_MIDDLE_CENTER    MSize(50, 50)    // middle center\r\n#define mzcLA_MIDDLE_RIGHT     MSize(100, 50)   // middle right\r\n#define mzcLA_BOTTOM_LEFT      MSize(0, 100)    // lower left\r\n#define mzcLA_BOTTOM_CENTER    MSize(50, 100)   // lower center\r\n#define mzcLA_BOTTOM_RIGHT     MSize(100, 100)  // lower right\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MResizable\r\n\r\n#include "MScrollBar.hpp"   // for MSizeGrip\r\n#include <vector>           // for std::vector\r\n\r\nclass MResizable\r\n{\r\nprotected:\r\n    struct MCtrlLayout\r\n    {\r\n        HWND m_hwndCtrl;\r\n        MSize m_sizLA_1, m_sizMargin1, m_sizLA_2, m_sizMargin2;\r\n\r\n        MCtrlLayout() { }\r\n\r\n        MCtrlLayout(HWND hwndCtrl, SIZE sizLA_1, SIZE sizMargin1,\r\n            SIZE sizLA_2, SIZE sizMargin2) : m_hwndCtrl(hwndCtrl),\r\n            m_sizLA_1(sizLA_1), m_sizMargin1(sizMargin1),\r\n            m_sizLA_2(sizLA_2), m_sizMargin2(sizMargin2)\r\n        {\r\n        }\r\n    };\r\npublic:\r\n    typedef MCtrlLayout                 layout_type;\r\n    typedef std::vector<MCtrlLayout>    layouts_type;\r\n\r\n    MResizable();\r\n    virtual ~MResizable();\r\n\r\n    // NOTE: Please call OnParentCreate after parent's WM_CREATE or WM_INITDIALOG.\r\n    VOID OnParentCreate(HWND hwnd, BOOL bEnableResize = TRUE,\r\n                        BOOL bShowSizeGrip = TRUE);\r\n\r\n    // NOTE: Please call OnSize on parent's WM_SIZE.\r\n    VOID OnSize(const RECT *prcClient = NULL);\r\n\r\n    // NOTE: Please call SetLayoutAnchor after OnParentCreate.\r\n    // NOTE: sizLA_1 is upper left anchor, sizLA_2 is lower right anchor.\r\n    VOID SetLayoutAnchor(HWND hwndCtrl,\r\n                         MSize sizLA_1, MSize sizLA_2 = mzcLA_NO_ANCHOR);\r\n    VOID SetLayoutAnchor(UINT nCtrlID,\r\n                         MSize sizLA_1, MSize sizLA_2 = mzcLA_NO_ANCHOR);\r\n\r\n          layout_type *CtrlLayout(HWND hwndCtrl);\r\n          layout_type *CtrlLayout(UINT nCtrlID);\r\n    const layout_type *CtrlLayout(HWND hwndCtrl) const;\r\n    const layout_type *CtrlLayout(UINT nCtrlID) const;\r\n\r\n    BOOL IsResizeEnabled() const;\r\n    VOID EnableResize(BOOL bEnableResize, BOOL bShowSizeGrip = TRUE);\r\n    VOID ClearLayouts();\r\n\r\nprotected:\r\n    HWND            m_hwndParent;\r\n    BOOL            m_bResizeEnabled;\r\n    MSizeGrip       m_size_grip;\r\n    layouts_type    m_layouts;\r\n\r\n    VOID ShowSizeGrip(BOOL bShow = TRUE);\r\n    VOID ModifyParentStyle(BOOL bEnableResize);\r\n    VOID MoveSizeGrip();\r\n    VOID ArrangeLayout(const RECT *prc);\r\n\r\nprivate:\r\n    // NOTE: MResizable is not copyable\r\n    MResizable(const MResizable& rsz);\r\n    MResizable& operator=(const MResizable& rsz);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MResizable::MResizable()\r\n    : m_hwndParent(NULL), m_bResizeEnabled(FALSE)\r\n{\r\n}\r\n\r\ninline /*virtual*/ MResizable::~MResizable()\r\n{\r\n}\r\n\r\ninline VOID MResizable::ClearLayouts()\r\n{\r\n    m_layouts.clear();\r\n}\r\n\r\ninline VOID MResizable::SetLayoutAnchor(\r\n    UINT nCtrlID, MSize sizLA_1, MSize sizLA_2/* = mzcLA_NO_ANCHOR*/)\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n    assert(sizLA_1 != mzcLA_NO_ANCHOR);\r\n    MResizable::SetLayoutAnchor(\r\n        GetDlgItem(m_hwndParent, nCtrlID), sizLA_1, sizLA_2);\r\n}\r\n\r\ninline VOID MResizable::OnSize(const RECT *prcClient/* = NULL*/)\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n\r\n    ArrangeLayout(prcClient);\r\n    MoveSizeGrip();\r\n}\r\n\r\ninline BOOL MResizable::IsResizeEnabled() const\r\n{\r\n    return m_bResizeEnabled;\r\n}\r\n\r\ninline VOID MResizable::ShowSizeGrip(BOOL bShow/* = TRUE*/)\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n\r\n    if (bShow)\r\n    {\r\n        // size grip aleady exists?\r\n        if (!m_size_grip)\r\n        {\r\n            // create size grip\r\n            MRect ClientRect;\r\n            GetClientRect(m_hwndParent, &ClientRect);\r\n            INT cx = ::GetSystemMetrics(SM_CXVSCROLL);\r\n            INT cy = ::GetSystemMetrics(SM_CYHSCROLL);\r\n            m_size_grip.CreateWindowDx(m_hwndParent, NULL,\r\n                WS_CHILD | WS_CLIPSIBLINGS | SBS_SIZEGRIP, 0,\r\n                ClientRect.right - cx, ClientRect.bottom - cy,\r\n                cx, cy, reinterpret_cast<HMENU>(123456789));\r\n        }\r\n\r\n        MoveSizeGrip();\r\n        ShowWindow(m_size_grip, SW_SHOWNOACTIVATE);\r\n    }\r\n    else\r\n    {\r\n        if (::IsWindow(m_size_grip))\r\n            ShowWindow(m_size_grip, SW_HIDE);\r\n    }\r\n}\r\n\r\ninline VOID MResizable::MoveSizeGrip()\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n\r\n    if (m_size_grip)\r\n    {\r\n        // move it\r\n        MRect ClientRect;\r\n        GetClientRect(m_hwndParent, &ClientRect);\r\n        INT cx = ::GetSystemMetrics(SM_CXVSCROLL);\r\n        INT cy = ::GetSystemMetrics(SM_CYHSCROLL);\r\n        SetWindowPos(m_size_grip, NULL,\r\n            ClientRect.right - cx, ClientRect.bottom - cy,\r\n            cx, cy, SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);\r\n    }\r\n}\r\n\r\ninline VOID MResizable::ModifyParentStyle(BOOL bEnableResize)\r\n{\r\n    // style\r\n    DWORD style = ::GetWindowLong(m_hwndParent, GWL_STYLE);\r\n    if (bEnableResize)\r\n    {\r\n        style &= ~DS_MODALFRAME;\r\n        style |= WS_THICKFRAME | WS_MAXIMIZEBOX;\r\n        SetWindowLong(m_hwndParent, GWL_STYLE, style);\r\n    }\r\n    else\r\n    {\r\n        style &= ~(WS_THICKFRAME | WS_MAXIMIZEBOX);\r\n        style |= DS_MODALFRAME;\r\n        SetWindowLong(m_hwndParent, GWL_STYLE, style);\r\n    }\r\n    // ex.style\r\n    style = ::GetWindowLong(m_hwndParent, GWL_EXSTYLE);\r\n    if (bEnableResize)\r\n    {\r\n        style &= ~WS_EX_DLGMODALFRAME;\r\n        style |= 0;\r\n        SetWindowLong(m_hwndParent, GWL_EXSTYLE, style);\r\n    }\r\n    else\r\n    {\r\n        style &= ~0;\r\n        style |= WS_EX_DLGMODALFRAME;\r\n        SetWindowLong(m_hwndParent, GWL_EXSTYLE, style);\r\n    }\r\n    if (bEnableResize)\r\n    {\r\n        GetSystemMenu(m_hwndParent, TRUE);\r\n    }\r\n    else\r\n    {\r\n        HMENU hSysMenu;\r\n        hSysMenu = ::GetSystemMenu(m_hwndParent, FALSE);\r\n        RemoveMenu(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND);\r\n        RemoveMenu(hSysMenu, SC_SIZE, MF_BYCOMMAND);\r\n        RemoveMenu(hSysMenu, SC_RESTORE, MF_BYCOMMAND);\r\n    }\r\n    RedrawWindow(m_hwndParent, NULL, NULL,\r\n                   RDW_FRAME | RDW_INVALIDATE | RDW_ERASENOW);\r\n    InvalidateRect(m_hwndParent, NULL, TRUE);\r\n}\r\n\r\ninline VOID\r\nMResizable::EnableResize(BOOL bEnableResize, BOOL bShowSizeGrip/* = TRUE*/)\r\n{\r\n    ShowSizeGrip(bEnableResize && bShowSizeGrip);\r\n    ModifyParentStyle(bEnableResize);\r\n    m_bResizeEnabled = bEnableResize;\r\n}\r\n\r\ninline VOID MResizable::OnParentCreate(HWND hwndParent, BOOL bEnableResize,\r\n                                       BOOL bShowSizeGrip/* = TRUE*/)\r\n{\r\n    assert(hwndParent);\r\n    assert(::IsWindow(hwndParent));\r\n\r\n    m_hwndParent = hwndParent;\r\n\r\n    ClearLayouts();\r\n\r\n    // NOTE: The parent window must have initially WS_THICKFRAME style.\r\n    assert(::GetWindowLong(hwndParent, GWL_STYLE) & WS_THICKFRAME);\r\n\r\n    EnableResize(bEnableResize, bShowSizeGrip);\r\n}\r\n\r\ninline VOID MResizable::ArrangeLayout(const RECT *prc)\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n\r\n    MRect ClientRect;\r\n    if (prc)\r\n    {\r\n        ClientRect = *prc;\r\n    }\r\n    else\r\n    {\r\n        GetClientRect(m_hwndParent, &ClientRect);\r\n    }\r\n\r\n    const INT count = INT(m_layouts.size());\r\n    if (count == 0)\r\n        return;\r\n\r\n    HDWP hDwp = ::BeginDeferWindowPos(count);\r\n    if (hDwp == NULL)\r\n        return;\r\n\r\n    const UINT uFlags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREPOSITION;\r\n    for (INT i = 0; i < count; ++i)\r\n    {\r\n        const layout_type& layout = m_layouts[i];\r\n        HWND hwndCtrl = layout.m_hwndCtrl;\r\n        if (!::IsWindow(hwndCtrl))\r\n            continue;\r\n\r\n        MRect ChildRect, NewRect;\r\n\r\n        GetWindowRect(hwndCtrl, &ChildRect);\r\n        MapWindowPoints(NULL, m_hwndParent,\r\n                          reinterpret_cast<LPPOINT>(&ChildRect), 2);\r\n\r\n        NewRect.left = layout.m_sizMargin1.cx +\r\n                       ClientRect.Width() * layout.m_sizLA_1.cx / 100;\r\n        NewRect.top = layout.m_sizMargin1.cy +\r\n                      ClientRect.Height() * layout.m_sizLA_1.cy / 100;\r\n        NewRect.right = layout.m_sizMargin2.cx +\r\n                        ClientRect.Width() * layout.m_sizLA_2.cx / 100;\r\n        NewRect.bottom = layout.m_sizMargin2.cy +\r\n                         ClientRect.Height() * layout.m_sizLA_2.cy / 100;\r\n\r\n        if (NewRect != ChildRect)\r\n        {\r\n            hDwp = ::DeferWindowPos(hDwp, hwndCtrl, NULL,\r\n                NewRect.left, NewRect.top,\r\n                NewRect.Width(), NewRect.Height(), uFlags);\r\n        }\r\n\r\n        InvalidateRect(hwndCtrl, NULL, TRUE);\r\n    }\r\n\r\n    EndDeferWindowPos(hDwp);\r\n}\r\n\r\ninline VOID MResizable::SetLayoutAnchor(\r\n    HWND hwndCtrl, MSize sizLA_1, MSize sizLA_2/* = mzcLA_NO_ANCHOR*/)\r\n{\r\n    assert(m_hwndParent);\r\n    assert(::IsWindow(m_hwndParent));\r\n    assert(sizLA_1 != mzcLA_NO_ANCHOR);\r\n\r\n    MRect ClientRect, ChildRect;\r\n    GetClientRect(m_hwndParent, &ClientRect);\r\n    GetWindowRect(hwndCtrl, &ChildRect);\r\n    MapWindowPoints(NULL, m_hwndParent,\r\n                    reinterpret_cast<LPPOINT>(&ChildRect), 2);\r\n\r\n    if (sizLA_2 == mzcLA_NO_ANCHOR)\r\n        sizLA_2 = sizLA_1;\r\n\r\n    MSize sizMargin1, sizMargin2;\r\n    sizMargin1.cx = ChildRect.left - ClientRect.Width() * sizLA_1.cx / 100;\r\n    sizMargin1.cy = ChildRect.top - ClientRect.Height() * sizLA_1.cy / 100;\r\n    sizMargin2.cx = ChildRect.right - ClientRect.Width() * sizLA_2.cx / 100;\r\n    sizMargin2.cy = ChildRect.bottom - ClientRect.Height() * sizLA_2.cy / 100;\r\n\r\n    // search hwndCtrl\r\n    layout_type *pLayout = CtrlLayout(hwndCtrl);\r\n    if (pLayout)\r\n        return;\r\n\r\n    // if not found\r\n    layout_type layout(hwndCtrl, sizLA_1, sizMargin1, sizLA_2, sizMargin2);\r\n    m_layouts.push_back(layout);\r\n}\r\n\r\ninline MResizable::layout_type *MResizable::CtrlLayout(HWND hwndCtrl)\r\n{\r\n    const INT count = INT(m_layouts.size());\r\n    for (INT i = 0; i < count; ++i)\r\n    {\r\n        if (m_layouts[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_layouts[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline MResizable::layout_type *MResizable::CtrlLayout(UINT nCtrlID)\r\n{\r\n    HWND hwndCtrl = ::GetDlgItem(m_hwndParent, nCtrlID);\r\n    const INT count = INT(m_layouts.size());\r\n    for (INT i = 0; i < count; ++i)\r\n    {\r\n        if (m_layouts[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_layouts[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline const MResizable::layout_type *MResizable::CtrlLayout(HWND hwndCtrl) const\r\n{\r\n    const INT count = INT(m_layouts.size());\r\n    for (INT i = 0; i < count; ++i)\r\n    {\r\n        if (m_layouts[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_layouts[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline const MResizable::layout_type *MResizable::CtrlLayout(UINT nCtrlID) const\r\n{\r\n    HWND hwndCtrl = ::GetDlgItem(m_hwndParent, nCtrlID);\r\n    const INT count = INT(m_layouts.size());\r\n    for (INT i = 0; i < count; ++i)\r\n    {\r\n        if (m_layouts[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_layouts[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MRESIZABLE_HPP_\r\n
MRgn.hpp<>MRgn.hpp<>// MRgn.hpp -- Win32API region wrapper                      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MRGN_HPP_\r\n#define MZC4_MRGN_HPP_      5       /* Version 5 */\r\n\r\nclass MRgn;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MGdiObject.hpp"\r\n\r\nclass MRgn : public MGdiObject\r\n{\r\npublic:\r\n    MRgn();\r\n    MRgn(HRGN hRgn);\r\n    MRgn(INT x1, INT y1, INT x2, INT y2, BOOL bElliptic = FALSE);\r\n    MRgn(LPCRECT prc, BOOL bElliptic = FALSE);\r\n    MRgn(const MRgn& rgn);\r\n    MRgn& operator=(HRGN hRgn);\r\n    MRgn& operator=(const MRgn& rgn);\r\n\r\n    operator HRGN() const;\r\n\r\n    BOOL Attach(HRGN hRgn);\r\n    HRGN Detach(VOID);\r\n    HRGN Handle() const;\r\n\r\n    BOOL IsRgnEmptyDx() const;\r\n    BOOL CreateEmptyRgn();\r\n    BOOL CreateRectRgn(INT x1, INT y1, INT x2, INT y2);\r\n    BOOL CreateRectRgnIndirect(LPCRECT prc);\r\n    BOOL CreateEllipticRgn(INT x1, INT y1, INT x2, INT y2);\r\n    BOOL CreateEllipticRgnIndirect(LPCRECT prc);\r\n    BOOL CreatePolygonRgn(LPPOINT ppts, INT nCount, INT nMode);\r\n    BOOL CreatePolyPolygonRgn(LPPOINT ppts, LPINT lpPolyCounts, INT nCount,\r\n                              INT nPolyFillMode);\r\n    BOOL CreateRoundRectRgn(INT x1, INT y1, INT x2, INT y2, INT x3, INT y3);\r\n    BOOL PathToRegion(HDC hDC);\r\n    BOOL ExtCreateRegion(CONST XFORM* lpXForm OPTIONAL, INT nCount,\r\n                         CONST RGNDATA* pRgnData);\r\n\r\n    VOID SetRectRgn(INT x1, INT y1, INT x2, INT y2);\r\n    VOID SetRectRgn(LPCRECT prc);\r\n    INT CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, INT nCombineMode);\r\n    INT CombineRgn(HRGN hRgnSrc, INT nCombineMode);\r\n    INT CopyRgnDx(HRGN hRgnSrc);\r\n    BOOL EqualRgn(HRGN hRgn) const;\r\n    INT OffsetRgn(INT x, INT y);\r\n    INT OffsetRgn(POINT pt);\r\n    INT GetRgnBox(LPRECT prc) const;\r\n    BOOL PtInRegion(INT x, INT y) const;\r\n    BOOL PtInRegion(POINT pt) const;\r\n    BOOL RectInRegion(LPCRECT prc) const;\r\n    DWORD GetRegionData(DWORD nDataSize, LPRGNDATA pRgnData) const;\r\n\r\n    INT IntersectRgnDx(HRGN hrgnA, HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnA, hrgnB, RGN_AND);\r\n    }\r\n    INT SubtractRgnDx(HRGN hrgnA, HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnA, hrgnB, RGN_DIFF);\r\n    }\r\n    INT UnionRgnDx(HRGN hrgnA, HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnA, hrgnB, RGN_OR);\r\n    }\r\n    INT XorRgnDx(HRGN hrgnA, HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnA, hrgnB, RGN_XOR);\r\n    }\r\n\r\n    INT IntersectRgnDx(HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnB, RGN_AND);\r\n    }\r\n    INT SubtractRgnDx(HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnB, RGN_DIFF);\r\n    }\r\n    INT UnionRgnDx(HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnB, RGN_OR);\r\n    }\r\n    INT XorRgnDx(HRGN hrgnB)\r\n    {\r\n        return CombineRgn(hrgnB, RGN_XOR);\r\n    }\r\n\r\n    static HRGN CloneHandleDx(HRGN hRgn);\r\n};\r\n\r\nBOOL IsRgnEmptyDx(HRGN hRgn);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ HRGN MRgn::CloneHandleDx(HRGN hRgn)\r\n{\r\n    if (hRgn == NULL)\r\n        return NULL;\r\n    HRGN hRgnNew = ::CreateRectRgn(0, 0, 0, 0);\r\n    assert(hRgnNew != NULL);\r\n    ::CombineRgn(hRgnNew, hRgnNew, hRgn, RGN_OR);\r\n    return hRgnNew;\r\n}\r\n\r\ninline MRgn::MRgn()\r\n{\r\n}\r\n\r\ninline MRgn::MRgn(HRGN hRgn) : MGdiObject(hRgn)\r\n{\r\n}\r\n\r\ninline MRgn::MRgn(\r\n    INT x1, INT y1, INT x2, INT y2, BOOL bElliptic/* = FALSE*/)\r\n{\r\n    if (bElliptic)\r\n        MRgn::CreateEllipticRgn(x1, y1, x2, y2);\r\n    else\r\n        MRgn::CreateRectRgn(x1, y1, x2, y2);\r\n}\r\n\r\ninline MRgn::MRgn(LPCRECT prc, BOOL bElliptic/* = FALSE*/)\r\n{\r\n    if (bElliptic)\r\n        MRgn::CreateEllipticRgnIndirect(prc);\r\n    else\r\n        MRgn::CreateRectRgnIndirect(prc);\r\n}\r\n\r\ninline MRgn::MRgn(const MRgn& rgn)\r\n{\r\n    if (Handle() != rgn.Handle())\r\n    {\r\n        HRGN hRgn = CloneHandleDx(rgn);\r\n        Attach(hRgn);\r\n    }\r\n}\r\n\r\ninline MRgn::operator HRGN() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline MRgn& MRgn::operator=(HRGN hRgn)\r\n{\r\n    assert(hRgn == NULL || ::GetObjectType(hRgn) == OBJ_REGION);\r\n    if (Handle() != hRgn)\r\n    {\r\n        Attach(hRgn);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MRgn& MRgn::operator=(const MRgn& rgn)\r\n{\r\n    if (Handle() != rgn.Handle())\r\n    {\r\n        HRGN hRgn = CloneHandleDx(rgn);\r\n        Attach(hRgn);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MRgn::Attach(HRGN hRgn)\r\n{\r\n    assert(::GetObjectType(hRgn) == OBJ_REGION);\r\n    return MGdiObject::Attach(hRgn);\r\n}\r\n\r\ninline HRGN MRgn::Detach(VOID)\r\n{\r\n    return reinterpret_cast<HRGN>(MGdiObject::Detach());\r\n}\r\n\r\ninline HRGN MRgn::Handle() const\r\n{\r\n    return (this ? (HRGN)m_hGdiObj : NULL);\r\n}\r\n\r\ninline BOOL MRgn::CreateEmptyRgn()\r\n{\r\n    return CreateRectRgn(0, 0, 0, 0);\r\n}\r\n\r\ninline BOOL MRgn::CreateRectRgn(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    return Attach(::CreateRectRgn(x1, y1, x2, y2));\r\n}\r\n\r\ninline BOOL MRgn::CreateRectRgnIndirect(LPCRECT prc)\r\n{\r\n    return Attach(::CreateRectRgnIndirect(prc));\r\n}\r\n\r\ninline BOOL MRgn::CreateEllipticRgn(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    return Attach(::CreateEllipticRgn(x1, y1, x2, y2));\r\n}\r\n\r\ninline BOOL MRgn::CreateEllipticRgnIndirect(LPCRECT prc)\r\n{\r\n    return Attach(::CreateEllipticRgnIndirect(prc));\r\n}\r\n\r\ninline BOOL MRgn::CreatePolygonRgn(LPPOINT ppts, INT nCount, INT nMode)\r\n{\r\n    return Attach(::CreatePolygonRgn(ppts, nCount, nMode));\r\n}\r\n\r\ninline BOOL MRgn::CreatePolyPolygonRgn(\r\n    LPPOINT ppts, LPINT lpPolyCounts, INT nCount, INT nPolyFillMode)\r\n{\r\n    return Attach(::CreatePolyPolygonRgn(ppts, lpPolyCounts, nCount, nPolyFillMode));\r\n}\r\n\r\ninline BOOL MRgn::CreateRoundRectRgn(\r\n    INT x1, INT y1, INT x2, INT y2, INT x3, INT y3)\r\n{\r\n    return Attach(::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3));\r\n}\r\n\r\ninline BOOL MRgn::PathToRegion(HDC hDC)\r\n{\r\n    assert(hDC);\r\n    return Attach(::PathToRegion(hDC));\r\n}\r\n\r\ninline BOOL MRgn::ExtCreateRegion(\r\n    CONST XFORM* lpXForm OPTIONAL, INT nCount, CONST RGNDATA* pRgnData)\r\n{\r\n    return Attach(::ExtCreateRegion(lpXForm, (DWORD) nCount, pRgnData));\r\n}\r\n\r\ninline VOID MRgn::SetRectRgn(INT x1, INT y1, INT x2, INT y2)\r\n{\r\n    assert(Handle());\r\n    ::SetRectRgn(Handle(), x1, y1, x2, y2);\r\n}\r\n\r\ninline VOID MRgn::SetRectRgn(LPCRECT prc)\r\n{\r\n    assert(Handle());\r\n    ::SetRectRgn(Handle(), prc->left, prc->top, prc->right, prc->bottom);\r\n}\r\n\r\ninline INT MRgn::CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, INT nCombineMode)\r\n{\r\n    assert(Handle());\r\n    return ::CombineRgn(Handle(), hRgnSrc1, hRgnSrc2, nCombineMode);\r\n}\r\n\r\ninline INT MRgn::CombineRgn(HRGN hRgnSrc, INT nCombineMode)\r\n{\r\n    assert(Handle());\r\n    return ::CombineRgn(Handle(), Handle(), hRgnSrc, nCombineMode);\r\n}\r\n\r\ninline INT MRgn::CopyRgnDx(HRGN hRgnSrc)\r\n{\r\n    assert(Handle());\r\n    return ::CombineRgn(Handle(), hRgnSrc, NULL, RGN_COPY);\r\n}\r\n\r\ninline BOOL MRgn::EqualRgn(HRGN hRgn) const\r\n{\r\n    assert(Handle());\r\n    return ::EqualRgn(Handle(), hRgn);\r\n}\r\n\r\ninline INT MRgn::OffsetRgn(INT x, INT y)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetRgn(Handle(), x, y);\r\n}\r\n\r\ninline INT MRgn::OffsetRgn(POINT pt)\r\n{\r\n    assert(Handle());\r\n    return ::OffsetRgn(Handle(), pt.x, pt.y);\r\n}\r\n\r\ninline INT MRgn::GetRgnBox(LPRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::GetRgnBox(Handle(), prc);\r\n}\r\n\r\ninline BOOL MRgn::PtInRegion(INT x, INT y) const\r\n{\r\n    assert(Handle());\r\n    return ::PtInRegion(Handle(), x, y);\r\n}\r\n\r\ninline BOOL MRgn::PtInRegion(POINT pt) const\r\n{\r\n    assert(Handle());\r\n    return ::PtInRegion(Handle(), pt.x, pt.y);\r\n}\r\n\r\ninline BOOL MRgn::RectInRegion(LPCRECT prc) const\r\n{\r\n    assert(Handle());\r\n    return ::RectInRegion(Handle(), prc);\r\n}\r\n\r\ninline DWORD MRgn::GetRegionData(DWORD nDataSize, LPRGNDATA pRgnData) const\r\n{\r\n    assert(Handle());\r\n    return ::GetRegionData(Handle(), nDataSize, pRgnData);\r\n}\r\n\r\ninline BOOL MRgn::IsRgnEmptyDx() const\r\n{\r\n    assert(Handle());\r\n    return ::IsRgnEmptyDx(Handle());\r\n}\r\n\r\ninline BOOL IsRgnEmptyDx(HRGN hRgn)\r\n{\r\n    HRGN hrgnEmpty = ::CreateRectRgn(0, 0, 0, 0);\r\n    BOOL bOK = ::EqualRgn(hRgn, hrgnEmpty);\r\n    ::DeleteObject(hrgnEmpty);\r\n    return bOK;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MRGN_HPP_\r\n
MScrollBar.hpp<>MScrollBar.hpp<>// MScrollBar.hpp -- Win32API scroll bar wrapper -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSCROLLBAR_HPP_\r\n#define MZC4_MSCROLLBAR_HPP_        2   /* Version 2 */\r\n\r\nclass MScrollBar;\r\n//class MSizeGrip;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#define MSCROLLBAR_HSCROLL_STYLE \\\r\n    (WS_CHILD | WS_VISIBLE | SBS_HORZ)\r\n#define MSCROLLBAR_VSCROLL_STYLE \\\r\n    (WS_CHILD | WS_VISIBLE | SBS_VERT)\r\n\r\nclass MScrollBar : public MWindowBase\r\n{\r\npublic:\r\n    MScrollBar();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetScrollPos() const;\r\n    INT SetScrollPos(INT nPos, BOOL bRedraw = TRUE);\r\n\r\n    VOID GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;\r\n    VOID SetScrollRange(INT nMinPos, INT nMaxPos, BOOL bRedraw = TRUE);\r\n\r\n    VOID ShowScrollBar(BOOL bShow = TRUE);\r\n\r\n    BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);\r\n\r\n    BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nSIF_mask = SIF_ALL);\r\n    BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);\r\n\r\n    INT GetScrollLimit();\r\n\r\n    static INT GetHScrollWidth();\r\n    static INT GetHScrollHeight();\r\n    static INT GetVScrollWidth();\r\n    static INT GetVScrollHeight();\r\n    static INT GetHThumbWidth();\r\n    static INT GetVThumbHeight();\r\n};\r\ntypedef MScrollBar MSizeGrip;\r\n\r\nUINT GetMouseScrollLinesDx(VOID);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MScrollBar::MScrollBar()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MScrollBar::GetWndClassNameDx() const\r\n{\r\n    return TEXT("SCROLLBAR");\r\n}\r\n\r\ninline INT MScrollBar::GetScrollPos() const\r\n{\r\n    return ::GetScrollPos(m_hwnd, SB_CTL);\r\n}\r\n\r\ninline INT MScrollBar::SetScrollPos(INT nPos, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    return ::SetScrollPos(m_hwnd, SB_CTL, nPos, bRedraw);\r\n}\r\n\r\ninline VOID MScrollBar::GetScrollRange(\r\n    LPINT lpMinPos, LPINT lpMaxPos) const\r\n{\r\n    ::GetScrollRange(m_hwnd, SB_CTL, lpMinPos, lpMaxPos);\r\n}\r\n\r\ninline VOID MScrollBar::SetScrollRange(\r\n    INT nMinPos, INT nMaxPos, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    ::SetScrollRange(m_hwnd, SB_CTL, nMinPos, nMaxPos, bRedraw);\r\n}\r\n\r\ninline VOID MScrollBar::ShowScrollBar(BOOL bShow/* = TRUE*/)\r\n{\r\n    ::ShowScrollBar(m_hwnd, SB_CTL, bShow);\r\n}\r\n\r\ninline BOOL MScrollBar::EnableScrollBar(\r\n    UINT nArrowFlags/* = ESB_ENABLE_BOTH*/)\r\n{\r\n    return ::EnableScrollBar(m_hwnd, SB_CTL, nArrowFlags);\r\n}\r\n\r\ninline BOOL MScrollBar::SetScrollInfo(\r\n    LPSCROLLINFO lpScrollInfo, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    return ::SetScrollInfo(m_hwnd, SB_CTL, lpScrollInfo, bRedraw);\r\n}\r\n\r\ninline BOOL MScrollBar::GetScrollInfo(\r\n    LPSCROLLINFO lpScrollInfo, UINT nSIF_mask/* = SIF_ALL*/)\r\n{\r\n    lpScrollInfo->fMask = nSIF_mask;\r\n    return ::GetScrollInfo(m_hwnd, SB_CTL, lpScrollInfo);\r\n}\r\n\r\ninline INT MScrollBar::GetScrollLimit()\r\n{\r\n    INT nMin, nMax;\r\n    ::GetScrollRange(m_hwnd, SB_CTL, &nMin, &nMax);\r\n\r\n    SCROLLINFO info;\r\n    info.cbSize = sizeof(SCROLLINFO);\r\n    info.fMask = SIF_PAGE;\r\n    if(::GetScrollInfo(m_hwnd, SB_CTL, &info))\r\n        nMax -= ((info.nPage - 1) > 0) ? (info.nPage - 1) : 0;\r\n    return nMax;\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetHThumbWidth()\r\n{\r\n    return ::GetSystemMetrics(SM_CXHTHUMB);\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetVThumbHeight()\r\n{\r\n    return ::GetSystemMetrics(SM_CYVTHUMB);\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetHScrollWidth()\r\n{\r\n    return ::GetSystemMetrics(SM_CXHSCROLL);\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetHScrollHeight()\r\n{\r\n    return ::GetSystemMetrics(SM_CYHSCROLL);\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetVScrollWidth()\r\n{\r\n    return ::GetSystemMetrics(SM_CXVSCROLL);\r\n}\r\n\r\ninline /*static*/ INT MScrollBar::GetVScrollHeight()\r\n{\r\n    return ::GetSystemMetrics(SM_CYVSCROLL);\r\n}\r\n\r\ninline UINT GetMouseScrollLinesDx(VOID)\r\n{\r\n    static BOOL s_bGot = FALSE;\r\n    static UINT s_uCachedScrollLines;\r\n\r\n    if (s_bGot)\r\n        return s_uCachedScrollLines;\r\n\r\n#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)\r\n    s_bGot = ::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,\r\n        &s_uCachedScrollLines, 0);\r\n    if (s_bGot)\r\n        return s_uCachedScrollLines;\r\n#endif  // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)\r\n\r\n    s_bGot = TRUE;\r\n    HWND hwMouseWheel = ::FindWindow(TEXT("MouseZ"), TEXT("Magellan MSWHEEL"));\r\n    UINT uMsg = ::RegisterWindowMessage(TEXT("MSH_SCROLL_LINES_MSG"));\r\n    if (hwMouseWheel != NULL && uMsg != 0)\r\n    {\r\n        s_uCachedScrollLines = (UINT)::SendMessage(hwMouseWheel, uMsg, 0, 0);\r\n        return s_uCachedScrollLines;\r\n    }\r\n\r\n    s_uCachedScrollLines = 3; // reasonable default\r\n    HKEY hKey;\r\n    if (::RegOpenKeyEx(HKEY_CURRENT_USER,  TEXT("Control Panel\\\\Desktop"),\r\n                       0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)\r\n    {\r\n        TCHAR szData[128];\r\n        DWORD dwKeyDataType;\r\n        DWORD dwDataBufSize = sizeof(szData);\r\n\r\n        if (::RegQueryValueEx(hKey, TEXT("WheelScrollLines"), NULL,\r\n            &dwKeyDataType, (LPBYTE)&szData, &dwDataBufSize) == ERROR_SUCCESS)\r\n        {\r\n            s_uCachedScrollLines = (UINT) _ttoi(szData);\r\n        }\r\n        RegCloseKey(hKey);\r\n    }\r\n\r\n    return s_uCachedScrollLines;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSCROLLBAR_HPP_\r\n
MScrollView.hpp<>MScrollView.hpp<>// MScrollView.hpp -- MZC4 scroll view                          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n// MScrollView provides a scrollable area in the parent window that\r\n// contains some scrolled child windows.\r\n\r\n#ifndef MZC4_MSCROLLVIEW_HPP_\r\n#define MZC4_MSCROLLVIEW_HPP_       3       /* Version 3 */\r\n\r\nclass MScrollView;\r\nstruct MScrollCtrlInfo;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MPointSizeRect.hpp"   // for MPoint, MSize, MRect\r\n#include "MScrollBar.hpp"       // for MScrollBar\r\n\r\n#include <vector>               // for std::vector\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nstruct MScrollCtrlInfo\r\n{\r\n    HWND    m_hwndCtrl;\r\n    MRect   m_rcCtrl;\r\n\r\n    MScrollCtrlInfo();\r\n    MScrollCtrlInfo(HWND hwndCtrl);\r\n    MScrollCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl);\r\n    MScrollCtrlInfo(HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MScrollView\r\n{\r\npublic:\r\n    MScrollView();\r\n    MScrollView(HWND hwndParent);\r\n    virtual ~MScrollView();\r\n\r\n    // parent\r\n    HWND GetParent() const;\r\n    void SetParent(HWND hwndParent);\r\n\r\n    // scroll bar control\r\n    HWND GetHScrollBar() const;\r\n    VOID SetHScrollBar(HWND hHScrollBar);\r\n    HWND GetVScrollBar() const;\r\n    VOID SetVScrollBar(HWND hVScrollBar);\r\n\r\n    // parent scroll bars\r\n    void ShowScrollBars(BOOL fHScroll, BOOL fVScroll);\r\n\r\n    // add/set control info\r\n    void AddCtrlInfo(HWND hwndCtrl);\r\n    void AddCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl);\r\n    void AddCtrlInfo(HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl);\r\n    void SetCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl);\r\n    void SetCtrlInfo(HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl);\r\n    void RemoveCtrlInfo(HWND hwndCtrl);\r\n    void AddCtrlInfo(UINT idCtrl);\r\n    void AddCtrlInfo(UINT idCtrl, const MRect& rcCtrl);\r\n    void AddCtrlInfo(UINT idCtrl, const MPoint& ptCtrl, const MSize& sizCtrl);\r\n    void SetCtrlInfo(UINT idCtrl, const MRect& rcCtrl);\r\n    void SetCtrlInfo(UINT idCtrl, const MPoint& ptCtrl, const MSize& sizCtrl);\r\n    void RemoveCtrlInfo(UINT idCtrl);\r\n\r\n    bool empty() const;\r\n    void clear();\r\n    size_t size() const;\r\n\r\n    // find control info\r\n          MScrollCtrlInfo* FindCtrlInfo(HWND hwndCtrl);\r\n    const MScrollCtrlInfo* FindCtrlInfo(HWND hwndCtrl) const;\r\n\r\n    // scroll pos\r\n          MPoint& ScrollPos();\r\n    const MPoint& ScrollPos() const;\r\n    void OffsetScrollPos(INT dx, INT dy);\r\n    void OffsetScrollPos(const MPoint& pt);\r\n    void ResetScrollPos();\r\n\r\n    // extent\r\n          MSize& Extent();\r\n    const MSize& Extent() const;\r\n    void SetExtentForAllCtrls();\r\n\r\n    // ensure visible\r\n    void EnsureCtrlVisible(HWND hwndCtrl, bool update_all = true);\r\n\r\n    // update\r\n    void UpdateScrollInfo();\r\n    void UpdateCtrlsPos();\r\n    void UpdateAll();\r\n\r\n    // NOTE: Call MScrollView::HScroll on parent's WM_HSCROLL.\r\n    void HScroll(INT nSB_, INT nPos);\r\n    // NOTE: Call MScrollView::VScroll on parent's WM_VSCROLL.\r\n    void VScroll(INT nSB_, INT nPos);\r\n\r\n          MScrollCtrlInfo& operator[](size_t index);\r\n    const MScrollCtrlInfo& operator[](size_t index) const;\r\n\r\n    // scroll info\r\n    BOOL GetHScrollInfo(LPSCROLLINFO psi) const;\r\n    BOOL GetVScrollInfo(LPSCROLLINFO psi) const;\r\n    BOOL SetHScrollInfo(const SCROLLINFO *psi, BOOL bRedraw = TRUE);\r\n    BOOL SetVScrollInfo(const SCROLLINFO *psi, BOOL bRedraw = TRUE);\r\n\r\n    // scroll position\r\n    INT  GetHScrollPos() const;\r\n    void SetHScrollPos(INT nPos, BOOL bRedraw = TRUE);\r\n    INT  GetVScrollPos() const;\r\n    void SetVScrollPos(INT nPos, BOOL bRedraw = TRUE);\r\n\r\n    virtual void GetClientRect(LPRECT prcClient) const;\r\n\r\nprotected:\r\n    HWND        m_hwndParent;\r\n    MPoint      m_ptScrollPos;\r\n    MSize       m_sizExtent;\r\n    std::vector<MScrollCtrlInfo> m_vecInfo;\r\n    HWND        m_h_scroll_bar;\r\n    HWND        m_v_scroll_bar;\r\n\r\n    BOOL HasChildStyle(HWND hwnd) const;\r\n\r\nprivate:\r\n    // NOTE: MScrollView is not copyable.\r\n    MScrollView(const MScrollView&);\r\n    MScrollView& operator=(const MScrollView&);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MScrollCtrlInfo::MScrollCtrlInfo()\r\n{\r\n}\r\n\r\ninline MScrollCtrlInfo::MScrollCtrlInfo(HWND hwndCtrl) :\r\n    m_hwndCtrl(hwndCtrl)\r\n{\r\n}\r\n\r\ninline\r\nMScrollCtrlInfo::MScrollCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl) :\r\n    m_hwndCtrl(hwndCtrl), m_rcCtrl(rcCtrl)\r\n{\r\n}\r\n\r\ninline MScrollCtrlInfo::MScrollCtrlInfo(\r\n    HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl) :\r\n    m_hwndCtrl(hwndCtrl), m_rcCtrl(ptCtrl, sizCtrl)\r\n{\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MScrollView::MScrollView() : m_hwndParent(NULL)\r\n{\r\n}\r\n\r\ninline MScrollView::MScrollView(HWND hwndParent) : m_hwndParent(NULL)\r\n{\r\n    MScrollView::SetParent(hwndParent);\r\n}\r\n\r\ninline /*virtual*/ MScrollView::~MScrollView()\r\n{\r\n}\r\n\r\ninline HWND MScrollView::GetParent() const\r\n{\r\n    return m_hwndParent;\r\n}\r\n\r\ninline void MScrollView::SetParent(HWND hwndParent)\r\n{\r\n    assert(::IsWindow(hwndParent));\r\n    m_hwndParent = hwndParent;\r\n    DWORD style = ::GetWindowLong(m_hwndParent, GWL_STYLE);\r\n    style |= WS_CLIPCHILDREN;\r\n    ::SetWindowLong(m_hwndParent, GWL_STYLE, style);\r\n}\r\n\r\ninline HWND MScrollView::GetHScrollBar() const\r\n{\r\n    return m_h_scroll_bar;\r\n}\r\n\r\ninline VOID MScrollView::SetHScrollBar(HWND hHScrollBar)\r\n{\r\n    m_h_scroll_bar = hHScrollBar;\r\n}\r\n\r\ninline HWND MScrollView::GetVScrollBar() const\r\n{\r\n    return m_v_scroll_bar;\r\n}\r\n\r\ninline VOID MScrollView::SetVScrollBar(HWND hVScrollBar)\r\n{\r\n    m_v_scroll_bar = hVScrollBar;\r\n}\r\n\r\ninline void\r\nMScrollView::ShowScrollBars(BOOL fHScroll, BOOL fVScroll)\r\n{\r\n    if (::IsWindow(m_h_scroll_bar))\r\n        ::ShowScrollBar(m_h_scroll_bar, SB_CTL, fHScroll);\r\n    else\r\n        ::ShowScrollBar(m_hwndParent, SB_HORZ, fHScroll);\r\n\r\n    if (::IsWindow(m_v_scroll_bar))\r\n        ::ShowScrollBar(m_v_scroll_bar, SB_CTL, fHScroll);\r\n    else\r\n        ::ShowScrollBar(m_hwndParent, SB_VERT, fVScroll);\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(HWND hwndCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n\r\n#if CXX11\r\n    m_vecInfo.emplace_back(hwndCtrl);\r\n#else\r\n    MScrollCtrlInfo info(hwndCtrl);\r\n    m_vecInfo.push_back(info);\r\n#endif\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    assert(rcCtrl.left >= 0);\r\n    assert(rcCtrl.top >= 0);\r\n#if CXX11\r\n    m_vecInfo.emplace_back(hwndCtrl, rcCtrl);\r\n#else\r\n    MScrollCtrlInfo info(hwndCtrl, rcCtrl);\r\n    m_vecInfo.push_back(info);\r\n#endif\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(\r\n    HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    assert(ptCtrl.x >= 0);\r\n    assert(ptCtrl.y >= 0);\r\n#if CXX11\r\n    m_vecInfo.emplace_back(hwndCtrl, ptCtrl, sizCtrl);\r\n#else\r\n    MScrollCtrlInfo info(hwndCtrl, ptCtrl, sizCtrl);\r\n    m_vecInfo.push_back(info);\r\n#endif\r\n}\r\n\r\ninline MSize& MScrollView::Extent()\r\n{\r\n    return m_sizExtent;\r\n}\r\n\r\ninline const MSize& MScrollView::Extent() const\r\n{\r\n    return m_sizExtent;\r\n}\r\n\r\ninline MPoint& MScrollView::ScrollPos()\r\n{\r\n    return m_ptScrollPos;\r\n}\r\n\r\ninline const MPoint& MScrollView::ScrollPos() const\r\n{\r\n    return m_ptScrollPos;\r\n}\r\n\r\ninline void MScrollView::OffsetScrollPos(INT dx, INT dy)\r\n{\r\n    m_ptScrollPos.Offset(dx, dy);\r\n}\r\n\r\ninline void MScrollView::OffsetScrollPos(const MPoint& pt)\r\n{\r\n    m_ptScrollPos.Offset(pt);\r\n}\r\n\r\ninline BOOL MScrollView::HasChildStyle(HWND hwnd) const\r\n{\r\n    return (::GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD);\r\n}\r\n\r\ninline bool MScrollView::empty() const\r\n{\r\n    return m_vecInfo.empty();\r\n}\r\n\r\ninline void MScrollView::clear()\r\n{\r\n    m_vecInfo.clear();\r\n}\r\n\r\ninline size_t MScrollView::size() const\r\n{\r\n    return m_vecInfo.size();\r\n}\r\n\r\ninline void MScrollView::UpdateAll()\r\n{\r\n    UpdateScrollInfo();\r\n    UpdateCtrlsPos();\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(UINT idCtrl)\r\n{\r\n    AddCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl));\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(UINT idCtrl, const MRect& rcCtrl)\r\n{\r\n    AddCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl), rcCtrl);\r\n}\r\n\r\ninline void MScrollView::AddCtrlInfo(\r\n    UINT idCtrl, const MPoint& ptCtrl, const MSize& sizCtrl)\r\n{\r\n    AddCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl), ptCtrl, sizCtrl);\r\n}\r\n\r\ninline void MScrollView::SetCtrlInfo(UINT idCtrl, const MRect& rcCtrl)\r\n{\r\n    SetCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl), rcCtrl);\r\n}\r\n\r\ninline void MScrollView::SetCtrlInfo(\r\n    UINT idCtrl, const MPoint& ptCtrl, const MSize& sizCtrl)\r\n{\r\n    SetCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl), ptCtrl, sizCtrl);\r\n}\r\n\r\ninline void MScrollView::RemoveCtrlInfo(UINT idCtrl)\r\n{\r\n    RemoveCtrlInfo(::GetDlgItem(m_hwndParent, idCtrl));\r\n}\r\n\r\ninline MScrollCtrlInfo& MScrollView::operator[](size_t index)\r\n{\r\n    assert(index < size());\r\n    return m_vecInfo[index];\r\n}\r\n\r\ninline const MScrollCtrlInfo& MScrollView::operator[](size_t index) const\r\n{\r\n    assert(index < size());\r\n    return m_vecInfo[index];\r\n}\r\n\r\ninline void MScrollView::ResetScrollPos()\r\n{\r\n    ScrollPos() = MPoint();\r\n}\r\n\r\ninline INT MScrollView::GetHScrollPos() const\r\n{\r\n    if (::IsWindow(m_h_scroll_bar)) {\r\n        return ::GetScrollPos(m_h_scroll_bar, SB_CTL);\r\n    } else {\r\n        return ::GetScrollPos(m_hwndParent, SB_HORZ);\r\n    }\r\n}\r\n\r\ninline void MScrollView::SetHScrollPos(INT nPos, BOOL bRedraw)\r\n{\r\n    if (::IsWindow(m_h_scroll_bar)) {\r\n        ::SetScrollPos(m_h_scroll_bar, SB_CTL, nPos, bRedraw);\r\n    } else {\r\n        ::SetScrollPos(m_hwndParent, SB_HORZ, nPos, bRedraw);\r\n    }\r\n}\r\n\r\ninline INT MScrollView::GetVScrollPos() const\r\n{\r\n    if (::IsWindow(m_v_scroll_bar)) {\r\n        return ::GetScrollPos(m_v_scroll_bar, SB_CTL);\r\n    } else {\r\n        return ::GetScrollPos(m_hwndParent, SB_VERT);\r\n    }\r\n}\r\n\r\ninline void MScrollView::SetVScrollPos(INT nPos, BOOL bRedraw)\r\n{\r\n    if (::IsWindow(m_v_scroll_bar)) {\r\n        ::SetScrollPos(m_v_scroll_bar, SB_CTL, nPos, bRedraw);\r\n    } else {\r\n        ::SetScrollPos(m_hwndParent, SB_VERT, nPos, bRedraw);\r\n    }\r\n}\r\n\r\ninline BOOL MScrollView::GetHScrollInfo(LPSCROLLINFO psi) const\r\n{\r\n    if (::IsWindow(m_h_scroll_bar)) { \r\n        return ::GetScrollInfo(m_h_scroll_bar, SB_CTL, psi);\r\n    } else {\r\n        return ::GetScrollInfo(m_hwndParent, SB_HORZ, psi);\r\n    }\r\n}\r\n\r\ninline BOOL MScrollView::GetVScrollInfo(LPSCROLLINFO psi) const\r\n{\r\n    if (::IsWindow(m_v_scroll_bar)) { \r\n        return ::GetScrollInfo(m_v_scroll_bar, SB_CTL, psi);\r\n    } else {\r\n        return ::GetScrollInfo(m_hwndParent, SB_VERT, psi);\r\n    }\r\n}\r\n\r\ninline BOOL\r\nMScrollView::SetHScrollInfo(const SCROLLINFO *psi, BOOL bRedraw)\r\n{\r\n    if (::IsWindow(m_h_scroll_bar)) { \r\n        return ::SetScrollInfo(m_h_scroll_bar, SB_CTL, psi, bRedraw);\r\n    } else {\r\n        return ::SetScrollInfo(m_hwndParent, SB_HORZ, psi, bRedraw);\r\n    }\r\n}\r\n\r\ninline BOOL\r\nMScrollView::SetVScrollInfo(const SCROLLINFO *psi, BOOL bRedraw)\r\n{\r\n    if (::IsWindow(m_v_scroll_bar)) { \r\n        return ::SetScrollInfo(m_v_scroll_bar, SB_CTL, psi, bRedraw);\r\n    } else {\r\n        return ::SetScrollInfo(m_hwndParent, SB_VERT, psi, bRedraw);\r\n    }\r\n}\r\n\r\ninline void MScrollView::SetCtrlInfo(HWND hwndCtrl, const MRect& rcCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    assert(rcCtrl.left >= 0);\r\n    assert(rcCtrl.top >= 0);\r\n    MScrollCtrlInfo* info = FindCtrlInfo(hwndCtrl);\r\n    if (info)\r\n        info->m_rcCtrl = rcCtrl;\r\n    else\r\n        AddCtrlInfo(hwndCtrl, rcCtrl);\r\n}\r\n\r\ninline void\r\nMScrollView::SetCtrlInfo(\r\n    HWND hwndCtrl, const MPoint& ptCtrl, const MSize& sizCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    assert(ptCtrl.x >= 0);\r\n    assert(ptCtrl.y >= 0);\r\n    MScrollCtrlInfo* info = FindCtrlInfo(hwndCtrl);\r\n    if (info)\r\n        info->m_rcCtrl = MRect(ptCtrl, sizCtrl);\r\n    else\r\n        AddCtrlInfo(hwndCtrl, ptCtrl, sizCtrl);\r\n}\r\n\r\ninline MScrollCtrlInfo*\r\nMScrollView::FindCtrlInfo(HWND hwndCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    size_t siz = size();\r\n    for (size_t i = 0; i < siz; ++i)\r\n    {\r\n        if (m_vecInfo[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_vecInfo[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline const MScrollCtrlInfo*\r\nMScrollView::FindCtrlInfo(HWND hwndCtrl) const\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    size_t siz = size();\r\n    for (size_t i = 0; i < siz; ++i)\r\n    {\r\n        if (m_vecInfo[i].m_hwndCtrl == hwndCtrl)\r\n            return &m_vecInfo[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\ninline void MScrollView::RemoveCtrlInfo(HWND hwndCtrl)\r\n{\r\n    assert(::IsWindow(hwndCtrl));\r\n    assert(HasChildStyle(hwndCtrl));\r\n    std::vector<MScrollCtrlInfo>::iterator it, end = m_vecInfo.end();\r\n    for (it = m_vecInfo.begin(); it != end; ++it)\r\n    {\r\n        if (it->m_hwndCtrl == hwndCtrl)\r\n        {\r\n            m_vecInfo.erase(it);\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\ninline /*virtual*/ void MScrollView::GetClientRect(LPRECT prcClient) const\r\n{\r\n    assert(prcClient);\r\n    ::GetClientRect(m_hwndParent, prcClient);\r\n}\r\n\r\n// ensure visible\r\ninline void\r\nMScrollView::EnsureCtrlVisible(HWND hwndCtrl, bool update_all/* = true*/)\r\n{\r\n    MRect rcClient;\r\n    MScrollView::GetClientRect(&rcClient);\r\n\r\n    const INT siz = static_cast<INT>(size());\r\n    for (INT i = 0; i < siz; ++i)\r\n    {\r\n        if (m_vecInfo[i].m_hwndCtrl != hwndCtrl)\r\n            continue;\r\n\r\n        if (!::IsWindow(hwndCtrl))\r\n            break;\r\n\r\n        MRect& rcCtrl = m_vecInfo[i].m_rcCtrl;\r\n        if (rcCtrl.bottom > m_ptScrollPos.y + rcClient.Height())\r\n        {\r\n            m_ptScrollPos.y = rcCtrl.bottom - rcClient.Height();\r\n        }\r\n        if (rcCtrl.top < m_ptScrollPos.y)\r\n        {\r\n            m_ptScrollPos.y = rcCtrl.top;\r\n        }\r\n        break;\r\n    }\r\n    if (update_all)\r\n        UpdateAll();\r\n}\r\n\r\ninline void MScrollView::SetExtentForAllCtrls()\r\n{\r\n    Extent().cx = Extent().cy = 0;\r\n    const INT siz = static_cast<INT>(size());\r\n    for (INT i = 0; i < siz; ++i)\r\n    {\r\n        if (!::IsWindowVisible(m_vecInfo[i].m_hwndCtrl))\r\n            continue;\r\n\r\n        MRect& rcCtrl = m_vecInfo[i].m_rcCtrl;\r\n        if (Extent().cx < rcCtrl.right - 1)\r\n            Extent().cx = rcCtrl.right - 1;\r\n        if (Extent().cy < rcCtrl.bottom - 1)\r\n            Extent().cy = rcCtrl.bottom - 1;\r\n    }\r\n}\r\n\r\n// TODO: Avoid flickering!\r\ninline void MScrollView::UpdateScrollInfo()\r\n{\r\n    MRect rcClient;\r\n    MScrollView::GetClientRect(&rcClient);\r\n\r\n    SCROLLINFO si;\r\n\r\n    si.cbSize = sizeof(si);\r\n    si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;\r\n    si.nMin = 0;\r\n    si.nMax = Extent().cx;\r\n    si.nPage = rcClient.Width();\r\n    if (static_cast<UINT>(si.nMax) < si.nPage)\r\n        ScrollPos().x = 0;\r\n    si.nPos = ScrollPos().x;\r\n    SetHScrollInfo(&si, TRUE);\r\n\r\n    si.cbSize = sizeof(si);\r\n    si.fMask = SIF_ALL | SIF_DISABLENOSCROLL;\r\n    si.nMin = 0;\r\n    si.nMax = Extent().cy;\r\n    si.nPage = rcClient.Height();\r\n    if (static_cast<UINT>(si.nMax) < si.nPage)\r\n        ScrollPos().y = 0;\r\n    si.nPos = ScrollPos().y;\r\n    SetVScrollInfo(&si, TRUE);\r\n\r\n    ::InvalidateRect(m_hwndParent, NULL, TRUE);\r\n}\r\n\r\ninline void MScrollView::UpdateCtrlsPos()\r\n{\r\n    const INT siz = static_cast<INT>(size());\r\n    HDWP hDWP = ::BeginDeferWindowPos(siz);\r\n    if (hDWP)\r\n    {\r\n        for (INT i = 0; i < siz; ++i)\r\n        {\r\n            MRect& rcCtrl = m_vecInfo[i].m_rcCtrl;\r\n            ::DeferWindowPos(hDWP, m_vecInfo[i].m_hwndCtrl,\r\n                NULL,\r\n                rcCtrl.left - ScrollPos().x, rcCtrl.top - ScrollPos().y,\r\n                rcCtrl.Width(), rcCtrl.Height(),\r\n                SWP_NOACTIVATE | SWP_NOZORDER);\r\n        }\r\n        ::EndDeferWindowPos(hDWP);\r\n    }\r\n}\r\n\r\ninline void MScrollView::HScroll(INT nSB_, INT nPos)\r\n{\r\n    SCROLLINFO si;\r\n    si.cbSize = sizeof(si);\r\n    si.fMask = SIF_ALL;\r\n    GetHScrollInfo(&si);\r\n\r\n    switch (nSB_)\r\n    {\r\n    case SB_TOP:\r\n        SetHScrollPos(0);\r\n        break;\r\n\r\n    case SB_BOTTOM:\r\n        SetHScrollPos(si.nMax - si.nPage);\r\n        break;\r\n\r\n    case SB_LINELEFT:\r\n        SetHScrollPos(si.nPos - 16);\r\n        break;\r\n\r\n    case SB_LINERIGHT:\r\n        SetHScrollPos(si.nPos + 16);\r\n        break;\r\n\r\n    case SB_PAGELEFT:\r\n        SetHScrollPos(si.nPos - si.nPage);\r\n        break;\r\n\r\n    case SB_PAGERIGHT:\r\n        SetHScrollPos(si.nPos + si.nPage);\r\n        break;\r\n\r\n    case SB_THUMBPOSITION:\r\n    case SB_THUMBTRACK:\r\n        SetHScrollPos(nPos);\r\n        break;\r\n    }\r\n\r\n    ScrollPos().x = GetHScrollPos();\r\n    UpdateAll();\r\n}\r\n\r\ninline void MScrollView::VScroll(INT nSB_, INT nPos)\r\n{\r\n    SCROLLINFO si;\r\n    si.cbSize = sizeof(si);\r\n    si.fMask = SIF_ALL;\r\n    GetVScrollInfo(&si);\r\n\r\n    switch (nSB_)\r\n    {\r\n    case SB_TOP:\r\n        SetVScrollPos(0);\r\n        break;\r\n\r\n    case SB_BOTTOM:\r\n        SetVScrollPos(si.nMax - si.nPage);\r\n        break;\r\n\r\n    case SB_LINELEFT:\r\n        SetVScrollPos(si.nPos - 16);\r\n        break;\r\n\r\n    case SB_LINERIGHT:\r\n        SetVScrollPos(si.nPos + 16);\r\n        break;\r\n\r\n    case SB_PAGELEFT:\r\n        SetVScrollPos(si.nPos - si.nPage);\r\n        break;\r\n\r\n    case SB_PAGERIGHT:\r\n        SetVScrollPos(si.nPos + si.nPage);\r\n        break;\r\n\r\n    case SB_THUMBPOSITION:\r\n    case SB_THUMBTRACK:\r\n        SetVScrollPos(nPos);\r\n        break;\r\n    }\r\n\r\n    ScrollPos().y = GetVScrollPos();\r\n    UpdateAll();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSCROLLVIEW_HPP_\r\n
MSecurity.hpp<>MSecurity.hpp<>// MSecurity.hpp -- security                                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSECURITY_HPP_\r\n#define MZC4_MSECURITY_HPP_     2   /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MSecurityAttributes.hpp"\r\n#include "MSecurityDescriptor.hpp"\r\n\r\ninline BOOL EnableProcessPriviledgeDx(LPCTSTR pszSE_)\r\n{\r\n    BOOL f;\r\n    HANDLE hToken;\r\n    LUID luid;\r\n    TOKEN_PRIVILEGES tp;\r\n    \r\n    f = FALSE;\r\n    if (::OpenProcessToken(::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,\r\n                           &hToken))\r\n    {\r\n        if (::LookupPrivilegeValue(NULL, pszSE_, &luid))\r\n        {\r\n            tp.PrivilegeCount = 1;\r\n            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\r\n            tp.Privileges[0].Luid = luid;\r\n            f = ::AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);\r\n        }\r\n        ::CloseHandle(hToken);\r\n    }\r\n\r\n    return f;\r\n}\r\n\r\ninline BOOL EnableThreadPriviledgeDx(LPCTSTR pszSE_)\r\n{\r\n    BOOL f;\r\n    HANDLE hToken;\r\n    LUID luid;\r\n    TOKEN_PRIVILEGES tp;\r\n    \r\n    f = FALSE;\r\n    if (::OpenThreadToken(::GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES,\r\n                          FALSE, &hToken))\r\n    {\r\n        if (::LookupPrivilegeValue(NULL, pszSE_, &luid))\r\n        {\r\n            tp.PrivilegeCount = 1;\r\n            tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\r\n            tp.Privileges[0].Luid = luid;\r\n            f = ::AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL);\r\n        }\r\n        ::CloseHandle(hToken);\r\n    }\r\n\r\n    return f;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSECURITY_HPP_\r\n
MSecurityAttributes.hpp<>MSecurityAttributes.hpp<>// MSecurityAttributes.hpp -- security attributes wrapper       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSECURITYATTRIBUTES_HPP_\r\n#define MZC4_MSECURITYATTRIBUTES_HPP_       2   /* Version 2 */\r\n\r\nclass MSecurityAttributes;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MSecurityAttributes : public SECURITY_ATTRIBUTES\r\n{\r\npublic:\r\n    MSecurityAttributes(BOOL bInherit = TRUE,\r\n                        LPVOID pSecurityDescriptor = NULL);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline\r\nMSecurityAttributes::MSecurityAttributes(\r\n    BOOL bInherit/* = TRUE*/, LPVOID pSecurityDescriptor/* = NULL*/)\r\n{\r\n    nLength = sizeof(SECURITY_ATTRIBUTES);\r\n    lpSecurityDescriptor = pSecurityDescriptor;\r\n    bInheritHandle = bInherit;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSECURITYATTRIBUTES_HPP_\r\n
MSecurityDescriptor.hpp<>MSecurityDescriptor.hpp<>// MSecurityDescriptor.hpp -- security descriptor wrapper       -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSECURITYDESCRIPTOR_HPP_\r\n#define MZC4_MSECURITYDESCRIPTOR_HPP_\r\n\r\nclass MSecurityDescriptor;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <accctrl.h>        // for EXPLICIT_ACCESS\r\n#include <aclapi.h>         // for ::BuildExplicitAccessWithName\r\n#include <cassert>          // assert\r\n\r\n#pragma comment(lib, "advapi32.lib")\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MSecurityDescriptor : public SECURITY_DESCRIPTOR\r\n{\r\npublic:\r\n    MSecurityDescriptor();\r\n    BOOL AttachEmptyDacl(); // grant all\r\n    BOOL AttachNullDacl();  // grant none\r\n    DWORD AttachDenyDacl(LPTSTR pszTrusteeName);\r\n    DWORD AttachGrantDacl(LPTSTR pszTrusteeName);\r\n};\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\ninline BOOL MSecurityDescriptor::AttachEmptyDacl()\r\n{\r\n    ACL acl;\r\n    BOOL b = ::InitializeAcl(&acl, sizeof(acl), ACL_REVISION);\r\n    assert(b);\r\n    if (b)\r\n    {\r\n        b = ::SetSecurityDescriptorDacl(this, TRUE, &acl, TRUE);\r\n        assert(b);\r\n    }\r\n    return b;\r\n}\r\n\r\ninline BOOL MSecurityDescriptor::AttachNullDacl()\r\n{\r\n    BOOL b = ::SetSecurityDescriptorDacl(this, TRUE, NULL, TRUE);\r\n    assert(b);\r\n    return b;\r\n}\r\n\r\ninline DWORD MSecurityDescriptor::AttachDenyDacl(LPTSTR pszTrusteeName)\r\n{\r\n    EXPLICIT_ACCESS ea;\r\n    ZeroMemory(&ea, sizeof(ea));\r\n    ::BuildExplicitAccessWithName(&ea, pszTrusteeName,\r\n        GENERIC_ALL, DENY_ACCESS, NO_INHERITANCE);\r\n    PACL pDacl;\r\n    DWORD dwResult = ::SetEntriesInAcl(1, &ea, NULL, &pDacl);\r\n    assert(dwResult == ERROR_SUCCESS);\r\n    ::LocalFree(pDacl);\r\n    return dwResult;\r\n}\r\n\r\ninline DWORD MSecurityDescriptor::AttachGrantDacl(LPTSTR pszTrusteeName)\r\n{\r\n    EXPLICIT_ACCESS ea;\r\n    ZeroMemory(&ea, sizeof(ea));\r\n    ::BuildExplicitAccessWithName(&ea, pszTrusteeName,\r\n        GENERIC_ALL, GRANT_ACCESS, NO_INHERITANCE);\r\n    PACL pDacl;\r\n    DWORD dwResult = ::SetEntriesInAcl(1, &ea, NULL, &pDacl);\r\n    assert(dwResult == ERROR_SUCCESS);\r\n    ::LocalFree(pDacl);\r\n    return dwResult;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSECURITYDESCRIPTOR_HPP_\r\n
MSemaphore.hpp<>MSemaphore.hpp<>// MSemaphore.hpp -- Win32API semaphore object wrapper          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSEMAPHORE_HPP_\r\n#define MZC4_MSEMAPHORE_HPP_     3   /* Version 3 */\r\n\r\nclass MSemaphore;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MSyncBase.hpp"\r\n\r\nclass MSemaphore : public MSyncBase\r\n{\r\npublic:\r\n    MSemaphore();\r\n    MSemaphore(HANDLE hSem);\r\n    MSemaphore(const MSemaphore& s);\r\n    MSemaphore& operator=(HANDLE hSem);\r\n    MSemaphore& operator=(const MSemaphore& s);\r\n    MSemaphore(LONG lInitialCount, LONG lMaxCount = 1,\r\n               LPCTSTR pstrName = NULL,\r\n               LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);\r\n    BOOL CreateSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,\r\n                         LPCTSTR pstrName = NULL,\r\n                         LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);\r\n    virtual BOOL Unlock();\r\n    virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MSemaphore::MSemaphore()\r\n{\r\n}\r\n\r\ninline MSemaphore::MSemaphore(HANDLE hSem) : MSyncBase(hSem)\r\n{\r\n}\r\n\r\ninline MSemaphore::MSemaphore(const MSemaphore& s)\r\n    : MSyncBase(CloneHandleDx(s))\r\n{\r\n}\r\n\r\ninline MSemaphore& MSemaphore::operator=(HANDLE hSem)\r\n{\r\n    if (Handle() != hSem)\r\n    {\r\n        Attach(hSem);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MSemaphore& MSemaphore::operator=(const MSemaphore& s)\r\n{\r\n    if (Handle() != s.Handle())\r\n    {\r\n        HANDLE hSem = CloneHandleDx(s);\r\n        Attach(hSem);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline MSemaphore::MSemaphore(LONG lInitialCount,\r\n    LONG lMaxCount/* = 1*/, LPCTSTR pstrName/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpsaAttributes/* = NULL*/)\r\n    : MSyncBase(::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount, pstrName))\r\n{\r\n    assert(lMaxCount > 0);\r\n    assert(lInitialCount <= lMaxCount);\r\n}\r\n\r\ninline /*virtual*/ BOOL MSemaphore::Unlock()\r\n{\r\n    return Unlock(1);\r\n}\r\n\r\ninline BOOL MSemaphore::CreateSemaphore(\r\n    LONG lInitialCount/* = 1*/, LONG lMaxCount/* = 1*/,\r\n    LPCTSTR pstrName/* = NULL*/,\r\n    LPSECURITY_ATTRIBUTES lpsaAttributes/* = NULL*/)\r\n{\r\n    assert(lMaxCount > 0);\r\n    assert(lInitialCount <= lMaxCount);\r\n    return Attach(::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount, pstrName));\r\n}\r\n\r\ninline /*virtual*/ BOOL MSemaphore::Unlock(LONG lCount, LPLONG lprevCount/* = NULL*/)\r\n{\r\n    return ::ReleaseSemaphore(m_hObject, lCount, lprevCount);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSEMAPHORE_HPP_\r\n
MSound.hpp<>MSound.hpp<>// MSound.hpp -- MZC4 sound                                     -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSOUND_HPP_\r\n#define MZC4_MSOUND_HPP_        3       /* Version 3 */\r\n\r\nclass MSound;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#pragma comment(lib, "winmm.lib")\r\n#pragma comment(lib, "msacm32.lib")\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>\r\n#endif\r\n#ifndef _INC_MMSYSTEM\r\n    #include <mmsystem.h>\r\n#endif\r\n#ifndef _INC_MMREG\r\n    #include <mmreg.h>\r\n#endif\r\n#ifndef _INC_MSACM\r\n    #include <msacm.h>\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MByteStream.hpp"\r\n#include "MFile.hpp"\r\n\r\nclass MSound\r\n{\r\npublic:\r\n    MSound();\r\n    MSound(LPCTSTR pszName, BOOL bFile = FALSE, BOOL bMp3 = FALSE);\r\n    virtual ~MSound();\r\n\r\n    BOOL Load(LPCTSTR pszName, BOOL bFile = FALSE, BOOL bMP3 = FALSE);\r\n    BOOL SaveToWaveFile(LPCTSTR pszFile);\r\n    void Unload();\r\n\r\n    BOOL LoadWaveFromFile(LPCTSTR pszFile);\r\n    BOOL LoadWaveFromResource(LPCTSTR pszResource, HINSTANCE hInstance = NULL);\r\n    BOOL LoadWaveFromResource(UINT nResourceID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadWaveFromMemory(LPVOID pv, DWORD cb);\r\n\r\n    BOOL LoadMp3FromFile(LPCTSTR pszFile);\r\n    BOOL LoadMp3FromResource(LPCTSTR pszResource, HINSTANCE hInstance = NULL);\r\n    BOOL LoadMp3FromResource(UINT nResourceID, HINSTANCE hInstance = NULL);\r\n    BOOL LoadMp3FromMemory(LPVOID pv, DWORD cb);\r\n\r\n    BOOL Play(BOOL bRepeat = FALSE);\r\n    BOOL PlayAndWait();\r\n    void Stop();\r\n\r\n    LPVOID GetPtr();\r\n\r\n    static void SetSoundVolume(WORD left, WORD right);\r\n    static void StopAll(void);\r\n\r\nprotected:\r\n    MByteStream         m_binWave;\r\n    LPVOID              m_pvWave;\r\n    DWORD               m_cbWave;\r\n    BOOL                m_bAlloc;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MSound::MSound() : m_pvWave(NULL), m_cbWave(0), m_bAlloc(FALSE)\r\n{\r\n}\r\n\r\ninline void MSound::Unload()\r\n{\r\n    m_binWave.clear();\r\n    m_pvWave = NULL;\r\n    m_cbWave = 0;\r\n    m_bAlloc = FALSE;\r\n}\r\n\r\ninline /*static*/ void SetSoundVolume(WORD left, WORD right)\r\n{\r\n    ::waveOutSetVolume(reinterpret_cast<HWAVEOUT>(WAVE_MAPPER), MAKELONG(left, right));\r\n}\r\n\r\ninline /*static*/ void MSound::StopAll(void)\r\n{\r\n    ::PlaySound(NULL, NULL, SND_PURGE);\r\n    ::PlaySound(NULL, ::GetModuleHandle(NULL), SND_PURGE);\r\n}\r\n\r\ninline INT GetMp3FrameHeaderDx(MPEGLAYER3WAVEFORMAT *pwf, LPBYTE& pb, DWORD& cb)\r\n{\r\n    BYTE head[4], byte;\r\n    INT ver, layer, bitrate, samp, padding, empha, cbFrame;\r\n    static const INT anMp3Freq_[3] = {44100, 48000, 32000};\r\n    static const SHORT anMp3BitRate_[2][3][15] =\r\n    {\r\n        {\r\n            {0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448}, \r\n            {0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384}, \r\n            {0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320}\r\n        }, \r\n        {\r\n            {0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256}, \r\n            {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}, \r\n            {0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160}\r\n        }\r\n    };\r\n    static const INT anMp3SmpPerFrame_[3][3] =\r\n    {\r\n        {384, 1152, 1152}, {384, 1152, 576}, {384, 1152, 576}\r\n    };\r\n\r\nretry:\r\n    if (cb < 2)\r\n        return 0;\r\n    CopyMemory(head, &pb[0], 2);\r\n    pb += 2; cb -= 2;\r\n\r\n    while (!(head[0] == 0xFF && (head[1] & 0xE0) == 0xE0))\r\n    {\r\n        if (cb < 1)\r\n            return 0;\r\n        byte = pb[0];\r\n        pb++; cb--;\r\n        head[0] = head[1];\r\n        head[1] = byte;\r\n    }\r\n\r\n    if (cb < 2)\r\n        return 0;\r\n    CopyMemory(&head[2], &pb[0], 2);\r\n    pb += 2; cb -= 2;\r\n\r\n    ver = (head[1] >> 3) & 3;\r\n    layer = (head[1] >> 1) & 3;\r\n    bitrate = (head[2] >> 4) & 0xf;\r\n    samp = (head[2] >> 2) & 3;\r\n    empha = head[3] & 3;\r\n\r\n    if (ver == 1 || layer == 0 || bitrate == 15 || samp == 3 || empha == 2)\r\n    {\r\n        pb -= 3; cb += 3;\r\n        goto retry;\r\n    }\r\n\r\n    if (ver == 0) ver = 2;\r\n    else if (ver == 2) ver = 1;\r\n    else ver = 0;\r\n\r\n    layer = 3 - layer;\r\n    bitrate = anMp3BitRate_[(ver == 0) ? 0 : 1][layer][bitrate];\r\n    samp = anMp3Freq_[samp] >> ver;\r\n    padding = (head[2] >> 1) & 1;\r\n    cbFrame = anMp3SmpPerFrame_[ver][layer] / 8 *\r\n        bitrate * 1000 / samp + padding;\r\n\r\n    if (pwf != NULL)\r\n    {\r\n        pwf->wfx.wFormatTag      = WAVE_FORMAT_MPEGLAYER3;\r\n        pwf->wfx.nChannels       = WORD((((head[3] >> 6) & 3) == 3) ? 1 : 2);\r\n        pwf->wfx.nSamplesPerSec  = (DWORD)samp;\r\n        pwf->wfx.nAvgBytesPerSec = DWORD(bitrate * 1000 / 8);\r\n        pwf->wfx.nBlockAlign     = 1;\r\n        pwf->wfx.wBitsPerSample  = 0;\r\n        pwf->wfx.cbSize          = MPEGLAYER3_WFX_EXTRA_BYTES;\r\n\r\n        pwf->wID                 = MPEGLAYER3_ID_MPEG;\r\n        pwf->nBlockSize          = (WORD)cbFrame; \r\n        pwf->nFramesPerBlock     = 1;\r\n        pwf->nCodecDelay         = 1393;\r\n        if (padding)\r\n            pwf->fdwFlags = MPEGLAYER3_FLAG_PADDING_ON;\r\n        else\r\n            pwf->fdwFlags = MPEGLAYER3_FLAG_PADDING_OFF;\r\n    }\r\n\r\n    pb -= 4; cb += 4;\r\n\r\n    return cbFrame;\r\n}\r\n\r\ninline BOOL ConvertMp3ToWaveDx(MByteStream& bin, LPBYTE& pb, DWORD& cb)\r\n{\r\n    MPEGLAYER3WAVEFORMAT wfmp3;\r\n    WAVEFORMATEX wfwav;\r\n    HACMSTREAM has;\r\n    ACMSTREAMHEADER ash;\r\n    DWORD cbTemp, cbWavBuf, cbData, /*cFrames,*/ cbFrame;\r\n    const DWORD cbMp3Buf = 131072;\r\n\r\n    bin.clear();\r\n    GetMp3FrameHeaderDx(&wfmp3, pb, cb);\r\n\r\n    ZeroMemory(&wfwav, sizeof(wfwav));\r\n    wfwav.wFormatTag = WAVE_FORMAT_PCM;\r\n\r\n    if (::acmFormatSuggest(NULL, (WAVEFORMATEX *)&wfmp3, &wfwav, \r\n            sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG))\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    if (::acmStreamOpen(&has, NULL, (WAVEFORMATEX *)&wfmp3, &wfwav, \r\n            NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME))\r\n    {\r\n        assert(FALSE);\r\n        return FALSE;\r\n    }\r\n\r\n    ::acmStreamSize(has,\r\n        DWORD(wfmp3.nBlockSize + 1), &cbWavBuf, ACM_STREAMSIZEF_SOURCE);\r\n\r\n    MByteStream     mp3_buf(cbMp3Buf);\r\n    MByteStream     wav_buf(cbWavBuf);\r\n\r\n    ZeroMemory(&ash, sizeof(ash));\r\n    ash.cbStruct        = sizeof(ash);\r\n    ash.pbSrc           = &mp3_buf[0];\r\n    ash.cbSrcLength     = DWORD(wfmp3.nBlockSize + 1);\r\n    ash.pbDst           = &wav_buf[0];\r\n    ash.cbDstLength     = cbWavBuf;\r\n\r\n    if (::acmStreamPrepareHeader(has, &ash, 0))\r\n    {\r\n        assert(FALSE);\r\n        ::acmStreamClose(has, 0);\r\n        return FALSE;\r\n    }\r\n\r\n    bin.WriteData("RIFF????WAVEfmt ", 16);\r\n    cbTemp = sizeof(WAVEFORMATEX);\r\n    bin.WriteData(&cbTemp, 4);\r\n    bin.WriteData(&wfwav, (INT)cbTemp);\r\n    bin.WriteData("data????", 8);\r\n\r\n    for(cbData = /*cFrames =*/ 0; ; /*cFrames++*/)\r\n    {\r\n        cbFrame = static_cast<DWORD>(GetMp3FrameHeaderDx(NULL, pb, cb));\r\n        if (cbFrame == 0)\r\n        {\r\n            break;\r\n        }\r\n\r\n        if (cb < cbFrame)\r\n        {\r\n            assert(FALSE);\r\n            break;\r\n        }\r\n\r\n        CopyMemory(&mp3_buf[0], pb, cbFrame);\r\n        pb += cbFrame; cb -= cbFrame;\r\n\r\n        ash.cbSrcLength = cbFrame;\r\n        if (::acmStreamConvert(has, &ash, 0))\r\n        {\r\n            assert(FALSE);\r\n            break;\r\n        }\r\n\r\n        if (ash.cbDstLengthUsed)\r\n        {\r\n            bin.WriteData(&wav_buf[0], (INT)ash.cbDstLengthUsed);\r\n            cbData += ash.cbDstLengthUsed;\r\n        }\r\n    }\r\n    //MzcTrace(TEXT("cFrames: %d\\r\\n"), cFrames);\r\n\r\n    cbTemp = 20 + sizeof(WAVEFORMATEX) + 4 + cbData;\r\n    CopyMemory(&bin[4], &cbTemp, 4);\r\n    CopyMemory(&bin[16 + 4 + sizeof(WAVEFORMATEX) + 4], &cbData, 4);\r\n\r\n    ::acmStreamUnprepareHeader(has, &ash, 0);\r\n    ::acmStreamClose(has, 0);\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline\r\nMSound::MSound(LPCTSTR pszName, BOOL bFile/* = FALSE*/, BOOL bMp3/* = FALSE*/)\r\n    : m_pvWave(NULL), m_cbWave(0), m_bAlloc(FALSE)\r\n{\r\n    Load(pszName, bFile, bMp3);\r\n}\r\n\r\ninline /*virtual*/ MSound::~MSound()\r\n{\r\n}\r\n\r\ninline BOOL\r\nMSound::Load(LPCTSTR pszName, BOOL bFile/* = FALSE*/, BOOL bMP3/* = FALSE*/)\r\n{\r\n    if (bMP3)\r\n    {\r\n        if (bFile)\r\n            return LoadMp3FromFile(pszName);\r\n        else\r\n            return LoadMp3FromResource(pszName);\r\n    }\r\n    else\r\n    {\r\n        if (bFile)\r\n            return LoadWaveFromFile(pszName);\r\n        else\r\n            return LoadWaveFromResource(pszName);\r\n    }\r\n}\r\n\r\ninline BOOL MSound::LoadWaveFromFile(LPCTSTR pszFile)\r\n{\r\n    using namespace std;\r\n    size_t cb;\r\n    LPBYTE pb = MFile_GetContents(pszFile, &cb);\r\n    assert(pb);\r\n    assert(cb);\r\n    if (cb > 12 &&\r\n        pb[0] == 'R' && pb[1] == 'I' && pb[2] == 'F' && pb[3] == 'F' &&\r\n        pb[8] == 'W' && pb[9] == 'A' && pb[10] == 'V' && pb[11] == 'E')\r\n    {\r\n        m_bAlloc = TRUE;\r\n        m_pvWave = NULL;\r\n        m_cbWave = 0;\r\n        m_binWave.assign(pb, pb + cb);\r\n        free(pb);\r\n        return TRUE;\r\n    }\r\n    assert(FALSE);\r\n    free(pb);\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL\r\nMSound::LoadWaveFromResource(LPCTSTR pszResource, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    HRSRC hRsrc = ::FindResource(hInstance, pszResource, TEXT("WAVE"));\r\n    if (hRsrc != NULL)\r\n    {\r\n        DWORD cb = ::SizeofResource(hInstance, hRsrc);\r\n        HGLOBAL hGlobal = ::LoadResource(hInstance, hRsrc);\r\n        if (hGlobal != NULL)\r\n        {\r\n            LPVOID pv = ::LockResource(hGlobal);\r\n            if (pv != NULL)\r\n            {\r\n                m_pvWave = pv;\r\n                m_cbWave = cb;\r\n                m_bAlloc = FALSE;\r\n                m_binWave.clear();\r\n                return TRUE;\r\n            }\r\n        }\r\n    }\r\n    assert(FALSE);\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL\r\nMSound::LoadWaveFromResource(UINT nResourceID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    return LoadWaveFromResource(MAKEINTRESOURCE(nResourceID), hInstance);\r\n}\r\n\r\ninline BOOL MSound::LoadMp3FromFile(LPCTSTR pszFile)\r\n{\r\n    using namespace std;\r\n    size_t cb;\r\n    BOOL bOK = FALSE;\r\n    LPBYTE pb = MFile_GetContents(pszFile, &cb);\r\n    if (pb)\r\n    {\r\n        bOK = LoadMp3FromMemory(pb, cb);\r\n        free(pb);\r\n    }\r\n    assert(bOK);\r\n    return bOK;\r\n}\r\n\r\ninline BOOL\r\nMSound::LoadMp3FromResource(LPCTSTR pszResource, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    HRSRC hRsrc = ::FindResource(hInstance, pszResource, TEXT("MP3"));\r\n    if (hRsrc != NULL)\r\n    {\r\n        DWORD cb = ::SizeofResource(hInstance, hRsrc);\r\n        HGLOBAL hGlobal = ::LoadResource(hInstance, hRsrc);\r\n        if (hGlobal != NULL)\r\n        {\r\n            LPVOID pv = ::LockResource(hGlobal);\r\n            if (pv != NULL)\r\n                return LoadMp3FromMemory(pv, cb);\r\n        }\r\n    }\r\n    assert(FALSE);\r\n    return FALSE;\r\n}\r\n\r\ninline BOOL\r\nMSound::LoadMp3FromResource(UINT nResourceID, HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    return LoadMp3FromResource(MAKEINTRESOURCE(nResourceID), hInstance);\r\n}\r\n\r\ninline BOOL MSound::LoadMp3FromMemory(LPVOID pv, DWORD cb)\r\n{\r\n    LPBYTE pb = (LPBYTE)pv;\r\n    BOOL b = ConvertMp3ToWaveDx(m_binWave, pb, cb);\r\n    assert(b);\r\n    if (b)\r\n        m_bAlloc = TRUE;\r\n    return b;\r\n}\r\n\r\ninline BOOL MSound::Play(BOOL bRepeat/* = FALSE*/)\r\n{\r\n    if (m_bAlloc)\r\n    {\r\n        if (bRepeat)\r\n            return ::PlaySound((LPTSTR)&m_binWave[0], NULL, SND_LOOP |\r\n                SND_ASYNC | SND_MEMORY | SND_NODEFAULT | SND_NOSTOP);\r\n        else\r\n            return ::PlaySound((LPTSTR)&m_binWave[0], NULL,\r\n                SND_ASYNC | SND_MEMORY | SND_NODEFAULT | SND_NOSTOP);\r\n    }\r\n    else\r\n    {\r\n        if (bRepeat)\r\n            return ::PlaySound((LPCTSTR)m_pvWave, NULL, SND_LOOP |\r\n                SND_ASYNC | SND_MEMORY | SND_NODEFAULT | SND_NOSTOP);\r\n        else\r\n            return ::PlaySound((LPCTSTR)m_pvWave, NULL,\r\n                SND_ASYNC | SND_MEMORY | SND_NODEFAULT | SND_NOSTOP);\r\n    }\r\n}\r\n\r\ninline LPVOID MSound::GetPtr()\r\n{\r\n    if (m_bAlloc)\r\n        return &m_binWave[0];\r\n    else\r\n        return m_pvWave;\r\n}\r\n\r\ninline BOOL MSound::PlayAndWait()\r\n{\r\n    return ::PlaySound((LPCTSTR)GetPtr(), NULL,\r\n        SND_SYNC | SND_MEMORY | SND_NODEFAULT | SND_NOSTOP);\r\n}\r\n\r\ninline BOOL MSound::SaveToWaveFile(LPCTSTR pszFile)\r\n{\r\n    BOOL b = MFile_PutContents(pszFile, &m_binWave[0], m_binWave.size());\r\n    assert(b);\r\n    return b;\r\n}\r\n\r\ninline void MSound::Stop()\r\n{\r\n    ::PlaySound(reinterpret_cast<LPCTSTR>(GetPtr()), NULL, SND_PURGE);\r\n}\r\n\r\n#endif  // ndef MZC4_MSOUND_HPP_\r\n
MSplitterWnd.hpp<>MSplitterWnd.hpp<>// MSplitterWnd.hpp --- MZC4 splitter window                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSPLITTERWND_HPP_\r\n#define MZC4_MSPLITTERWND_HPP_      9   /* Version 9 */\r\n\r\nclass MSplitterWnd;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n#include <vector>\r\n\r\n// The styles of MSplitterWnd\r\n#define SWS_HORZ            0\r\n#define SWS_VERT            1\r\n#define SWS_LEFTALIGN       0\r\n#define SWS_TOPALIGN        0\r\n#define SWS_RIGHTALIGN      2\r\n#define SWS_BOTTOMALIGN     2\r\n\r\nclass MSplitterWnd : public MWindowBase\r\n{\r\npublic:\r\n    enum { m_cxyBorder = 4, m_cxyMin = 8 };\r\n    enum { NOTIFY_CHANGED = 0x2934 };\r\n\r\n    MSplitterWnd() : m_iDraggingBorder(-1), m_nPaneCount(0)\r\n    {\r\n        m_vecPanes.resize(1);\r\n    }\r\n\r\n    BOOL CreateDx(HWND hwndParent, INT nPaneCount = 2,\r\n                  DWORD dwStyle = WS_CHILD | WS_VISIBLE | SWS_HORZ | SWS_LEFTALIGN,\r\n                  DWORD dwExStyle = 0)\r\n    {\r\n        RECT rc;\r\n        GetClientRect(hwndParent, &rc);\r\n\r\n        if (!CreateWindowDx(hwndParent, NULL, dwStyle, dwExStyle,\r\n                            rc.left, rc.top,\r\n                            rc.right - rc.left, rc.bottom - rc.top))\r\n        {\r\n            return FALSE;\r\n        }\r\n\r\n        SetPaneCount(nPaneCount);\r\n        PostMessageDx(WM_SIZE);\r\n        return TRUE;\r\n    }\r\n\r\n    BOOL IsHorizontal() const\r\n    {\r\n        return !IsVertical();\r\n    }\r\n    BOOL IsVertical() const\r\n    {\r\n        return (GetStyleDx() & SWS_VERT) == SWS_VERT;\r\n    }\r\n    BOOL IsRightBottomAlign() const\r\n    {\r\n        return (GetStyleDx() & SWS_RIGHTALIGN) == SWS_RIGHTALIGN;\r\n    }\r\n\r\n    INT GetPaneCount() const\r\n    {\r\n        return m_nPaneCount;\r\n    }\r\n    VOID SetPaneCount(INT nCount)\r\n    {\r\n        m_vecPanes.resize(nCount + 1);\r\n        m_nPaneCount = nCount;\r\n        SplitEqually();\r\n    }\r\n\r\n    HWND GetPane(INT nIndex) const\r\n    {\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        return m_vecPanes[nIndex].hwndPane;\r\n    }\r\n    VOID SetPane(INT nIndex, HWND hwndPane)\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        m_vecPanes[nIndex].hwndPane = hwndPane;\r\n    }\r\n\r\n    INT GetPanePos(INT nIndex) const\r\n    {\r\n        assert(0 <= nIndex && nIndex <= m_nPaneCount);\r\n        return m_vecPanes[nIndex].xyPos;\r\n    }\r\n    VOID SetPanePos(INT nIndex, INT nPos, BOOL bBounded = TRUE)\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        assert(0 <= nIndex && nIndex <= m_nPaneCount);\r\n        if (nIndex == 0)\r\n            return;\r\n\r\n        if (bBounded)\r\n        {\r\n            if (nIndex < m_nPaneCount)\r\n            {\r\n                const PANEINFO& info = m_vecPanes[nIndex];\r\n                const PANEINFO& next_info = m_vecPanes[nIndex + 1];\r\n                if (next_info.xyPos < nPos + info.cxyMin)\r\n                    nPos = next_info.xyPos - info.cxyMin;\r\n            }\r\n\r\n            const PANEINFO& prev_info = m_vecPanes[nIndex - 1];\r\n            if (nPos < prev_info.xyPos + prev_info.cxyMin)\r\n                nPos = prev_info.xyPos + prev_info.cxyMin;\r\n        }\r\n\r\n        m_vecPanes[nIndex].xyPos = nPos;\r\n    }\r\n\r\n    INT GetPaneExtent(INT nIndex) const\r\n    {\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        return m_vecPanes[nIndex + 1].xyPos - m_vecPanes[nIndex].xyPos;\r\n    }\r\n\r\n    VOID SetPaneExtent(INT nIndex, INT cxy, BOOL bUpdate = TRUE)\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        if (nIndex == m_nPaneCount - 1)\r\n        {\r\n            SetPanePos(nIndex, m_vecPanes[m_nPaneCount].xyPos - cxy);\r\n        }\r\n        else\r\n        {\r\n            SetPanePos(nIndex + 1, m_vecPanes[nIndex].xyPos + cxy);\r\n        }\r\n        UpdatePanes();\r\n    }\r\n\r\n    VOID SetPaneMinExtent(INT nIndex, INT cxyMin = MSplitterWnd::m_cxyMin)\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        m_vecPanes[nIndex].cxyMin = cxyMin;\r\n    }\r\n\r\n    INT GetTotalMinExtent() const\r\n    {\r\n        INT cxy = 0;\r\n        for (INT i = 0; i < m_nPaneCount; ++i)\r\n        {\r\n            cxy += m_vecPanes[i].cxyMin;\r\n        }\r\n        return cxy;\r\n    }\r\n\r\n    VOID GetPaneRect(INT nIndex, RECT *prc) const\r\n    {\r\n        assert(0 <= nIndex && nIndex < m_nPaneCount);\r\n        ::GetClientRect(m_hwnd, prc);\r\n        if (IsVertical())\r\n        {\r\n            prc->top = m_vecPanes[nIndex].xyPos;\r\n            prc->bottom = m_vecPanes[nIndex + 1].xyPos;\r\n            if (nIndex < m_nPaneCount - 1)\r\n                prc->bottom -= m_cxyBorder;\r\n        }\r\n        else\r\n        {\r\n            prc->left = m_vecPanes[nIndex].xyPos;\r\n            prc->right = m_vecPanes[nIndex + 1].xyPos;\r\n            if (nIndex < m_nPaneCount - 1)\r\n                prc->right -= m_cxyBorder;\r\n        }\r\n    }\r\n\r\n    INT HitTestBorder(POINT ptClient) const\r\n    {\r\n        RECT rcClient;\r\n        ::GetClientRect(m_hwnd, &rcClient);\r\n        if (!::PtInRect(&rcClient, ptClient))\r\n            return -1;\r\n\r\n        INT xy = (IsVertical() ? ptClient.y : ptClient.x);\r\n        for (INT i = 1; i < m_nPaneCount; ++i)\r\n        {\r\n            INT xyPos = m_vecPanes[i].xyPos;\r\n            if (xyPos - m_cxyBorder <= xy && xy <= xyPos)\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    void SplitEqually()\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        RECT rc;\r\n        GetClientRect(m_hwnd, &rc);\r\n\r\n        INT cxy = (IsVertical() ? rc.bottom : rc.right);\r\n        INT xy = 0, cxyPane = cxy / m_nPaneCount;\r\n        for (INT i = 0; i < m_nPaneCount; ++i)\r\n        {\r\n            m_vecPanes[i].xyPos = xy;\r\n            xy += cxyPane;\r\n        }\r\n        m_vecPanes[m_nPaneCount].xyPos = cxy;\r\n        PostMessageDx(WM_SIZE);\r\n    }\r\n\r\n    void UpdatePanes()\r\n    {\r\n        RECT rc;\r\n        HDWP hDWP = BeginDeferWindowPos(m_nPaneCount);\r\n        for (INT i = 0; i < m_nPaneCount; ++i)\r\n        {\r\n            const PANEINFO *pInfo = &m_vecPanes[i];\r\n            HWND hwndPane = pInfo->hwndPane;\r\n            if (hwndPane == NULL)\r\n                continue;\r\n\r\n            GetPaneRect(i, &rc);\r\n            hDWP = DeferWindowPos(hDWP, hwndPane, NULL, \r\n                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,\r\n                SWP_NOZORDER | SWP_NOACTIVATE);\r\n        }\r\n        EndDeferWindowPos(hDWP);\r\n\r\n        UINT nID = GetDlgCtrlID(m_hwnd);\r\n        NMHDR notify = { 0 };\r\n        notify.hwndFrom = m_hwnd;\r\n        notify.idFrom = nID;\r\n        notify.code = NOTIFY_CHANGED;\r\n        FORWARD_WM_NOTIFY(GetParent(m_hwnd), nID, &notify, SendMessage);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_SIZE, OnSize);\r\n        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, OnLButtonDown);\r\n        HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK, OnLButtonDown);\r\n        HANDLE_MSG(hwnd, WM_LBUTTONUP, OnLButtonUp);\r\n        HANDLE_MSG(hwnd, WM_MOUSEMOVE, OnMouseMove);\r\n        HANDLE_MSG(hwnd, WM_SETCURSOR, OnSetCursor);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);\r\n        HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);\r\n        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, OnSysColorChange);\r\n        case WM_CAPTURECHANGED:\r\n            m_iDraggingBorder = -1;\r\n            return 0;\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    void OnSysColorChange(HWND hwnd)\r\n    {\r\n        for (size_t i = 0; i < m_vecPanes.size(); ++i)\r\n        {\r\n            SendMessage(m_vecPanes[i].hwndPane, WM_SYSCOLORCHANGE, 0, 0);\r\n        }\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MSplitterWnd Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        FORWARD_WM_COMMAND(GetParent(hwnd), id, hwndCtl, codeNotify, PostMessage);\r\n    }\r\n\r\n    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)\r\n    {\r\n        return FORWARD_WM_NOTIFY(GetParent(hwnd), idFrom, pnmhdr, SendMessage);\r\n    }\r\n\r\n    void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)\r\n    {\r\n        FORWARD_WM_CONTEXTMENU(GetParent(hwnd), hwndContext, xPos, yPos, SendMessage);\r\n    }\r\n\r\n    static HCURSOR& CursorNS()\r\n    {\r\n        static HCURSOR s_hcurNS = ::LoadCursor(NULL, IDC_SIZENS);\r\n        return s_hcurNS;\r\n    }\r\n    static HCURSOR& CursorWE()\r\n    {\r\n        static HCURSOR s_hcurWE = ::LoadCursor(NULL, IDC_SIZEWE);\r\n        return s_hcurWE;\r\n    }\r\n\r\nprotected:\r\n    struct PANEINFO\r\n    {\r\n        HWND    hwndPane;\r\n        INT     xyPos;\r\n        INT     cxyMin;\r\n\r\n        PANEINFO()\r\n        {\r\n            hwndPane = NULL;\r\n            xyPos = 0;\r\n            cxyMin = m_cxyMin;\r\n        }\r\n    };\r\n    INT                     m_iDraggingBorder;\r\n    INT                     m_nPaneCount;\r\n    std::vector<PANEINFO>   m_vecPanes;\r\n\r\n    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)\r\n    {\r\n        if (fDoubleClick)\r\n            return;\r\n\r\n        POINT pt = { x, y };\r\n        INT iBorder = HitTestBorder(pt);\r\n        if (iBorder < 0)\r\n            return;\r\n\r\n        ::SetCapture(hwnd);\r\n        m_iDraggingBorder = iBorder;\r\n\r\n        if (IsVertical())\r\n            ::SetCursor(CursorNS());\r\n        else\r\n            ::SetCursor(CursorWE());\r\n    }\r\n\r\n    void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)\r\n    {\r\n        if (m_iDraggingBorder == -1)\r\n            return;\r\n\r\n        SetPanePos(m_iDraggingBorder, (IsVertical() ? y : x) + m_cxyBorder / 2);\r\n        UpdatePanes();\r\n\r\n        m_iDraggingBorder = -1;\r\n        ::ReleaseCapture();\r\n    }\r\n\r\n    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)\r\n    {\r\n        if (m_iDraggingBorder == -1)\r\n            return;\r\n\r\n        SetPanePos(m_iDraggingBorder, (IsVertical() ? y : x) + m_cxyBorder / 2);\r\n        UpdatePanes();\r\n    }\r\n\r\n    void OnSize(HWND hwnd, UINT state, int cx, int cy)\r\n    {\r\n        if (m_nPaneCount == 0)\r\n            return;\r\n\r\n        RECT rc;\r\n        GetClientRect(hwnd, &rc);\r\n        INT cxy = (IsVertical() ? rc.bottom : rc.right);\r\n        Resize(cxy);\r\n    }\r\n\r\n    void Resize(INT cxy)\r\n    {\r\n        if (IsRightBottomAlign())\r\n        {\r\n            INT dxy = cxy - m_vecPanes[m_nPaneCount].xyPos;\r\n            for (INT i = 1; i < m_nPaneCount; ++i)\r\n            {\r\n                SetPanePos(i, m_vecPanes[i].xyPos + dxy, FALSE);\r\n            }\r\n        }\r\n\r\n        SetPanePos(m_nPaneCount, cxy, FALSE);\r\n        UpdatePanes();\r\n    }\r\n\r\n    BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)\r\n    {\r\n        POINT pt;\r\n        ::GetCursorPos(&pt);\r\n        ::ScreenToClient(hwnd, &pt);\r\n\r\n        if (HitTestBorder(pt) == -1)\r\n        {\r\n            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));\r\n            return TRUE;\r\n        }\r\n\r\n        if (IsVertical())\r\n            ::SetCursor(CursorNS());\r\n        else\r\n            ::SetCursor(CursorWE());\r\n        return TRUE;\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSPLITTERWND_HPP_\r\n
MStaticCtrl.hpp<>MStaticCtrl.hpp<>// MStaticCtrl.hpp -- Win32API static control wrapper           -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSTATICCTRL_HPP_\r\n#define MZC4_MSTATICCTRL_HPP_   2   /* Version 2 */\r\n\r\nclass MStaticCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MStaticCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MStaticCtrl();\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    HICON GetIcon() const;\r\n    HICON SetIcon(HICON hIcon);\r\n\r\n    HENHMETAFILE GetEnhMetaFile() const;\r\n    HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile);\r\n\r\n    HBITMAP GetBitmap() const;\r\n    HBITMAP SetBitmap(HBITMAP hBitmap);\r\n\r\n    HCURSOR GetCursor();\r\n    HCURSOR SetCursor(HCURSOR hCursor);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MStaticCtrl::MStaticCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MStaticCtrl::GetWndClassNameDx() const\r\n{\r\n    return TEXT("STATIC");\r\n}\r\n\r\ninline HICON MStaticCtrl::SetIcon(HICON hIcon)\r\n{\r\n    return (HICON)SendMessageDx(STM_SETICON, (WPARAM)hIcon);\r\n}\r\n\r\ninline HICON MStaticCtrl::GetIcon() const\r\n{\r\n    return (HICON)SendMessageDx(STM_GETICON);\r\n}\r\n\r\ninline HENHMETAFILE MStaticCtrl::SetEnhMetaFile(HENHMETAFILE hMetaFile)\r\n{\r\n    return (HENHMETAFILE)SendMessageDx(STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile);\r\n}\r\n\r\ninline HENHMETAFILE MStaticCtrl::GetEnhMetaFile() const\r\n{\r\n    return (HENHMETAFILE)SendMessageDx(STM_GETIMAGE, IMAGE_ENHMETAFILE);\r\n}\r\n\r\ninline HBITMAP MStaticCtrl::SetBitmap(HBITMAP hBitmap)\r\n{\r\n    return (HBITMAP)SendMessageDx(STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap);\r\n}\r\n\r\ninline HBITMAP MStaticCtrl::GetBitmap() const\r\n{\r\n    return (HBITMAP)SendMessageDx(STM_GETIMAGE, IMAGE_BITMAP);\r\n}\r\n\r\ninline HCURSOR MStaticCtrl::SetCursor(HCURSOR hCursor)\r\n{\r\n    return (HCURSOR)SendMessageDx(STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);\r\n}\r\n\r\ninline HCURSOR MStaticCtrl::GetCursor()\r\n{\r\n    return (HCURSOR)SendMessageDx(STM_GETIMAGE, IMAGE_CURSOR);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSTATICCTRL_HPP_\r\n
MStatusBar.hpp<>MStatusBar.hpp<>// MStatusBar.hpp -- Win32API status bar wrapper                -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSTATUSBAR_HPP_\r\n#define MZC4_MSTATUSBAR_HPP_        2   /* Version 2 */\r\n\r\nclass MStatusBar;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MStatusBar : public MWindowBase\r\n{\r\npublic:\r\n    MStatusBar();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetText(LPCTSTR lpszText, INT nPane, INT* pnSBT_ = NULL) const;\r\n    MString GetText(INT nPane, INT* pnSBT_ = NULL) const;\r\n    INT GetTextLength(INT nPane, INT* pnSBT_ = NULL) const;\r\n    BOOL SetText(LPCTSTR lpszText, INT nPane = 0, INT nSBT_ = 0);\r\n\r\n    INT GetParts(INT nParts, INT* pParts) const;\r\n    BOOL SetParts(INT nParts, INT* pWidths);\r\n    BOOL GetBorders(INT* pBorders) const;\r\n    BOOL GetBorders(INT& nHorz, INT& nVert, INT& nSpacing) const;\r\n    BOOL GetRect(INT iPart, LPRECT prc) const;\r\n    VOID SetMinHeight(INT nMin);\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    BOOL IsSimple() const;\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n    BOOL SetSimple(BOOL bSimple = TRUE);\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    VOID GetTipText(INT nPane, LPTSTR lpstrText, INT nSize) const;\r\n    MString GetTipText(INT nPane) const;\r\n    VOID SetTipText(INT nPane, LPCTSTR pszTipText);\r\n\r\n    HICON GetIcon(INT nPane);\r\n    BOOL SetIcon(INT nPane, HICON hIcon);\r\n\r\n    COLORREF SetBkColor(COLORREF cr);\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    VOID AutoSize();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MStatusBar::MStatusBar()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MStatusBar::GetWndClassNameDx() const\r\n{\r\n    return STATUSCLASSNAME;\r\n}\r\n\r\ninline BOOL MStatusBar::SetText(\r\n    LPCTSTR lpszText, INT nPane/* = 0*/, INT nSBT_/* = 0*/)\r\n{\r\n    assert(nPane < 256);\r\n    return (BOOL)SendMessageDx(SB_SETTEXT, (WPARAM)(nPane | nSBT_), (LPARAM)lpszText);\r\n}\r\n\r\ninline INT MStatusBar::GetText(\r\n    LPCTSTR lpszText, INT nPane, INT* pnSBT_/* = NULL*/) const\r\n{\r\n    assert(nPane < 256);\r\n    DWORD dw = (DWORD)SendMessageDx(SB_GETTEXT, (WPARAM)nPane, (LPARAM)lpszText);\r\n    if (pnSBT_ != NULL)\r\n        *pnSBT_ = (INT) HIWORD(dw);\r\n    return (INT) LOWORD(dw);\r\n}\r\n\r\ninline INT MStatusBar::GetTextLength(\r\n    INT nPane, INT* pnSBT_/* = NULL*/) const\r\n{\r\n    assert(nPane < 256);\r\n    DWORD dw = (DWORD)SendMessageDx(SB_GETTEXTLENGTH, (WPARAM)nPane);\r\n    if (pnSBT_ != NULL)\r\n        *pnSBT_ = (INT) HIWORD(dw);\r\n    return (INT) LOWORD(dw);\r\n}\r\n\r\ninline BOOL MStatusBar::SetParts(INT nParts, INT* pWidths)\r\n{\r\n    return (BOOL)SendMessageDx(SB_SETPARTS, (WPARAM)nParts, (LPARAM)pWidths);\r\n}\r\n\r\ninline INT MStatusBar::GetParts(INT nParts, INT* pParts) const\r\n{\r\n    return (INT)SendMessageDx(SB_GETPARTS, (WPARAM)nParts, (LPARAM)pParts);\r\n}\r\n\r\ninline BOOL MStatusBar::GetBorders(INT* pBorders) const\r\n{\r\n    return (BOOL)SendMessageDx(SB_GETBORDERS, 0, (LPARAM)pBorders);\r\n}\r\n\r\ninline BOOL MStatusBar::GetBorders(\r\n    INT& nHorz, INT& nVert, INT& nSpacing) const\r\n{\r\n    INT an[3];\r\n    BOOL b = (BOOL)SendMessageDx(SB_GETBORDERS, 0, (LPARAM)an);\r\n    if (b)\r\n    {\r\n        nHorz = an[0];\r\n        nVert = an[1];\r\n        nSpacing = an[2];\r\n    }\r\n    return b;\r\n}\r\n\r\ninline VOID MStatusBar::SetMinHeight(INT nMin)\r\n{\r\n    SendMessageDx(SB_SETMINHEIGHT, (WPARAM)nMin);\r\n}\r\n\r\ninline BOOL MStatusBar::GetRect(INT iPart, LPRECT prc) const\r\n{\r\n    assert(iPart < 256);\r\n    return (BOOL)SendMessageDx(SB_GETRECT, (WPARAM)iPart, (LPARAM)prc);\r\n}\r\n#if (_WIN32_IE >= 0x0300)\r\n    \r\ninline BOOL MStatusBar::IsSimple() const\r\n    {\r\n        return (BOOL)SendMessageDx(SB_ISSIMPLE);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline BOOL MStatusBar::SetSimple(BOOL bSimple/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(SB_SIMPLE, (WPARAM)bSimple);\r\n}\r\n\r\ninline VOID MStatusBar::AutoSize()\r\n{\r\n    SendMessageDx(WM_SIZE);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline VOID MStatusBar::GetTipText(\r\n        INT nPane, LPTSTR lpstrText, INT nSize) const\r\n    {\r\n        assert(nPane < 256);\r\n        SendMessageDx(SB_GETTIPTEXT, MAKEWPARAM(nPane, nSize), (LPARAM)lpstrText);\r\n    }\r\n    \r\n    inline MString MStatusBar::GetTipText(INT nPane) const\r\n    {\r\n        assert(nPane < 256);\r\n        TCHAR sz[512];\r\n        GetTipText(nPane, sz, 512);\r\n        MString str = sz;\r\n        return str;\r\n    }\r\n    \r\n    inline VOID MStatusBar::SetTipText(INT nPane, LPCTSTR pszTipText)\r\n    {\r\n        assert(nPane < 256);\r\n        SendMessageDx(SB_SETTIPTEXT, (WPARAM)nPane, (LPARAM)pszTipText);\r\n    }\r\n    \r\n    inline HICON MStatusBar::GetIcon(INT nPane)\r\n    {\r\n        assert(nPane < 256);\r\n        return (HICON)SendMessageDx(SB_GETICON, (WPARAM)nPane);\r\n    }\r\n    \r\n    inline BOOL MStatusBar::SetIcon(INT nPane, HICON hIcon)\r\n    {\r\n        assert(nPane < 256);\r\n        return (BOOL)SendMessageDx(SB_SETICON, (WPARAM)nPane, (LPARAM)hIcon);\r\n    }\r\n    \r\n    inline COLORREF MStatusBar::SetBkColor(COLORREF cr)\r\n    {\r\n        return (COLORREF)SendMessageDx(SB_SETBKCOLOR, 0, (LPARAM)cr);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\ninline MString MStatusBar::GetText(INT nPane, INT* pType/* = NULL*/) const\r\n{\r\n    assert(nPane < 256);\r\n    DWORD dw = (DWORD)(DWORD_PTR)SendMessageDx(SB_GETTEXTLENGTH, (WPARAM)nPane);\r\n\r\n    TCHAR sz[512];\r\n    dw = (DWORD)(DWORD_PTR)SendMessageDx(SB_GETTEXT, (WPARAM)nPane, (LPARAM)sz);\r\n    if (pType != NULL)\r\n        *pType = (INT) HIWORD(dw);\r\n\r\n    MString str = sz;\r\n    return str;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSTATUSBAR_HPP_\r\n
MString.hpp<>MString.hpp<>// MString.hpp -- MZC4 string class                             -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSTRING_HPP_\r\n#define MZC4_MSTRING_HPP_       19  /* Version 19 */\r\n\r\n// class MString;\r\n// class MStringA;\r\n// class MStringW;\r\n// mstr_... functions\r\n// mbin_... functions\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if __cplusplus >= 201103L          /* C++11 */\r\n    #include <cstdint>\r\n#else\r\n    #include "pstdint.h"\r\n#endif\r\n\r\n#include <algorithm>    // for std::reverse\r\n#include <cstring>      // for std::memcmp\r\n\r\n// WCHAR\r\n#ifndef __WCHAR_DEFINED\r\n    #define __WCHAR_DEFINED\r\n    #ifdef _WIN32\r\n        typedef wchar_t WCHAR;\r\n    #else\r\n        #if __cplusplus >= 201103L\r\n            typedef char16_t WCHAR;\r\n        #else\r\n            typedef uint16_t WCHAR;\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n// MString\r\n#ifndef MString\r\n    #include <string>       // for std::basic_string, std::string, ...\r\n    typedef std::string MStringA;\r\n    #if defined(_WIN32) && !defined(WONVER)\r\n        #include <tchar.h>      // Windows generic text mapping\r\n        #ifdef _MBCS\r\n            #include <mbstring.h>   // for _mbsrchr\r\n        #endif\r\n        typedef std::wstring MStringW;\r\n    #else\r\n        typedef std::basic_string<WCHAR> MStringW;\r\n    #endif\r\n    #ifdef UNICODE\r\n        #define MString     MStringW\r\n    #else\r\n        #define MString     MStringA\r\n    #endif\r\n#endif\r\n\r\n// WIDE\r\n#ifndef WIDE\r\n    #ifdef _WIN32\r\n        #define WIDE(sz) L##sz\r\n    #else\r\n        #define WIDE(sz) u##sz\r\n    #endif\r\n#endif\r\n\r\n// TEXT\r\n#ifndef TEXT\r\n    #ifdef UNICODE\r\n        #define TEXT(sz)   WIDE(sz)\r\n    #else\r\n        #define TEXT(sz)   sz\r\n    #endif\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// C string\r\n\r\ntemplate <typename T_CHAR>\r\ninline size_t mstrlen(const T_CHAR *str);\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\nT_CHAR *mstrcpy(T_CHAR (&dest)[siz], const T_CHAR *src);\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\nT_CHAR *mstrcpyn(T_CHAR (&dest)[siz], const T_CHAR *src, size_t maxbuf);\r\n\r\ntemplate <typename T_CHAR>\r\nT_CHAR *mstrrchr(T_CHAR *str, T_CHAR ch);\r\ntemplate <typename T_CHAR>\r\nconst T_CHAR *mstrrchr(const T_CHAR *str, T_CHAR ch);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nenum MTextEncoding\r\n{\r\n    MTENC_UNKNOWN = 0,\r\n    MTENC_ASCII,\r\n    MTENC_ANSI,\r\n    MTENC_UNICODE_LE,\r\n    MTENC_UNICODE_BE,\r\n    MTENC_UTF8,\r\n    MTENC_UNICODE = MTENC_UNICODE_LE,\r\n};\r\n\r\nenum MTextNewLineType\r\n{\r\n    MNEWLINE_UNKNOWN,\r\n    MNEWLINE_NOCHANGE,\r\n    MNEWLINE_CRLF,\r\n    MNEWLINE_LF,\r\n    MNEWLINE_CR\r\n};\r\n\r\nstruct MTextType\r\n{\r\n    MTextEncoding       nEncoding;\r\n    MTextNewLineType    nNewLine;\r\n    bool                bHasBOM;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// string\r\n\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR> mchr_to_hex(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_digit(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_xdigit(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_upper(T_CHAR ch);\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_lower(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_alpha(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_alnum(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mchr_is_space(T_CHAR ch);\r\n\r\ntemplate <typename T_CHAR>\r\nint mstr_parse_int(const T_CHAR *str, bool is_signed = true, int base = 0);\r\n\r\ntemplate <typename T_CHAR>\r\nvoid mstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value);\r\ntemplate <typename T_CHAR>\r\nvoid mstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value);\r\n\r\ntemplate <typename T_CHAR>\r\nvoid mstr_to_dec(std::basic_string<T_CHAR>& str, int value, bool is_signed = true);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mstr_is_text_ascii(const T_CHAR *str, size_t len);\r\n\r\ntemplate <typename T_CHAR>\r\nbool mstr_is_text_ascii(const std::basic_string<T_CHAR>& str);\r\n\r\nbool mstr_is_text_utf8(const char *str, size_t len);\r\nbool mstr_is_text_utf8(const std::string& str);\r\n\r\nbool mstr_is_text_unicode(const void *ptr, size_t len);\r\n\r\ntemplate <typename T_CHAR>\r\nvoid mstr_trim(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);\r\ntemplate <typename T_CHAR, size_t siz>\r\nvoid mstr_trim(T_CHAR (&str)[siz], const T_CHAR *spaces);\r\n\r\ntemplate <typename T_CHAR>\r\nvoid mstr_trim_left(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);\r\ntemplate <typename T_CHAR, size_t siz>\r\nvoid mstr_trim_left(T_CHAR (&str)[siz], const T_CHAR *spaces);\r\n\r\ntemplate <typename T_CHAR>\r\nvoid mstr_trim_right(std::basic_string<T_CHAR>& str, const T_CHAR *spaces);\r\ntemplate <typename T_CHAR, size_t siz>\r\nvoid mstr_trim_right(T_CHAR (&str)[siz], const T_CHAR *spaces);\r\n\r\ntemplate <typename T_CHAR>\r\nT_CHAR *mstr_skip_space(T_CHAR *pch, const T_CHAR *spaces);\r\n\r\ntemplate <typename T_CHAR>\r\nconst T_CHAR *mstr_skip_space(const T_CHAR *pch, const T_CHAR *spaces);\r\n\r\ninline char *mstr_skip_space(char *pch)\r\n{\r\n    return mstr_skip_space(pch, " \\t\\n\\r\\f\\v");\r\n}\r\ninline const char *mstr_skip_space(const char *pch)\r\n{\r\n    return mstr_skip_space(pch, " \\t\\n\\r\\f\\v");\r\n}\r\ninline WCHAR *mstr_skip_space(WCHAR *pch)\r\n{\r\n    return mstr_skip_space(pch, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\ninline const WCHAR *mstr_skip_space(const WCHAR *pch)\r\n{\r\n    return mstr_skip_space(pch, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR>\r\nmstr_repeat(const std::basic_string<T_CHAR>& str, size_t count);\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR>\r\nmstr_repeat(const T_CHAR *str, size_t count);\r\n\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR>\r\nmstr_escape(const std::basic_string<T_CHAR>& str);\r\n\r\ntemplate <typename T_STR>\r\nbool mstr_replace_all(T_STR& str, const T_STR& from, const T_STR& to);\r\ntemplate <typename T_STR>\r\nbool mstr_replace_all(T_STR& str,\r\n                      const typename T_STR::value_type *from,\r\n                      const typename T_STR::value_type *to);\r\n\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR>\r\nmstr_quote(const std::basic_string<T_CHAR>& str);\r\n\r\ntemplate <typename T_CHAR>\r\nstd::basic_string<T_CHAR>\r\nmstr_quote(const T_CHAR *str);\r\n\r\ntemplate <typename T_STR_CONTAINER>\r\nvoid mstr_split(T_STR_CONTAINER& container,\r\n                const typename T_STR_CONTAINER::value_type& str,\r\n                const typename T_STR_CONTAINER::value_type& chars);\r\n\r\ntemplate <typename T_STR_CONTAINER>\r\ntypename T_STR_CONTAINER::value_type\r\nmstr_join(const T_STR_CONTAINER& container,\r\n          const typename T_STR_CONTAINER::value_type& sep);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// binary\r\n\r\nvoid mbin_swap_endian(void *ptr, size_t len);\r\nvoid mbin_swap_endian(std::string& bin);\r\n\r\nMStringW\r\nmstr_from_bin(const void *bin, size_t len, MTextType *pType = NULL);\r\nMStringW\r\nmstr_from_bin(const std::string& bin, MTextType *pType = NULL);\r\n\r\nstd::string mbin_from_str(const MStringW& str, const MTextType& type);\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MTextToText.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T_CHAR>\r\ninline size_t mstrlen(const T_CHAR *str)\r\n{\r\n    return std::char_traits<T_CHAR>::length(str);\r\n}\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\ninline T_CHAR *mstrcpy(T_CHAR (&dest)[siz], const T_CHAR *src)\r\n{\r\n    std::char_traits<T_CHAR>::copy(dest, src, mstrlen(src) + 1);\r\n    return dest;\r\n}\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\ninline T_CHAR *mstrcpyn(T_CHAR (&dest)[siz], const T_CHAR *src, size_t maxbuf)\r\n{\r\n    size_t len = mstrlen(src) + 1;\r\n    if (len >= maxbuf)\r\n        len = maxbuf;\r\n    std::char_traits<T_CHAR>::copy(dest, src, len);\r\n    if (maxbuf)\r\n        dest[maxbuf - 1] = 0;\r\n    return dest;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline T_CHAR *mstrrchr(T_CHAR *str, T_CHAR ch)\r\n{\r\n#if defined(_WIN32) && defined(_MBCS)\r\n    if (sizeof(T_CHAR) == 1)\r\n    {\r\n        return (T_CHAR *)(_mbsrchr((BYTE *)str, ch));\r\n    }\r\n#endif\r\n    T_CHAR *ptr = NULL;\r\n    while (*str)\r\n    {\r\n        if (*str == ch)\r\n            ptr = str;\r\n        ++str;\r\n    }\r\n    return ptr;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline const T_CHAR *mstrrchr(const T_CHAR *str, T_CHAR ch)\r\n{\r\n#if defined(_WIN32) && defined(_MBCS)\r\n    if (sizeof(T_CHAR) == 1)\r\n    {\r\n        return (const T_CHAR *)(_mbsrchr((const BYTE *)str, ch));\r\n    }\r\n#endif\r\n    const T_CHAR *ptr = NULL;\r\n    while (*str)\r\n    {\r\n        if (*str == ch)\r\n            ptr = str;\r\n        ++str;\r\n    }\r\n    return ptr;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmchr_to_hex(T_CHAR value)\r\n{\r\n    std::basic_string<T_CHAR> ret;\r\n    if (sizeof(T_CHAR) == 1)\r\n        mstr_to_hex(ret, (value & 0xFF));\r\n    else if (sizeof(T_CHAR) == 2)\r\n        mstr_to_hex(ret, (value & 0xFFFF));\r\n    else if (sizeof(T_CHAR) == 4)\r\n        mstr_to_hex(ret, (value & 0xFFFFFFFF));\r\n    return ret;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_digit(T_CHAR ch)\r\n{\r\n    return (T_CHAR('0') <= ch && ch <= T_CHAR('9'));\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_xdigit(T_CHAR ch)\r\n{\r\n    if (T_CHAR('0') <= ch && ch <= T_CHAR('9'))\r\n        return true;\r\n    if (T_CHAR('A') <= ch && ch <= T_CHAR('F'))\r\n        return true;\r\n    if (T_CHAR('a') <= ch && ch <= T_CHAR('f'))\r\n        return true;\r\n    return false;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_upper(T_CHAR ch)\r\n{\r\n    return (T_CHAR('A') <= ch && ch <= T_CHAR('Z'));\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_lower(T_CHAR ch)\r\n{\r\n    return (T_CHAR('a') <= ch && ch <= T_CHAR('z'));\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_alpha(T_CHAR ch)\r\n{\r\n    return mchr_is_upper(ch) || mchr_is_lower(ch);\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_alnum(T_CHAR ch)\r\n{\r\n    return mchr_is_alpha(ch) || mchr_is_digit(ch);\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mchr_is_space(T_CHAR ch)\r\n{\r\n    return (ch == T_CHAR(' ') || ch == T_CHAR('\\t') ||\r\n            ch == T_CHAR('\\n') || ch == T_CHAR('\\r') ||\r\n            ch == T_CHAR('\\f') || ch == T_CHAR('\\v'));\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline int mstr_parse_int(const T_CHAR *str, bool is_signed, int base)\r\n{\r\n    str = mstr_skip_space(str);\r\n\r\n    if (*str == T_CHAR('+'))\r\n        ++str;\r\n\r\n    bool minus = false;\r\n    if (is_signed && *str == T_CHAR('-'))\r\n    {\r\n        minus = true;\r\n        ++str;\r\n    }\r\n\r\n    if (str[0] == T_CHAR('0'))\r\n    {\r\n        if (str[1] == T_CHAR('x') || str[1] == T_CHAR('X'))\r\n        {\r\n            if (base == 0)\r\n            {\r\n                base = 16;\r\n            }\r\n            str += 2;\r\n        }\r\n        else\r\n        {\r\n            if (base == 0)\r\n            {\r\n                base = 8;\r\n            }\r\n            ++str;\r\n        }\r\n    }\r\n\r\n    if (base == 0)\r\n    {\r\n        base = 10;\r\n    }\r\n    assert(base == 10 || base == 8 || base == 16);\r\n\r\n    int num;\r\n    for (num = 0; *str; ++str)\r\n    {\r\n        if (base == 8)\r\n        {\r\n            if (T_CHAR('0') <= *str && *str <= T_CHAR('7'))\r\n            {\r\n                num *= base;\r\n                num += *str - T_CHAR('0');\r\n                continue;\r\n            }\r\n        }\r\n        else if (base == 16)\r\n        {\r\n            if (T_CHAR('0') <= *str && *str <= T_CHAR('9'))\r\n            {\r\n                num *= base;\r\n                num += *str - T_CHAR('0');\r\n                continue;\r\n            }\r\n            else if (T_CHAR('A') <= *str && *str <= T_CHAR('F'))\r\n            {\r\n                num *= base;\r\n                num += *str - T_CHAR('A') + 10;\r\n                continue;\r\n            }\r\n            else if (T_CHAR('a') <= *str && *str <= T_CHAR('f'))\r\n            {\r\n                num *= base;\r\n                num += *str - T_CHAR('a') + 10;\r\n                continue;\r\n            }\r\n        }\r\n        else if (base == 10)\r\n        {\r\n            if (T_CHAR('0') <= *str && *str <= T_CHAR('9'))\r\n            {\r\n                num *= base;\r\n                num += *str - T_CHAR('0');\r\n                continue;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n\r\n    return (minus ? -num : num);\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline void\r\nmstr_to_hex(std::basic_string<T_CHAR>& str, unsigned int value)\r\n{\r\n    static const char hex[] = "0123456789ABCDEF";\r\n    str.clear();\r\n    while (value)\r\n    {\r\n        str += T_CHAR(hex[value & 0xF]);\r\n        value >>= 4;\r\n    }\r\n    std::reverse(str.begin(), str.end());\r\n    if (str.empty())\r\n        str += T_CHAR('0');\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline void\r\nmstr_to_dec(std::basic_string<T_CHAR>& str, int value, bool is_signed)\r\n{\r\n    static const char dec[] = "0123456789";\r\n    str.clear();\r\n    bool is_minus = false;\r\n    if (is_signed && value < 0)\r\n    {\r\n        is_minus = true;\r\n        value = -value;\r\n    }\r\n    size_t i = 0;\r\n    unsigned int uvalue = value;\r\n    while (uvalue)\r\n    {\r\n        str += T_CHAR(dec[uvalue % 10]);\r\n        uvalue /= 10;\r\n        ++i;\r\n    }\r\n    if (is_minus)\r\n        str += T_CHAR('-');\r\n    std::reverse(str.begin(), str.end());\r\n    if (str.empty())\r\n        str += T_CHAR('0');\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mstr_is_text_ascii(const T_CHAR *str, size_t len)\r\n{\r\n    if (!len)\r\n        return true;\r\n\r\n    while (len-- > 0)\r\n    {\r\n        if (*str < 0 || *str > 0x7F)\r\n            return false;\r\n        ++str;\r\n    }\r\n    return true;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline bool mstr_is_text_ascii(const std::basic_string<T_CHAR>& str)\r\n{\r\n    return mstr_is_text_ascii(&str[0], str.size());\r\n}\r\n\r\ninline bool mstr_is_text_utf8(const std::string& str)\r\n{\r\n    return mstr_is_text_utf8(&str[0], str.size());\r\n}\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    inline bool mstr_is_text_unicode(const void *ptr, size_t len)\r\n    {\r\n        if (len == 0)\r\n            return true;\r\n\r\n        return !!::IsTextUnicode(ptr, int(len), NULL);\r\n    }\r\n#else\r\n    #include "UTF16_validator.h"\r\n    inline bool mstr_is_text_unicode(const void *ptr, size_t len)\r\n    {\r\n        if (len == 0)\r\n            return true;\r\n\r\n        return UTF16_validate(ptr, len);\r\n    }\r\n#endif\r\n\r\ntemplate <typename T_CHAR>\r\ninline void mstr_trim(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    size_t i = str.find_first_not_of(spaces);\r\n    size_t j = str.find_last_not_of(spaces);\r\n    if ((i == string_type::npos) || (j == string_type::npos))\r\n    {\r\n        str.clear();\r\n    }\r\n    else\r\n    {\r\n        str = str.substr(i, j - i + 1);\r\n    }\r\n}\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\ninline void mstr_trim(T_CHAR (&str)[siz], const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    string_type s = str;\r\n    mstr_trim(s, spaces);\r\n    mstrcpy(str, s.c_str());\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline void mstr_trim_left(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    size_t i = str.find_first_not_of(spaces);\r\n    if (i == string_type::npos)\r\n    {\r\n        str.clear();\r\n    }\r\n    else\r\n    {\r\n        str = str.substr(i);\r\n    }\r\n}\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\ninline void mstr_trim_left(T_CHAR (&str)[siz], const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    string_type s = str;\r\n    mstr_trim_left(s, spaces);\r\n    mstrcpy(str, s.c_str());\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline void mstr_trim_right(std::basic_string<T_CHAR>& str, const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    size_t j = str.find_last_not_of(spaces);\r\n    if (j == string_type::npos)\r\n    {\r\n        str.clear();\r\n    }\r\n    else\r\n    {\r\n        str = str.substr(0, j + 1);\r\n    }\r\n}\r\n\r\ntemplate <typename T_CHAR, size_t siz>\r\ninline void mstr_trim_right(T_CHAR (&str)[siz], const T_CHAR *spaces)\r\n{\r\n    typedef std::basic_string<T_CHAR> string_type;\r\n    string_type s = str;\r\n    mstr_trim_right(s, spaces);\r\n    mstrcpy(str, s.c_str());\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmstr_repeat(const std::basic_string<T_CHAR>& str, size_t count)\r\n{\r\n    std::basic_string<T_CHAR> ret;\r\n    while (count-- > 0)\r\n    {\r\n        ret += str;\r\n    }\r\n    return ret;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmstr_repeat(const T_CHAR *str, size_t count)\r\n{\r\n    return mstr_repeat(std::basic_string<T_CHAR>(str), count);\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmstr_escape(const std::basic_string<T_CHAR>& str)\r\n{\r\n    std::basic_string<T_CHAR> ret;\r\n\r\n    for (size_t i = 0; i < str.size(); ++i)\r\n    {\r\n        T_CHAR ch = str[i];\r\n        switch (ch)\r\n        {\r\n        case T_CHAR('\\"'): ret += T_CHAR('\\"'); ret += T_CHAR('\\"'); break;\r\n        case T_CHAR('\\\\'): ret += T_CHAR('\\\\'); ret += T_CHAR('\\\\'); break;\r\n        case T_CHAR('\\0'): ret += T_CHAR('\\\\'); ret += T_CHAR('0'); break;\r\n        case T_CHAR('\\a'): ret += T_CHAR('\\\\'); ret += T_CHAR('a'); break;\r\n        case T_CHAR('\\b'): ret += T_CHAR('\\\\'); ret += T_CHAR('b'); break;\r\n        case T_CHAR('\\f'): ret += T_CHAR('\\\\'); ret += T_CHAR('f'); break;\r\n        case T_CHAR('\\n'): ret += T_CHAR('\\\\'); ret += T_CHAR('n'); break;\r\n        case T_CHAR('\\r'): ret += T_CHAR('\\\\'); ret += T_CHAR('r'); break;\r\n        case T_CHAR('\\t'): ret += T_CHAR('\\\\'); ret += T_CHAR('t'); break;\r\n        case T_CHAR('\\v'): ret += T_CHAR('\\\\'); ret += T_CHAR('v'); break;\r\n        default:\r\n            if (ch < 0x20)\r\n            {\r\n                ret += T_CHAR('\\\\');\r\n                ret += T_CHAR('x');\r\n                ret += mchr_to_hex(ch);\r\n            }\r\n            else\r\n            {\r\n                ret += ch;\r\n            }\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ntemplate <typename T_STR>\r\ninline bool\r\nmstr_replace_all(T_STR& str, const T_STR& from, const T_STR& to)\r\n{\r\n    bool ret = false;\r\n    size_t i = 0;\r\n    for (;;) {\r\n        i = str.find(from, i);\r\n        if (i == T_STR::npos)\r\n            break;\r\n        ret = true;\r\n        str.replace(i, from.size(), to);\r\n        i += to.size();\r\n    }\r\n    return ret;\r\n}\r\ntemplate <typename T_STR>\r\ninline bool\r\nmstr_replace_all(T_STR& str,\r\n                 const typename T_STR::value_type *from,\r\n                 const typename T_STR::value_type *to)\r\n{\r\n    return mstr_replace_all(str, T_STR(from), T_STR(to));\r\n}\r\n\r\ninline void\r\nmbin_swap_endian(void *ptr, size_t len)\r\n{\r\n    char *pb = (char *)ptr;\r\n    len /= 2;\r\n    while (--len)\r\n    {\r\n        char b = pb[0];\r\n        pb[0] = pb[1];\r\n        pb[1] = b;\r\n        ++pb;\r\n        ++pb;\r\n    }\r\n}\r\n\r\ninline void mbin_swap_endian(std::string& bin)\r\n{\r\n    mbin_swap_endian(&bin[0], bin.size());\r\n}\r\n\r\ninline MStringW\r\nmstr_from_bin(const void *bin, size_t len, MTextType *pType/* = NULL*/)\r\n{\r\n    MStringW ret;\r\n\r\n    if (bin == NULL || len == 0)\r\n    {\r\n        // empty\r\n        if (pType)\r\n        {\r\n            pType->nNewLine = MNEWLINE_CRLF;\r\n            pType->nEncoding = MTENC_ASCII;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    if (len >= 2 && std::memcmp(bin, "\\xFF\\xFE", 2) == 0)\r\n    {\r\n        // UTF-16 LE\r\n        if (pType)\r\n        {\r\n            pType->nEncoding = MTENC_UNICODE_LE;\r\n            pType->bHasBOM = true;\r\n        }\r\n        ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));\r\n    }\r\n    else if (len >= 2 && std::memcmp(bin, "\\xFE\\xFF", 2) == 0)\r\n    {\r\n        // UTF-16 BE\r\n        if (pType)\r\n        {\r\n            pType->nEncoding = MTENC_UNICODE_BE;\r\n            pType->bHasBOM = true;\r\n        }\r\n        ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));\r\n        mbin_swap_endian(&ret[0], len);\r\n    }\r\n    else\r\n    {\r\n        const char *pch = (const char *)bin;\r\n        if (len >= 3 && std::memcmp(bin, "\\xEF\\xBB\\xBF", 3) == 0)\r\n        {\r\n            // UTF-8\r\n            if (pType)\r\n            {\r\n                pType->nEncoding = MTENC_UTF8;\r\n                pType->bHasBOM = true;\r\n            }\r\n            std::string str(&pch[3], len - 3);\r\n            ret = MAnsiToWide(CP_UTF8, str);\r\n        }\r\n        else if (mstr_is_text_ascii((const char *)bin, len))\r\n        {\r\n            // ASCII\r\n            if (pType)\r\n            {\r\n                pType->nEncoding = MTENC_ASCII;\r\n                pType->bHasBOM = false;\r\n            }\r\n            std::string str(pch, len);\r\n            ret = MAnsiToWide(CP_ACP, str);\r\n        }\r\n        else if (mstr_is_text_utf8((const char *)bin, len))\r\n        {\r\n            // UTF-8\r\n            if (pType)\r\n            {\r\n                pType->nEncoding = MTENC_UTF8;\r\n                pType->bHasBOM = false;\r\n            }\r\n            ret = MAnsiToWide(CP_UTF8, pch, int(len));\r\n        }\r\n        else if (mstr_is_text_unicode(bin, int(len)))\r\n        {\r\n            // UTF-16 LE\r\n            if (pType)\r\n            {\r\n                pType->nEncoding = MTENC_UNICODE_LE;\r\n                pType->bHasBOM = false;\r\n            }\r\n            ret.assign((const WCHAR *)bin, len / sizeof(WCHAR));\r\n        }\r\n        else\r\n        {\r\n            // ANSI\r\n            if (pType)\r\n            {\r\n                pType->nEncoding = MTENC_ANSI;\r\n                pType->bHasBOM = false;\r\n            }\r\n            std::string str(pch, len);\r\n            ret = MAnsiToWide(CP_ACP, str);\r\n        }\r\n    }\r\n\r\n    if (!pType || pType->nNewLine != MNEWLINE_NOCHANGE)\r\n    {\r\n        if (pType)\r\n        {\r\n            pType->nNewLine = MNEWLINE_UNKNOWN;\r\n        }\r\n        if (mstr_replace_all(ret, WIDE("\\r\\n"), WIDE("\\n")))\r\n        {\r\n            if (pType)\r\n            {\r\n                pType->nNewLine = MNEWLINE_CRLF;\r\n            }\r\n        }\r\n        if (mstr_replace_all(ret, WIDE("\\r"), WIDE("\\n")))\r\n        {\r\n            if (pType && pType->nNewLine != MNEWLINE_CRLF)\r\n            {\r\n                pType->nNewLine = MNEWLINE_CR;\r\n            }\r\n        }\r\n        if (mstr_replace_all(ret, WIDE("\\n"), WIDE("\\r\\n")))\r\n        {\r\n            if (pType && pType->nNewLine != MNEWLINE_CRLF)\r\n            {\r\n                pType->nNewLine = MNEWLINE_LF;\r\n            }\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline MStringW\r\nmstr_from_bin(const std::string& bin, MTextType *pType/* = NULL*/)\r\n{\r\n    return mstr_from_bin(&bin[0], bin.size(), pType);\r\n}\r\n\r\ninline std::string\r\nmbin_from_str(const MStringW& str, const MTextType& type)\r\n{\r\n    std::string ret;\r\n    MStringW str2 = str;\r\n\r\n    switch (type.nNewLine)\r\n    {\r\n    case MNEWLINE_UNKNOWN:\r\n    case MNEWLINE_NOCHANGE:\r\n        break;\r\n    case MNEWLINE_CRLF:\r\n        mstr_replace_all(str2, WIDE("\\r\\n"), WIDE("\\n"));\r\n        mstr_replace_all(str2, WIDE("\\r"), WIDE("\\r\\n"));\r\n        mstr_replace_all(str2, WIDE("\\n"), WIDE("\\r\\n"));\r\n        break;\r\n    case MNEWLINE_LF:\r\n        mstr_replace_all(str2, WIDE("\\r\\n"), WIDE("\\n"));\r\n        mstr_replace_all(str2, WIDE("\\r"), WIDE("\\n"));\r\n        break;\r\n    case MNEWLINE_CR:\r\n        mstr_replace_all(str2, WIDE("\\r\\n"), WIDE("\\r"));\r\n        mstr_replace_all(str2, WIDE("\\n"), WIDE("\\r"));\r\n        break;\r\n    }\r\n\r\n    switch (type.nEncoding)\r\n    {\r\n    case MTENC_UNKNOWN:\r\n    case MTENC_ASCII:\r\n    case MTENC_ANSI:\r\n    default:\r\n        ret += MWideToAnsi(CP_ACP, str2);\r\n        break;\r\n    case MTENC_UNICODE_LE:\r\n        if (type.bHasBOM)\r\n        {\r\n            ret += "\\xFF\\xFE";\r\n        }\r\n        ret.append((const char *)str2.c_str(), str2.size() * sizeof(WCHAR));\r\n        break;\r\n    case MTENC_UNICODE_BE:\r\n        if (type.bHasBOM)\r\n        {\r\n            ret += "\\xFF\\xFE";\r\n        }\r\n        ret.append((const char *)str2.c_str(), str2.size() * sizeof(WCHAR));\r\n        mbin_swap_endian(ret);\r\n        break;\r\n    case MTENC_UTF8:\r\n        if (type.bHasBOM)\r\n        {\r\n            ret += "\\xEF\\xBB\\xBF";\r\n        }\r\n        ret += MWideToAnsi(CP_UTF8, str2);\r\n        break;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmstr_quote(const std::basic_string<T_CHAR>& str)\r\n{\r\n    std::basic_string<T_CHAR> ret;\r\n    ret += T_CHAR('\\"');\r\n    ret += mstr_escape(str);\r\n    ret += T_CHAR('\\"');\r\n    return ret;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline std::basic_string<T_CHAR>\r\nmstr_quote(const T_CHAR *str)\r\n{\r\n    std::basic_string<T_CHAR> ret = str;\r\n    return mstr_quote(ret);\r\n}\r\n\r\ntemplate <typename T_STR_CONTAINER>\r\ninline void\r\nmstr_split(T_STR_CONTAINER& container,\r\n           const typename T_STR_CONTAINER::value_type& str,\r\n           const typename T_STR_CONTAINER::value_type& chars)\r\n{\r\n    container.clear();\r\n    size_t i = 0, k = str.find_first_of(chars);\r\n    while (k != T_STR_CONTAINER::value_type::npos)\r\n    {\r\n        container.push_back(str.substr(i, k - i));\r\n        i = k + 1;\r\n        k = str.find_first_of(chars, i);\r\n    }\r\n    container.push_back(str.substr(i));\r\n}\r\n\r\ntemplate <typename T_STR_CONTAINER>\r\ninline typename T_STR_CONTAINER::value_type\r\nmstr_join(const T_STR_CONTAINER& container,\r\n          const typename T_STR_CONTAINER::value_type& sep)\r\n{\r\n    typename T_STR_CONTAINER::value_type result;\r\n    typename T_STR_CONTAINER::const_iterator it, end;\r\n    it = container.begin();\r\n    end = container.end();\r\n    if (it != end)\r\n    {\r\n        result = *it;\r\n        for (++it; it != end; ++it)\r\n        {\r\n            result += sep;\r\n            result += *it;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline T_CHAR *\r\nmstr_skip_space(T_CHAR *pch, const T_CHAR *spaces)\r\n{\r\n    const T_CHAR *ptr;\r\n    while (*pch)\r\n    {\r\n        for (ptr = spaces; *ptr; ++ptr)\r\n        {\r\n            if (*ptr == *pch)\r\n            {\r\n                ptr = NULL;\r\n                break;\r\n            }\r\n        }\r\n        if (ptr)\r\n            return pch;\r\n\r\n        ++pch;\r\n    }\r\n    return pch;\r\n}\r\n\r\ntemplate <typename T_CHAR>\r\ninline const T_CHAR *\r\nmstr_skip_space(const T_CHAR *pch, const T_CHAR *spaces)\r\n{\r\n    const T_CHAR *ptr;\r\n    while (*pch)\r\n    {\r\n        for (ptr = spaces; *ptr; ++ptr)\r\n        {\r\n            if (*ptr == *pch)\r\n            {\r\n                ptr = NULL;\r\n                break;\r\n            }\r\n        }\r\n        if (ptr)\r\n            return pch;\r\n\r\n        ++pch;\r\n    }\r\n    return pch;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline void mstr_trim(MStringA& str)\r\n{\r\n    mstr_trim(str, " \\t\\n\\r\\f\\v");\r\n}\r\ninline void mstr_trim(MStringW& str)\r\n{\r\n    mstr_trim(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim(char (&str)[siz])\r\n{\r\n    mstr_trim(str, " \\t\\n\\r\\f\\v");\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim(WCHAR (&str)[siz])\r\n{\r\n    mstr_trim(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\n\r\ninline void mstr_trim_left(MStringA& str)\r\n{\r\n    mstr_trim_left(str, " \\t\\n\\r\\f\\v");\r\n}\r\ninline void mstr_trim_left(MStringW& str)\r\n{\r\n    mstr_trim_left(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim_left(char (&str)[siz])\r\n{\r\n    mstr_trim_left(str, " \\t\\n\\r\\f\\v");\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim_left(WCHAR (&str)[siz])\r\n{\r\n    mstr_trim_left(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\n\r\ninline void mstr_trim_right(MStringA& str)\r\n{\r\n    mstr_trim_right(str, " \\t\\n\\r\\f\\v");\r\n}\r\ninline void mstr_trim_right(MStringW& str)\r\n{\r\n    mstr_trim_right(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim_right(char (&str)[siz])\r\n{\r\n    mstr_trim_right(str, " \\t\\n\\r\\f\\v");\r\n}\r\ntemplate <size_t siz>\r\ninline void mstr_trim_right(WCHAR (&str)[siz])\r\n{\r\n    mstr_trim_right(str, WIDE(" \\t\\n\\r\\f\\v"));\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// UTF-8 checking\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    inline bool mstr_is_text_utf8(const char *str, size_t len)\r\n    {\r\n        if (len == 0)\r\n            return true;\r\n\r\n        len = ::MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, str, int(len), NULL, 0);\r\n        return len != 0;\r\n    }\r\n#else\r\n    #include "UTF8_validator.h"\r\n    inline bool mstr_is_text_utf8(const char *str, size_t len)\r\n    {\r\n        if (len == 0)\r\n            return true;\r\n\r\n        return UTF8_validate(str, len);\r\n    }\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSTRING_HPP_\r\n
MSync.hpp<>MSync.hpp<>// MSync.hpp -- Win32API synchronization                      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSYNC_HPP_\r\n#define MZC4_MSYNC_HPP_     2   /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MCriticalSection.hpp"\r\n#include "MEvent.hpp"\r\n#include "MMutex.hpp"\r\n#include "MSemaphore.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSYNC_HPP_\r\n
MSyncBase.hpp<>MSyncBase.hpp<>// MSyncBase.hpp -- Win32API synchronization object wrapper   -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MSYNCBASE_HPP_\r\n#define MZC4_MSYNCBASE_HPP_       3   /* Version 3 */\r\n\r\nclass MSyncBase;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MSyncBase\r\n{\r\nprotected:\r\n    HANDLE m_hObject;\r\n    MSyncBase();\r\n    MSyncBase(HANDLE hObject);\r\n    MSyncBase(const MSyncBase& base);\r\n    MSyncBase& operator=(const MSyncBase& base);\r\n\r\npublic:\r\n    virtual ~MSyncBase();\r\n    bool operator!() const;\r\n    operator HANDLE() const;\r\n    MSyncBase& operator=(HANDLE hObject);\r\n    bool operator==(HANDLE hObject) const;\r\n    bool operator!=(HANDLE hObject) const;\r\n\r\n    BOOL Attach(HANDLE hObject);\r\n    HANDLE Detach();\r\n    HANDLE Handle() const;\r\n\r\n    virtual BOOL Lock(DWORD dwTimeout = INFINITE);\r\n    virtual BOOL Unlock() = 0;\r\n\r\n    BOOL CloseHandle();\r\n\r\n    static HANDLE CloneHandleDx(HANDLE hObject);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ HANDLE MSyncBase::CloneHandleDx(HANDLE hObject)\r\n{\r\n    if (hObject == NULL)\r\n        return NULL;\r\n\r\n    HANDLE hDup = NULL;\r\n    HANDLE hProcess = ::GetCurrentProcess();\r\n    ::DuplicateHandle(hProcess, hObject, hProcess, &hDup, 0,\r\n                      FALSE, DUPLICATE_SAME_ACCESS);\r\n    return hDup;\r\n}\r\n\r\ninline MSyncBase::MSyncBase() : m_hObject(NULL)\r\n{\r\n}\r\n\r\ninline MSyncBase::MSyncBase(HANDLE hObject) : m_hObject(hObject)\r\n{\r\n}\r\n\r\ninline MSyncBase::MSyncBase(const MSyncBase& base)\r\n    : m_hObject(CloneHandleDx(base))\r\n{\r\n}\r\n\r\ninline MSyncBase& MSyncBase::operator=(const MSyncBase& base)\r\n{\r\n    if (Handle() != base.Handle())\r\n    {\r\n        HANDLE hObject = CloneHandleDx(base);\r\n        Attach(hObject);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline /*virtual*/ MSyncBase::~MSyncBase()\r\n{\r\n    CloseHandle();\r\n}\r\n\r\ninline HANDLE MSyncBase::Handle() const\r\n{\r\n    return (this ? m_hObject : NULL);\r\n}\r\n\r\ninline MSyncBase::operator HANDLE() const\r\n{\r\n    return Handle();\r\n}\r\n\r\ninline bool MSyncBase::operator!() const\r\n{\r\n    return Handle() == NULL;\r\n}\r\n\r\ninline bool MSyncBase::operator==(HANDLE hObject) const\r\n{\r\n    return Handle() == hObject;\r\n}\r\n\r\ninline bool MSyncBase::operator!=(HANDLE hObject) const\r\n{\r\n    return Handle() != hObject;\r\n}\r\n\r\ninline MSyncBase& MSyncBase::operator=(HANDLE hObject)\r\n{\r\n    if (Handle() != hObject)\r\n    {\r\n        Attach(hObject);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline BOOL MSyncBase::Attach(HANDLE hObject)\r\n{\r\n    CloseHandle();\r\n    m_hObject = hObject;\r\n    return m_hObject != NULL;\r\n}\r\n\r\ninline HANDLE MSyncBase::Detach()\r\n{\r\n    HANDLE hObject = m_hObject;\r\n    m_hObject = NULL;\r\n    return hObject;\r\n}\r\n\r\ninline /*virtual*/ BOOL MSyncBase::Lock(DWORD dwTimeout/* = INFINITE*/)\r\n{\r\n    assert(Handle());\r\n    return ::WaitForSingleObject(Handle(), dwTimeout) == WAIT_OBJECT_0;\r\n}\r\n\r\ninline BOOL MSyncBase::CloseHandle()\r\n{\r\n    if (Handle())\r\n    {\r\n        BOOL bOK = ::CloseHandle(Detach());\r\n        return bOK;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MSYNCBASE_HPP_\r\n
MTabCtrl.hpp<>MTabCtrl.hpp<>// MTabCtrl.hpp -- Win32API tab control wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTABCTRL_HPP_\r\n#define MZC4_MTABCTRL_HPP_      2   /* Version 2 */\r\n\r\nclass MTabCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n#include "MPointSizeRect.hpp"\r\n\r\nclass MTabCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MTabCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    HIMAGELIST GetImageList() const;\r\n    HIMAGELIST SetImageList(HIMAGELIST hImageList);\r\n    INT GetItemCount() const;\r\n\r\n    BOOL GetItem(INT iItem, TCITEM* pTabCtrlItem) const;\r\n    BOOL SetItem(INT iItem, TCITEM* pTabCtrlItem);\r\n\r\n    BOOL SetItemExtra(INT nBytes);\r\n    BOOL GetItemRect(INT iItem, LPRECT prc) const;\r\n\r\n    INT GetCurSel() const;\r\n    INT SetCurSel(INT iItem);\r\n\r\n    MSize SetItemSize(MSize size);\r\n    VOID SetPadding(MSize size);\r\n    INT GetRowCount() const;\r\n\r\n    HWND GetToolTips() const;\r\n    VOID SetToolTips(HWND hwndToolTips);\r\n\r\n    INT GetCurFocus() const;\r\n    VOID SetCurFocus(INT iItem);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        INT SetMinTabWidth(INT cx);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        DWORD GetExtendedStyle();\r\n        DWORD SetExtendedStyle(DWORD dwNewStyle, DWORD dwExMask = 0);\r\n        BOOL HighlightItem(INT nIndex, BOOL fHighlight = TRUE);\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    BOOL InsertItem(INT iItem, TCITEM* pTabCtrlItem);\r\n    BOOL InsertItem(INT iItem, LPCTSTR lpszItem);\r\n    BOOL InsertItem(INT iItem, LPCTSTR lpszItem, INT iImage);\r\n    BOOL InsertItem(UINT nMask, INT iItem, LPCTSTR lpszItem, INT iImage,\r\n        LPARAM lParam);\r\n    BOOL DeleteItem(INT iItem);\r\n    BOOL DeleteAllItems();\r\n    VOID AdjustRect(BOOL bLarger, LPRECT prc);\r\n    VOID RemoveImage(INT iImage);\r\n    INT HitTest(TCHITTESTINFO* pHitTestInfo) const;\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        VOID DeselectAll(BOOL fExcludeFocus);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MTabCtrl::MTabCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MTabCtrl::GetWndClassNameDx() const\r\n{\r\n    return WC_TABCONTROL;\r\n}\r\n\r\ninline HIMAGELIST MTabCtrl::GetImageList() const\r\n{\r\n    return (HIMAGELIST)SendMessageDx(TCM_GETIMAGELIST);\r\n}\r\n\r\ninline HIMAGELIST MTabCtrl::SetImageList(HIMAGELIST hImageList)\r\n{\r\n    return (HIMAGELIST)SendMessageDx(TCM_SETIMAGELIST, 0, (LPARAM)hImageList);\r\n}\r\n\r\ninline INT MTabCtrl::GetItemCount() const\r\n{\r\n    return (INT)SendMessageDx(TCM_GETITEMCOUNT);\r\n}\r\n\r\ninline BOOL MTabCtrl::GetItem(INT iItem, TCITEM* pTabCtrlItem) const\r\n{\r\n    return (BOOL)SendMessageDx(TCM_GETITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);\r\n}\r\n\r\ninline BOOL MTabCtrl::SetItem(INT iItem, TCITEM* pTabCtrlItem)\r\n{\r\n    return (BOOL)SendMessageDx(TCM_SETITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);\r\n}\r\n\r\ninline BOOL MTabCtrl::SetItemExtra(INT nBytes)\r\n{\r\n    assert(GetItemCount() == 0);\r\n    return (BOOL)SendMessageDx(TCM_SETITEMEXTRA, (WPARAM)nBytes);\r\n}\r\n\r\ninline BOOL MTabCtrl::GetItemRect(INT iItem, LPRECT prc) const\r\n{\r\n    return (BOOL)SendMessageDx(TCM_GETITEMRECT, (WPARAM)iItem, (LPARAM)prc);\r\n}\r\n\r\ninline INT MTabCtrl::GetCurSel() const\r\n{\r\n    return (INT)SendMessageDx(TCM_GETCURSEL);\r\n}\r\n\r\ninline INT MTabCtrl::SetCurSel(INT iItem)\r\n{\r\n    return (INT)SendMessageDx(TCM_SETCURSEL, (WPARAM)iItem);\r\n}\r\n\r\ninline MSize MTabCtrl::SetItemSize(MSize size)\r\n{\r\n    DWORD dwSize = (DWORD)SendMessageDx(TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));\r\n    return MSize(GET_X_LPARAM(dwSize), GET_Y_LPARAM(dwSize));\r\n}\r\n\r\ninline VOID MTabCtrl::SetPadding(MSize size)\r\n{\r\n    SendMessageDx(TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));\r\n}\r\n\r\ninline INT MTabCtrl::GetRowCount() const\r\n{\r\n    return (INT)SendMessageDx(TCM_GETROWCOUNT);\r\n}\r\n\r\ninline HWND MTabCtrl::GetToolTips() const\r\n{\r\n    return (HWND)SendMessageDx(TCM_GETTOOLTIPS);\r\n}\r\n\r\ninline VOID MTabCtrl::SetToolTips(HWND hwndToolTips)\r\n{\r\n    SendMessageDx(TCM_SETTOOLTIPS, (WPARAM)hwndToolTips);\r\n}\r\n\r\ninline INT MTabCtrl::GetCurFocus() const\r\n{\r\n    return (INT)SendMessageDx(TCM_GETCURFOCUS);\r\n}\r\n\r\ninline VOID MTabCtrl::SetCurFocus(INT iItem)\r\n{\r\n    SendMessageDx(TCM_SETCURFOCUS, (WPARAM)iItem);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline INT MTabCtrl::SetMinTabWidth(INT cx)\r\n    {\r\n        return (INT)SendMessageDx(TCM_SETMINTABWIDTH, 0, cx);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline DWORD MTabCtrl::GetExtendedStyle()\r\n    {\r\n        return (DWORD)SendMessageDx(TCM_GETEXTENDEDSTYLE);\r\n    }\r\n\r\n    inline DWORD MTabCtrl::SetExtendedStyle(\r\n        DWORD dwNewStyle, DWORD dwExMask/* = 0*/)\r\n    {\r\n        return (DWORD)SendMessageDx(TCM_SETEXTENDEDSTYLE, (WPARAM)dwExMask, (LPARAM)dwNewStyle);\r\n    }\r\n\r\n    inline BOOL MTabCtrl::HighlightItem(\r\n        INT nIndex, BOOL fHighlight/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(TCM_HIGHLIGHTITEM, (WPARAM)nIndex, MAKELPARAM(fHighlight, 0));\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\ninline BOOL MTabCtrl::InsertItem(INT iItem, TCITEM* pTabCtrlItem)\r\n{\r\n    return (INT)SendMessageDx(TCM_INSERTITEM, (WPARAM)iItem, (LPARAM)pTabCtrlItem);\r\n}\r\n\r\ninline BOOL MTabCtrl::InsertItem(INT iItem, LPCTSTR lpszItem)\r\n{\r\n    return InsertItem(TCIF_TEXT, iItem, lpszItem, 0, 0);\r\n}\r\n\r\ninline BOOL MTabCtrl::InsertItem(INT iItem, LPCTSTR lpszItem, INT iImage)\r\n{\r\n    return InsertItem(TCIF_TEXT | TCIF_IMAGE, iItem, lpszItem, iImage, 0);\r\n}\r\n\r\ninline BOOL MTabCtrl::InsertItem(UINT nMask, INT iItem,\r\n    LPCTSTR lpszItem, INT iImage, LPARAM lParam)\r\n{\r\n    TCITEM tci;\r\n    ZeroMemory(&tci, sizeof(tci));\r\n    tci.mask = nMask;\r\n    tci.pszText = (LPTSTR) lpszItem;\r\n    tci.iImage = iImage;\r\n    tci.lParam = lParam;\r\n    return (INT)SendMessageDx(TCM_INSERTITEM, (WPARAM)iItem, (LPARAM)&tci);\r\n}\r\n\r\ninline BOOL MTabCtrl::DeleteItem(INT iItem)\r\n{\r\n    return (BOOL)SendMessageDx(TCM_DELETEITEM, (WPARAM)iItem);\r\n}\r\n\r\ninline BOOL MTabCtrl::DeleteAllItems()\r\n{\r\n    return (BOOL)SendMessageDx(TCM_DELETEALLITEMS);\r\n}\r\n\r\ninline VOID MTabCtrl::AdjustRect(BOOL bLarger, LPRECT prc)\r\n{\r\n    SendMessageDx(TCM_ADJUSTRECT, (WPARAM)bLarger, (LPARAM)prc);\r\n}\r\n\r\ninline VOID MTabCtrl::RemoveImage(INT iImage)\r\n{\r\n    SendMessageDx(TCM_REMOVEIMAGE, (WPARAM)iImage);\r\n}\r\n\r\ninline INT MTabCtrl::HitTest(TCHITTESTINFO* pHitTestInfo) const\r\n{\r\n    return (INT)SendMessageDx(TCM_HITTEST, 0, (LPARAM)pHitTestInfo);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline VOID MTabCtrl::DeselectAll(BOOL fExcludeFocus)\r\n    {\r\n        SendMessageDx(TCM_DESELECTALL, (WPARAM)fExcludeFocus);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTABCTRL_HPP_\r\n
MTester.h<>MTester.h<>/* MTester.h --- MZC4 tester                                    -*- C++ -*- */\r\n/* This file is part of MZC4.  See file "ReadMe.txt" and "License.txt". */\r\n/****************************************************************************/\r\n\r\n#ifndef MZC4_MTESTER_H_\r\n#define MZC4_MTESTER_H_     9   /* Version 9 */\r\n\r\n/****************************************************************************/\r\n\r\n#ifdef __cplusplus\r\n    #include <cstdio>\r\n    #include <cstring>\r\n    #include <cstdarg>\r\n#else\r\n    #include <stdio.h>\r\n    #include <string.h>\r\n    #include <stdarg.h>\r\n#endif\r\n\r\n/****************************************************************************/\r\n\r\n#ifndef USING_NAMESPACE_STD\r\n    #ifdef __cplusplus\r\n        #define USING_NAMESPACE_STD     using namespace std\r\n    #else\r\n        #define USING_NAMESPACE_STD     /* empty */\r\n    #endif\r\n#endif\r\n\r\n/* Some C compilers don't support inline keyword. Use __inline instread if so. */\r\n#ifndef MZC_INLINE\r\n    #ifdef __cplusplus\r\n        #define MZC_INLINE inline\r\n    #elif (__STDC_VERSION__ >= 199901L)\r\n        #define MZC_INLINE inline\r\n    #else\r\n        #define MZC_INLINE __inline\r\n    #endif\r\n#endif\r\n\r\n/* C99 and C++11 */\r\n#if __STDC_VERSION__ >= 199901L && !defined(C99)\r\n    #define C99             1\r\n#endif\r\n#if __cplusplus >= 201103L && !defined(CXX11)\r\n    #define CXX11           1\r\n#endif\r\n\r\n#ifndef _countof\r\n    #define _countof(array)     (sizeof(array) / sizeof(array[0]))\r\n#endif\r\n\r\n#ifndef MTESTER_MAX_BUFFER_COUNT\r\n    #define MTESTER_MAX_BUFFER_COUNT    16\r\n#endif\r\n\r\n#ifndef MTESTER_MAX_BUFFER_SIZE\r\n    #define MTESTER_MAX_BUFFER_SIZE     512\r\n#endif\r\n\r\n/****************************************************************************/\r\n/* types */\r\n\r\ntypedef void (*MTEST_FUNC)(void);\r\n\r\ntypedef struct MTESTCASE\r\n{\r\n    const char *    name;\r\n    MTEST_FUNC      func;\r\n} MTESTCASE;\r\n\r\ntypedef struct MTEST_BUFFER\r\n{\r\n    int index;\r\n    char buffer[MTESTER_MAX_BUFFER_COUNT][MTESTER_MAX_BUFFER_SIZE];\r\n} MTEST_BUFFER;\r\n\r\n/****************************************************************************/\r\n/* global variables */\r\n\r\nextern int              g_executed;\r\nextern int              g_failures;\r\nextern int              g_skipped;\r\nextern MTEST_BUFFER     g_test_buffer;\r\nextern const int        g_testcase_count;\r\nextern MTESTCASE        g_testcases[];\r\n\r\n/****************************************************************************/\r\n/* mtester functions */\r\n\r\nstatic MZC_INLINE int MTester_finish(const char *name)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    printf("\\n%s: %d tests executed (%d failures), %d skipped.\\n",\r\n           name, g_executed, g_failures, g_skipped);\r\n    return g_failures > 0;\r\n}\r\n\r\nstatic MZC_INLINE int MTester_execute(MTESTCASE *testcase)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    g_executed = g_failures = g_skipped = 0;\r\n    memset(&g_test_buffer, 0, sizeof(g_test_buffer));\r\n    (*testcase->func)();\r\n    return MTester_finish(testcase->name);\r\n}\r\n\r\nstatic MZC_INLINE int MTester_list(void)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    int i;\r\n    for (i = 0; i < g_testcase_count; ++i)\r\n    {\r\n        if (g_testcases[i].name == NULL)\r\n            break;\r\n\r\n        printf("\\t%s\\n", g_testcases[i].name);\r\n    }\r\n    return 1;\r\n}\r\n\r\nstatic MZC_INLINE MTESTCASE *MTester_find(const char *name)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    int i;\r\n    for (i = 0; i < g_testcase_count; ++i)\r\n    {\r\n        if (g_testcases[i].name == NULL)\r\n            break;\r\n        if (strcmp(g_testcases[i].name, name) == 0)\r\n            return &g_testcases[i];\r\n    }\r\n    return NULL;\r\n}\r\n\r\nstatic MZC_INLINE int MTester_main(int argc, char **argv)\r\n{\r\n    int i, ret = 0;\r\n    MTESTCASE *testcase;\r\n\r\n    if (argc <= 1)\r\n    {\r\n        if (g_testcase_count == 1)\r\n        {\r\n            return MTester_execute(&g_testcases[0]);\r\n        }\r\n        for (i = 0; i < g_testcase_count; ++i)\r\n        {\r\n            ret += MTester_execute(&g_testcases[i]);\r\n        }\r\n        return ret;\r\n    }\r\n    else if (strcmp(argv[1], "all") == 0)\r\n    {\r\n        for (i = 0; i < g_testcase_count; ++i)\r\n        {\r\n            ret += MTester_execute(&g_testcases[i]);\r\n        }\r\n        return ret;\r\n    }\r\n    else\r\n    {\r\n        for (i = 1; i < argc; ++i)\r\n        {\r\n            testcase = MTester_find(argv[i]);\r\n            if (testcase == NULL)\r\n            {\r\n                return MTester_list();\r\n            }\r\n        }\r\n        for (i = 1; i < argc; ++i)\r\n        {\r\n            testcase = MTester_find(argv[i]);\r\n            if (testcase)\r\n            {\r\n                ret += MTester_execute(testcase);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\nstatic MZC_INLINE void MTester_do_skip(const char *file, int line, const char *fmt, ...)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    va_list va;\r\n    va_start(va, fmt);\r\n    printf("%s:%d: Tests skipped: ", file, line);\r\n    vprintf(fmt, va);\r\n    va_end(va);\r\n    g_skipped++;\r\n}\r\n\r\nstatic MZC_INLINE void\r\nMTester_head(const char *file, int line)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    printf("%s:%d: Test failed: ", file, line);\r\n}\r\n\r\nstatic MZC_INLINE int\r\nMTester_body_v(int cond, const char *fmt, va_list va)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    if (!cond)\r\n    {\r\n        vprintf(fmt, va);\r\n        g_failures++;\r\n    }\r\n    return cond;\r\n}\r\n\r\nstatic MZC_INLINE int\r\nMTester_body(int cond, const char *fmt, ...)\r\n{\r\n    va_list va;\r\n    va_start(va, fmt);\r\n    MTester_body_v(cond, fmt, va);\r\n    va_end(va);\r\n    return cond;\r\n}\r\n\r\nstatic MZC_INLINE void\r\nMTester_do_test(const char *file, int line, int cond, const char *fmt, ...)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    if (!cond)\r\n    {\r\n        va_list va;\r\n        va_start(va, fmt);\r\n        MTester_head(file, line);\r\n        MTester_body_v(cond, fmt, va);\r\n        va_end(va);\r\n    }\r\n    g_executed++;\r\n}\r\n\r\nstatic MZC_INLINE char *MTester_sprintf(const char *fmt, ...)\r\n{\r\n    USING_NAMESPACE_STD;\r\n    char *buffer = g_test_buffer.buffer[g_test_buffer.index];\r\n    va_list va;\r\n    va_start(va, fmt);\r\n    vsnprintf(buffer, MTESTER_MAX_BUFFER_SIZE, fmt, va);\r\n    g_test_buffer.index = (g_test_buffer.index + 1) % MTESTER_MAX_BUFFER_COUNT;\r\n    va_end(va);\r\n    return buffer;\r\n}\r\n\r\n/****************************************************************************/\r\n/* macros */\r\n\r\n#define START_TEST(name) void func_##name(void)\r\n#define DECLARE_TEST(name)  void func_##name(void)\r\n\r\n#define BEGIN_TESTS() \\\r\n    int g_executed, g_failures, g_skipped; \\\r\n    MTEST_BUFFER g_test_buffer; \\\r\n    MTESTCASE g_testcases[] = \\\r\n    {\r\n#define DEFINE_TEST(name) \\\r\n        { #name, func_##name },\r\n#define END_TESTS() \\\r\n    }; \\\r\n    const int g_testcase_count = (int)_countof(g_testcases); \\\r\n    int main(int argc, char **argv) { \\\r\n        return MTester_main(argc, argv); \\\r\n    }\r\n\r\n#if C99 || CXX11\r\n    #define mtest(cond, ...) \\\r\n        MTester_do_test(__FILE__, __LINE__, (cond), __VA_ARGS__)\r\n#else\r\n    #define mtest \\\r\n        MTester_head(__FILE__, __LINE__), MTester_body\r\n#endif\r\n\r\n#define mtest_int_eq(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, (expr) == (value), \\\r\n                    "%s expected %d (0x%X), got %d (0x%X).\\n", \\\r\n                    #expr, (value), (value), (expr), (expr))\r\n#define mtest_int_ne(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, (expr) != (value), \\\r\n                    "%s expected not %d (0x%X).\\n", #expr, (value), (value))\r\n\r\n#define mtest_ptr_eq(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, (expr) == (value), \\\r\n                    "%s expected %p, got %p.\\n", #expr, \\\r\n                    (const void *)(value), (const void *)(expr))\r\n#define mtest_ptr_ne(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, (expr) != (value), \\\r\n                    "%s expected not %p.\\n", #expr, (const void *)(value))\r\n\r\n#define mtest_psz_eq(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, strcmp((expr), (value)) == 0, \\\r\n                    "%s expected %s, got %s.\\n", #expr, (value), (expr))\r\n#define mtest_psz_ne(expr, value) \\\r\n    MTester_do_test(__FILE__, __LINE__, strcmp((expr), (value)) != 0, \\\r\n                    "%s expected not %s.\\n", #expr, (value))\r\n\r\n#ifdef __cplusplus\r\n    #define mtest_str_eq(expr, value) \\\r\n        MTester_do_test(__FILE__, __LINE__, std::string(expr) == std::string(value), \\\r\n                        "%s expected %s, got %s.\\n", #expr, \\\r\n                        std::string(value).c_str(), std::string(expr).c_str())\r\n    #define mtest_str_ne(expr, value) \\\r\n        MTester_do_test(__FILE__, __LINE__, std::string(expr) != std::string(value), \\\r\n                        "%s expected not %s.\\n", #expr, std::string(value).c_str())\r\n#endif\r\n\r\n/****************************************************************************/\r\n/* Win32API */\r\n\r\n#ifdef _WIN32\r\n    static MZC_INLINE const char *MTester_point(const POINT *ppt)\r\n    {\r\n        if (ppt == NULL)\r\n            return "(null)";\r\n        return MTester_sprintf("(%d, %d)", ppt->x, ppt->y);\r\n    }\r\n    static MZC_INLINE const char *MTester_size(const SIZE *psiz)\r\n    {\r\n        if (psiz == NULL)\r\n            return "(null)";\r\n        return MTester_sprintf("(%d, %d)", psiz->cx, psiz->cy);\r\n    }\r\n    static MZC_INLINE const char *MTester_rect(const RECT *prc)\r\n    {\r\n        if (prc == NULL)\r\n            return "(null)";\r\n        return MTester_sprintf("(%d, %d) - (%d, %d)",\r\n                               prc->left, prc->top, prc->right, prc->bottom);\r\n    }\r\n    static MZC_INLINE const char *MTester_longlong(LONGLONG ll)\r\n    {\r\n        return MTester_sprintf("0x%08%08X", (LONG)(ll >> 32), (LONG)ll);\r\n    }\r\n    static MZC_INLINE const char *MTester_guid(const GUID *id)\r\n    {\r\n        if (id == NULL)\r\n            return "(null)";\r\n        if (IS_INTRESOURCE(id))\r\n            return MTester_sprintf("<guid-0x%04lx>", (LONG)((ULONG_PTR)id & 0xFFFF));\r\n        return MTester_sprintf("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",\r\n                             id->Data1, id->Data2, id->Data3,\r\n                             id->Data4[0], id->Data4[1], id->Data4[2], id->Data4[3],\r\n                             id->Data4[4], id->Data4[5], id->Data4[6], id->Data4[7]);\r\n    }\r\n#endif  /* _WIN32 */\r\n\r\n/****************************************************************************/\r\n\r\n#endif  /* ndef MZC4_MTESTER_H_ */\r\n
MTextToText.hpp<>MTextToText.hpp<>// MTextToText.hpp -- text encoding conversion                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTEXTTOTEXT_HPP_\r\n#define MZC4_MTEXTTOTEXT_HPP_       5       /* Version 5 */\r\n\r\nclass MAnsiToWide;\r\nclass MWideToAnsi;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MString.hpp"\r\n\r\n#include <cassert>\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MAnsiToWide\r\n{\r\npublic:\r\n    MAnsiToWide()\r\n    {\r\n    }\r\n    MAnsiToWide(int codepage, const char *str)\r\n    {\r\n        do_it(codepage, str, mstrlen(str));\r\n    }\r\n    MAnsiToWide(int codepage, const char *str, size_t count)\r\n    {\r\n        do_it(codepage, str, count);\r\n    }\r\n    MAnsiToWide(int codepage, const MStringA& str)\r\n    {\r\n        do_it(codepage, str.c_str(), str.size());\r\n    }\r\n    MAnsiToWide(int codepage, const MAnsiToWide& str) : m_str(str.m_str) { }\r\n\r\n    MAnsiToWide& operator=(const MAnsiToWide& str)\r\n    {\r\n        m_str = str.m_str;\r\n        return *this;\r\n    }\r\n\r\n    bool empty() const\r\n    {\r\n        return m_str.empty();\r\n    }\r\n\r\n    size_t size() const\r\n    {\r\n        return m_str.size();\r\n    }\r\n\r\n    WCHAR *data()\r\n    {\r\n        return &m_str[0];\r\n    }\r\n\r\n    const WCHAR *c_str() const\r\n    {\r\n        return m_str.c_str();\r\n    }\r\n\r\n    operator const WCHAR *() const\r\n    {\r\n        return c_str();\r\n    }\r\n\r\nprotected:\r\n    MStringW m_str;\r\n    void do_it(int codepage, const char *str, size_t count);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MWideToAnsi\r\n{\r\npublic:\r\n    MWideToAnsi()\r\n    {\r\n    }\r\n    MWideToAnsi(int codepage, const WCHAR *str)\r\n    {\r\n        do_it(codepage, str, mstrlen(str));\r\n    }\r\n    MWideToAnsi(int codepage, const WCHAR *str, size_t count)\r\n    {\r\n        do_it(codepage, str, count);\r\n    }\r\n    MWideToAnsi(int codepage, const MStringW& str)\r\n    {\r\n        do_it(codepage, str.c_str(), str.size());\r\n    }\r\n    MWideToAnsi(int codepage, const MWideToAnsi& str) : m_str(str.m_str) { }\r\n\r\n    MWideToAnsi& operator=(const MWideToAnsi& str)\r\n    {\r\n        m_str = str.m_str;\r\n        return *this;\r\n    }\r\n\r\n    bool empty() const\r\n    {\r\n        return m_str.empty();\r\n    }\r\n\r\n    size_t size() const\r\n    {\r\n        return m_str.size();\r\n    }\r\n\r\n    char *data()\r\n    {\r\n        return &m_str[0];\r\n    }\r\n\r\n    const char *c_str() const\r\n    {\r\n        return m_str.c_str();\r\n    }\r\n\r\n    operator const char *() const\r\n    {\r\n        return c_str();\r\n    }\r\n\r\nprotected:\r\n    MStringA m_str;\r\n    void do_it(int codepage, const WCHAR *str, size_t count);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#define MAnsiToAnsi(cp,ansi)   MStringA(ansi)\r\n#define MWideToWide(cp,wide)   MStringW(wide)\r\n\r\n#ifdef UNICODE\r\n    #define MAnsiToText MAnsiToWide\r\n    #define MTextToAnsi MWideToAnsi\r\n    #define MWideToText MWideToWide\r\n    #define MTextToWide MWideToWide\r\n    #define MTextToText MWideToWide\r\n#else\r\n    #define MAnsiToText MAnsiToAnsi\r\n    #define MTextToAnsi MAnsiToAnsi\r\n    #define MWideToText MWideToAnsi\r\n    #define MTextToWide MAnsiToWide\r\n    #define MTextToText MAnsiToAnsi\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    inline void\r\n    MAnsiToWide::do_it(int codepage, const char *str, size_t count)\r\n    {\r\n        int len = int(count);\r\n        int cch = ::MultiByteToWideChar(codepage, 0, str, len, NULL, 0);\r\n        m_str.resize(cch);\r\n        if (!::MultiByteToWideChar(codepage, 0, str, len, &m_str[0], cch + 1))\r\n        {\r\n            m_str.clear();\r\n        }\r\n    }\r\n\r\n    inline void\r\n    MWideToAnsi::do_it(int codepage, const WCHAR *str, size_t count)\r\n    {\r\n        int len = int(count);\r\n        int cch = ::WideCharToMultiByte(codepage, 0, str, len, NULL, 0, NULL, NULL);\r\n        m_str.resize(cch);\r\n        if (!::WideCharToMultiByte(codepage, 0, str, len, &m_str[0], cch + 1,\r\n                                   NULL, NULL))\r\n        {\r\n            m_str.clear();\r\n        }\r\n    }\r\n#else\r\n    #include <iconv.h>\r\n\r\n    #ifndef WonGetACP\r\n        #define WonGetACP()     1252\r\n    #endif\r\n    #ifndef WonGetOEMCP\r\n        #define WonGetOEMCP()   437\r\n    #endif\r\n\r\n    #ifndef CP_ACP\r\n        #define CP_ACP          WonGetACP()\r\n    #endif\r\n    #ifndef CP_OEMCP\r\n        #define CP_OEMCP        WonGetOEMCP()\r\n    #endif\r\n    #ifndef CP_UTF8\r\n        #define CP_UTF8         65001   // UTF-8\r\n    #endif\r\n\r\n    namespace text2text\r\n    {\r\n        inline const char *get_wide_encoding(void)\r\n        {\r\n            switch (sizeof(WCHAR))\r\n            {\r\n            case 1:\r\n                return "UTF-8";\r\n            case 2:\r\n                return "UCS-2LE";\r\n            case 4:\r\n                return "UCS-4LE";\r\n            default:\r\n                assert(0);\r\n                return NULL;\r\n            }\r\n        }\r\n\r\n        inline std::string encoding_from_cp(int codepage)\r\n        {\r\n            if (codepage == CP_ACP)\r\n                codepage = WonGetACP();\r\n            else if (codepage == CP_OEMCP)\r\n                codepage = WonGetOEMCP();\r\n\r\n            std::string ret;\r\n            switch (codepage)\r\n            {\r\n            case CP_UTF8:\r\n                ret = "UTF-8";\r\n                break;\r\n            case 932:\r\n                ret = "SHIFT_JIS";\r\n                break;\r\n            case 1252:\r\n                ret = "ISO-8859-1";\r\n                break;\r\n            default:\r\n                mstr_to_dec(ret, codepage, false);\r\n                ret = "CP" + ret;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    inline void\r\n    MAnsiToWide::do_it(int codepage, const char *str, size_t count)\r\n    {\r\n        m_str.clear();\r\n        if (*str == 0)\r\n            return;\r\n\r\n        iconv_t ic = iconv_open(text2text::get_wide_encoding(),\r\n                                text2text::encoding_from_cp(codepage).c_str());\r\n        if ((iconv_t)-1 == ic)\r\n            return;\r\n\r\n        size_t ansi_len = count * sizeof(char);\r\n        #ifdef ICONV_SECOND_ARGUMENT_IS_CONST\r\n            const char *ansi_ptr  = str;\r\n        #else\r\n            char *ansi_ptr  = const_cast<char *>(str);\r\n        #endif\r\n\r\n        size_t buf_len = (count + 1) * sizeof(WCHAR);\r\n        if (char *buf = (char *)malloc(buf_len))\r\n        {\r\n            size_t wide_len = buf_len;\r\n            char *wide_ptr = buf;\r\n            if (buf && (size_t)-1 != iconv(ic, &ansi_ptr, &ansi_len, &wide_ptr, &wide_len))\r\n            {\r\n                wide_len = buf_len - wide_len;\r\n                m_str.assign(reinterpret_cast<WCHAR *>(buf), wide_len / sizeof(WCHAR));\r\n            }\r\n            free(buf);\r\n        }\r\n\r\n        iconv_close(ic);\r\n    }\r\n\r\n    inline void\r\n    MWideToAnsi::do_it(int codepage, const WCHAR *str, size_t count)\r\n    {\r\n        m_str.clear();\r\n        if (*str == 0)\r\n            return;\r\n\r\n        iconv_t ic = iconv_open(text2text::encoding_from_cp(codepage).c_str(),\r\n                                text2text::get_wide_encoding());\r\n        if ((iconv_t)-1 == ic)\r\n            return;\r\n\r\n        size_t wide_len = count * sizeof(WCHAR);\r\n        #ifdef ICONV_SECOND_ARGUMENT_IS_CONST\r\n            const char *wide_ptr  = reinterpret_cast<const char *>(str);\r\n        #else\r\n            char *wide_ptr  = reinterpret_cast<char *>(const_cast<WCHAR *>(str));\r\n        #endif\r\n\r\n        size_t buf_len = (count + 1) * 3;\r\n        if (char *buf = (char *)malloc(buf_len))\r\n        {\r\n            size_t ansi_len = buf_len;\r\n            char *ansi_ptr = buf;\r\n            if (buf && (size_t)-1 != iconv(ic, &wide_ptr, &wide_len, &ansi_ptr, &ansi_len))\r\n            {\r\n                ansi_len = buf_len - ansi_len;\r\n                m_str.assign(buf, ansi_len / sizeof(char));\r\n            }\r\n            free(buf);\r\n        }\r\n\r\n        iconv_close(ic);\r\n    }\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTEXTTOTEXT_HPP_\r\n
MThreadLocal.hpp<>MThreadLocal.hpp<>// MThreadLocal.hpp -- Win32API thread local                    -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTHREADLOCAL_HPP_\r\n#define MZC4_MTHREADLOCAL_HPP_      2   /* Version 2 */\r\n\r\ntemplate <class T_DATA>\r\nclass MThreadLocal;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <class T_DATA>\r\nclass MThreadLocal\r\n{\r\npublic:\r\n    MThreadLocal();\r\n    virtual ~MThreadLocal();\r\n\r\n    T_DATA* GetData();\r\n    T_DATA* GetDataNA();    // no allocation\r\n    T_DATA& operator*();\r\n    T_DATA* operator->();\r\n\r\n    struct MThreadLocalNode\r\n    {\r\n        T_DATA *value;\r\n        MThreadLocalNode *next;\r\n    };\r\n\r\nprotected:\r\n    DWORD m_dwIndex;\r\n    MThreadLocalNode *m_nodes;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ntemplate <class T_DATA>\r\ninline MThreadLocal<T_DATA>::MThreadLocal() :\r\n    m_dwIndex(::TlsAlloc()),\r\n    m_nodes(NULL)\r\n{\r\n    assert(m_dwIndex != 0xFFFFFFFF);\r\n}\r\n\r\ntemplate <class T_DATA>\r\n/*virtual*/ MThreadLocal<T_DATA>::~MThreadLocal()\r\n{\r\n    ::TlsFree(m_dwIndex);\r\n\r\n    MThreadLocalNode *node = m_nodes;\r\n    while (node)\r\n    {\r\n        MThreadLocalNode *next = node->next;\r\n        delete node->value;\r\n        delete node;\r\n        node = next;\r\n    }\r\n}\r\n\r\ntemplate <class T_DATA>\r\ninline T_DATA* MThreadLocal<T_DATA>::GetDataNA()\r\n{\r\n    return reinterpret_cast<T_DATA *>(::TlsGetValue(m_dwIndex));\r\n}\r\n\r\ntemplate <class T_DATA>\r\ninline T_DATA* MThreadLocal<T_DATA>::GetData()\r\n{\r\n    T_DATA *pData = GetDataNA();\r\n    if (pData)\r\n        return pData;\r\n\r\n    pData = new T_DATA;\r\n    MThreadLocalNode *node = new MThreadLocalNode;\r\n    node->value = pData;\r\n    node->next = m_nodes;\r\n    m_nodes = node;\r\n\r\n    return pData;\r\n}\r\n\r\ntemplate <class T_DATA>\r\ninline T_DATA& MThreadLocal<T_DATA>::operator*()\r\n{\r\n    return *GetData();\r\n}\r\n\r\ntemplate <class T_DATA>\r\ninline T_DATA* MThreadLocal<T_DATA>::operator->()\r\n{\r\n    return GetData();\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTHREADLOCAL_HPP_\r\n
MToolBarCtrl.hpp<>MToolBarCtrl.hpp<>// MToolBarCtrl.hpp -- Win32API tool bar control wrapper        -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTOOLBARCTRL_HPP_\r\n#define MZC4_MTOOLBARCTRL_HPP_      5   /* Version 5 */\r\n\r\nclass MToolBarCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MToolBarCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MToolBarCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    virtual HWND SetParent(HWND hWndNewParent);\r\n\r\n    BOOL IsButtonEnabled(INT nButtonID) const;\r\n    BOOL IsButtonChecked(INT nButtonID) const;\r\n    BOOL IsButtonPressed(INT nButtonID) const;\r\n    BOOL IsButtonHidden(INT nButtonID) const;\r\n    BOOL IsButtonIndeterminate(INT nButtonID) const;\r\n    #if (_WIN32_IE >= 0x0400)\r\n        BOOL IsButtonHighlighted(INT nButtonID) const;\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    INT GetState(INT nButtonID) const;\r\n    BOOL SetState(INT nButtonID, UINT nTBSTATE_flags);\r\n\r\n    BOOL GetButton(INT nIndex, LPTBBUTTON lpButton) const;\r\n    BOOL SetButton(INT nIndex, CONST TBBUTTON *lpButton);\r\n    INT GetButtonCount() const;\r\n    BOOL GetItemRect(INT nIndex, LPRECT prc) const;\r\n    VOID SetButtonStructSize(INT nSize);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        BOOL GetRect(INT nButtonID, LPRECT prc) const;\r\n\r\n        SIZE GetButtonSize() const;\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    BOOL SetButtonSize(SIZE size);\r\n\r\n    BOOL SetBitmapSize(SIZE size);\r\n\r\n    HWND GetToolTips() const;\r\n    VOID SetToolTips(HWND hwndTT);\r\n\r\n    INT GetRows() const;\r\n    VOID SetRows(INT nRows, BOOL bLarger, LPRECT prc);\r\n    BOOL SetCmdID(INT nIndex, UINT nCommandID);\r\n    UINT GetBitmapFlags() const;\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        INT GetTextRows() const;\r\n\r\n        DWORD GetStyle() const;\r\n        VOID SetStyle(DWORD dwStyle);\r\n\r\n        BOOL SetButtonWidth(INT cxMin, INT cxMax);\r\n\r\n        HIMAGELIST GetImageList(INT nIndex = 0) const;\r\n        HIMAGELIST SetImageList(HIMAGELIST hImageList, INT nIndex = 0);\r\n\r\n        HIMAGELIST GetDisabledImageList(INT nIndex = 0) const;\r\n        HIMAGELIST SetDisabledImageList(HIMAGELIST hImageList, INT nIndex = 0);\r\n\r\n        HIMAGELIST GetHotImageList(INT nIndex = 0) const;\r\n        HIMAGELIST SetHotImageList(HIMAGELIST hImageList, INT nIndex = 0);\r\n\r\n        BOOL SetIndent(INT iIndent);\r\n        BOOL SetMaxTextRows(INT iMaxRows);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    #if (_WIN32_IE >= 0x400)\r\n        BOOL GetButtonInfo(INT nButtonID, TBBUTTONINFO* ptbbi) const;\r\n        BOOL SetButtonInfo(INT nButtonID, TBBUTTONINFO* ptbbi);\r\n\r\n        DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwDTFlags);\r\n\r\n        BOOL GetAnchorHighlight() const;\r\n        BOOL SetAnchorHighlight(BOOL bEnable = TRUE);\r\n\r\n        INT GetHotItem() const;\r\n        INT SetHotItem(INT nIndex);\r\n\r\n        VOID GetInsertMark(TBINSERTMARK* ptbim) const;\r\n        VOID SetInsertMark(TBINSERTMARK* ptbim);\r\n        BOOL InsertMarkHitTest(LPPOINT ppt, LPTBINSERTMARK ptbim) const;\r\n        COLORREF GetInsertMarkColor() const;\r\n        COLORREF SetInsertMarkColor(COLORREF clrNew);\r\n\r\n        BOOL GetMaxSize(LPSIZE pSize) const;\r\n\r\n        DWORD GetExtendedStyle() const;\r\n        DWORD SetExtendedStyle(DWORD dwExStyle);\r\n    #endif  // (_WIN32_IE >= 0x400)\r\n\r\n    BOOL EnableButton(INT nButtonID, BOOL bEnable = TRUE);\r\n    BOOL CheckButton(INT nButtonID, BOOL bCheck = TRUE);\r\n    BOOL PressButton(INT nButtonID, BOOL bPress = TRUE);\r\n    BOOL HideButton(INT nButtonID, BOOL bHide = TRUE);\r\n    BOOL Indeterminate(INT nButtonID, BOOL bIndeterminate = TRUE);\r\n    INT AddBitmap(INT nNumButtons, UINT nBitmapID);\r\n    INT AddBitmap(INT nNumButtons, HBITMAP hBitmap);\r\n    BOOL AddButtons(INT nNumButtons, LPTBBUTTON lpButtons);\r\n    BOOL InsertButton(INT nIndex, CONST TBBUTTON *lpButton);\r\n    BOOL DeleteButton(INT nIndex);\r\n    UINT CommandToIndex(UINT nCommandID) const;\r\n    VOID SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey,\r\n        LPCTSTR lpszValueName);\r\n    VOID RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey,\r\n        LPCTSTR lpszValueName);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        VOID LoadImages(INT iBitmapID, HINSTANCE hinst = ::GetModuleHandle(NULL));\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    #if (_WIN32_IE >= 0x0400)\r\n        BOOL MapAccelerator(TCHAR chAccel, UINT* pIDBtn);\r\n        BOOL MarkButton(INT nButtonID, BOOL fHighlight = TRUE);\r\n        BOOL MoveButton(UINT nOldPos, UINT nNewPos);\r\n        INT HitTest(LPPOINT ppt) const;\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    VOID Customize();\r\n    INT AddString(UINT nStringID);\r\n    INT AddStrings(LPCTSTR pszzStrings);\r\n    VOID AutoSize();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MToolBarCtrl::MToolBarCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MToolBarCtrl::GetWndClassNameDx() const\r\n{\r\n    return TOOLBARCLASSNAME;\r\n}\r\n\r\ninline /*virtual*/ HWND MToolBarCtrl::SetParent(HWND hWndNewParent)\r\n{\r\n    HWND hwndOldParent = ::GetParent(m_hwnd);\r\n    SendMessageDx(TB_SETPARENT, (WPARAM)hWndNewParent);\r\n    return hwndOldParent;\r\n}\r\n\r\ninline BOOL MToolBarCtrl::IsButtonEnabled(INT nButtonID) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_ISBUTTONENABLED, (WPARAM)nButtonID);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::IsButtonChecked(INT nButtonID) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_ISBUTTONCHECKED, (WPARAM)nButtonID);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::IsButtonPressed(INT nButtonID) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_ISBUTTONPRESSED, (WPARAM)nButtonID);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::IsButtonHidden(INT nButtonID) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_ISBUTTONHIDDEN, (WPARAM)nButtonID);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::IsButtonIndeterminate(INT nButtonID) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_ISBUTTONINDETERMINATE, (WPARAM)nButtonID);\r\n}\r\n#if (_WIN32_IE >= 0x0400)\r\n\r\n    inline BOOL MToolBarCtrl::IsButtonHighlighted(INT nButtonID) const\r\n    {\r\n        return (BOOL)SendMessageDx(TB_ISBUTTONHIGHLIGHTED, (WPARAM)nButtonID);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\ninline INT MToolBarCtrl::GetState(INT nButtonID) const\r\n{\r\n    return (INT)SendMessageDx(TB_GETSTATE, (WPARAM)nButtonID);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::SetState(INT nButtonID, UINT nTBSTATE_flags)\r\n{\r\n    return (BOOL)SendMessageDx(TB_SETSTATE, (WPARAM)nButtonID, MAKELPARAM(nTBSTATE_flags, 0));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::GetButton(INT nIndex, LPTBBUTTON lpButton) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_GETBUTTON, (WPARAM)nIndex, (LPARAM)lpButton);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::SetButton(INT nIndex, CONST TBBUTTON *lpButton)\r\n{\r\n    return DeleteButton(nIndex) && InsertButton(nIndex, lpButton);\r\n}\r\n\r\ninline INT MToolBarCtrl::GetButtonCount() const\r\n{\r\n    return (INT)SendMessageDx(TB_BUTTONCOUNT);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::GetItemRect(INT nIndex, LPRECT prc) const\r\n{\r\n    return (BOOL)SendMessageDx(TB_GETITEMRECT, (WPARAM)nIndex, (LPARAM)prc);\r\n}\r\n\r\ninline VOID MToolBarCtrl::SetButtonStructSize(INT nSize)\r\n{\r\n    SendMessageDx(TB_BUTTONSTRUCTSIZE, (WPARAM)nSize);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline BOOL MToolBarCtrl::GetRect(INT nButtonID, LPRECT prc) const\r\n    {\r\n        return (BOOL)SendMessageDx(TB_GETRECT, (WPARAM)nButtonID, (LPARAM)prc);\r\n    }\r\n\r\n    inline SIZE MToolBarCtrl::GetButtonSize() const\r\n    {\r\n        SIZE siz;\r\n        DWORD dw = (DWORD)SendMessageDx(TB_GETBUTTONSIZE);\r\n        siz.cx = (SHORT)LOWORD(dw);\r\n        siz.cy = (SHORT)HIWORD(dw);\r\n        return siz;\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline BOOL MToolBarCtrl::SetButtonSize(SIZE size)\r\n{\r\n    return (BOOL)SendMessageDx(TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::SetBitmapSize(SIZE size)\r\n{\r\n    return (BOOL)SendMessageDx(TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));\r\n}\r\n\r\ninline HWND MToolBarCtrl::GetToolTips() const\r\n{\r\n    return (HWND)SendMessageDx(TB_GETTOOLTIPS);\r\n}\r\n\r\ninline VOID MToolBarCtrl::SetToolTips(HWND hwndTT)\r\n{\r\n    SendMessageDx(TB_SETTOOLTIPS, (WPARAM)hwndTT);\r\n}\r\n\r\ninline INT MToolBarCtrl::GetRows() const\r\n{\r\n    return (INT)SendMessageDx(TB_GETROWS);\r\n}\r\n\r\ninline VOID MToolBarCtrl::SetRows(INT nRows, BOOL bLarger, LPRECT prc)\r\n{\r\n    SendMessageDx(TB_SETROWS, MAKEWPARAM(nRows, bLarger), (LPARAM)prc);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::SetCmdID(INT nIndex, UINT nCommandID)\r\n{\r\n    return (BOOL)SendMessageDx(TB_SETCMDID, (WPARAM)nIndex, (LPARAM)nCommandID);\r\n}\r\n\r\ninline UINT MToolBarCtrl::GetBitmapFlags() const\r\n{\r\n    return (DWORD)SendMessageDx(TB_GETBITMAPFLAGS);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline INT MToolBarCtrl::GetTextRows() const\r\n    {\r\n        return (INT)SendMessageDx(TB_GETTEXTROWS);\r\n    }\r\n\r\n    inline DWORD MToolBarCtrl::GetStyle() const\r\n    {\r\n        return (DWORD)SendMessageDx(TB_GETSTYLE);\r\n    }\r\n\r\n    inline VOID MToolBarCtrl::SetStyle(DWORD dwStyle)\r\n    {\r\n        SendMessageDx(TB_SETSTYLE, 0, (LPARAM)dwStyle);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::SetButtonWidth(INT cxMin, INT cxMax)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));\r\n    }\r\n\r\n    inline HIMAGELIST\r\n    MToolBarCtrl::GetImageList(INT nIndex/* = 0*/) const\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_GETIMAGELIST, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline HIMAGELIST\r\n    MToolBarCtrl::SetImageList(HIMAGELIST hImageList, INT nIndex/* = 0*/)\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_SETIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);\r\n    }\r\n\r\n    inline HIMAGELIST MToolBarCtrl::GetDisabledImageList(\r\n        INT nIndex/* = 0*/) const\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_GETDISABLEDIMAGELIST, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline HIMAGELIST MToolBarCtrl::SetDisabledImageList(\r\n        HIMAGELIST hImageList, INT nIndex/* = 0*/)\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_SETDISABLEDIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);\r\n    }\r\n\r\n    inline HIMAGELIST\r\n    MToolBarCtrl::GetHotImageList(INT nIndex/* = 0*/) const\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_GETHOTIMAGELIST, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline HIMAGELIST\r\n    MToolBarCtrl::SetHotImageList(HIMAGELIST hImageList, INT nIndex/* = 0*/)\r\n    {\r\n        return (HIMAGELIST)SendMessageDx(TB_SETHOTIMAGELIST, (WPARAM)nIndex, (LPARAM)hImageList);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::SetIndent(INT iIndent)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_SETINDENT, (WPARAM)iIndent);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::SetMaxTextRows(INT iMaxRows)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_SETMAXTEXTROWS, (WPARAM)iMaxRows);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x400)\r\n    inline BOOL MToolBarCtrl::GetButtonInfo(\r\n        INT nButtonID, TBBUTTONINFO* ptbbi) const\r\n    {\r\n        return (INT)SendMessageDx(TB_GETBUTTONINFO, (WPARAM)nButtonID, (LPARAM)ptbbi);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::SetButtonInfo(\r\n        INT nButtonID, TBBUTTONINFO* ptbbi)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_SETBUTTONINFO, (WPARAM)nButtonID, (LPARAM)ptbbi);\r\n    }\r\n\r\n    inline DWORD MToolBarCtrl::SetDrawTextFlags(\r\n        DWORD dwMask, DWORD dwDTFlags)\r\n    {\r\n        return (DWORD)SendMessageDx(TB_SETDRAWTEXTFLAGS, (WPARAM)dwMask, (LPARAM)dwDTFlags);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::GetAnchorHighlight() const\r\n    {\r\n        return (BOOL)SendMessageDx(TB_GETANCHORHIGHLIGHT);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::SetAnchorHighlight(\r\n        BOOL bEnable/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_SETANCHORHIGHLIGHT, (WPARAM)bEnable);\r\n    }\r\n\r\n    inline INT MToolBarCtrl::GetHotItem() const\r\n    {\r\n        return (INT)SendMessageDx(TB_GETHOTITEM);\r\n    }\r\n\r\n    inline INT MToolBarCtrl::SetHotItem(INT nIndex)\r\n    {\r\n        return (INT)SendMessageDx(TB_SETHOTITEM, (WPARAM)nIndex);\r\n    }\r\n\r\n    inline VOID MToolBarCtrl::GetInsertMark(TBINSERTMARK* ptbim) const\r\n    {\r\n        SendMessageDx(TB_GETINSERTMARK, 0, (LPARAM)ptbim);\r\n    }\r\n\r\n    inline VOID MToolBarCtrl::SetInsertMark(TBINSERTMARK* ptbim)\r\n    {\r\n        SendMessageDx(TB_SETINSERTMARK, 0, (LPARAM)ptbim);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::InsertMarkHitTest(\r\n        LPPOINT ppt, LPTBINSERTMARK ptbim) const\r\n    {\r\n        return (BOOL)SendMessageDx(TB_INSERTMARKHITTEST, (WPARAM)ppt, (LPARAM)ptbim);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::GetMaxSize(LPSIZE pSize) const\r\n    {\r\n        return (BOOL)SendMessageDx(TB_GETMAXSIZE, 0, (LPARAM)pSize);\r\n    }\r\n\r\n    inline DWORD MToolBarCtrl::GetExtendedStyle() const\r\n    {\r\n        return (DWORD)SendMessageDx(TB_GETEXTENDEDSTYLE);\r\n    }\r\n\r\n    inline DWORD MToolBarCtrl::SetExtendedStyle(DWORD dwExStyle)\r\n    {\r\n        return (DWORD)SendMessageDx(TB_SETEXTENDEDSTYLE, 0, (LPARAM)dwExStyle);\r\n    }\r\n\r\n    inline COLORREF MToolBarCtrl::GetInsertMarkColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TB_GETINSERTMARKCOLOR);\r\n    }\r\n\r\n    inline COLORREF MToolBarCtrl::SetInsertMarkColor(COLORREF clrNew)\r\n    {\r\n        return (COLORREF)SendMessageDx(TB_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x400)\r\n\r\ninline BOOL MToolBarCtrl::EnableButton(\r\n    INT nButtonID, BOOL bEnable/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TB_ENABLEBUTTON, (WPARAM)nButtonID, MAKELPARAM(bEnable, 0));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::CheckButton(\r\n    INT nButtonID, BOOL bCheck/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TB_CHECKBUTTON, (WPARAM)nButtonID, MAKELPARAM(bCheck, 0));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::PressButton(\r\n    INT nButtonID, BOOL bPress/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TB_PRESSBUTTON, (WPARAM)nButtonID, MAKELPARAM(bPress, 0));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::HideButton(INT nButtonID, BOOL bHide/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TB_HIDEBUTTON, (WPARAM)nButtonID, MAKELPARAM(bHide, 0));\r\n}\r\n\r\ninline BOOL MToolBarCtrl::Indeterminate(\r\n    INT nButtonID, BOOL bIndeterminate/* = TRUE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TB_INDETERMINATE, (WPARAM)nButtonID, MAKELPARAM(bIndeterminate, 0));\r\n}\r\n\r\ninline INT MToolBarCtrl::AddBitmap(INT nNumButtons, UINT nBitmapID)\r\n{\r\n    TBADDBITMAP tbab;\r\n    ZeroMemory(&tbab, sizeof(tbab));\r\n    tbab.hInst = ::GetModuleHandle(NULL);\r\n    tbab.nID = nBitmapID;\r\n    return (INT)SendMessageDx(TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);\r\n}\r\n\r\ninline INT MToolBarCtrl::AddBitmap(INT nNumButtons, HBITMAP hBitmap)\r\n{\r\n    TBADDBITMAP tbab;\r\n    ZeroMemory(&tbab, sizeof(tbab));\r\n    tbab.hInst = NULL;\r\n    tbab.nID = (UINT_PTR) hBitmap;\r\n    return (INT)SendMessageDx(TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::AddButtons(\r\n    INT nNumButtons, LPTBBUTTON lpButtons)\r\n{\r\n    return (BOOL)SendMessageDx(TB_ADDBUTTONS, (WPARAM)nNumButtons, (LPARAM)lpButtons);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::InsertButton(\r\n    INT nIndex, CONST TBBUTTON *lpButton)\r\n{\r\n    return (BOOL)SendMessageDx(TB_INSERTBUTTON, (WPARAM)nIndex, (LPARAM)lpButton);\r\n}\r\n\r\ninline BOOL MToolBarCtrl::DeleteButton(INT nIndex)\r\n{\r\n    return (BOOL)SendMessageDx(TB_DELETEBUTTON, (WPARAM)nIndex);\r\n}\r\n\r\ninline UINT MToolBarCtrl::CommandToIndex(UINT nCommandID) const\r\n{\r\n    return (UINT)SendMessageDx(TB_COMMANDTOINDEX, nCommandID);\r\n}\r\n\r\ninline VOID MToolBarCtrl::SaveState(\r\n    HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)\r\n{\r\n    TBSAVEPARAMS tbs;\r\n    ZeroMemory(&tbs, sizeof(tbs));\r\n    tbs.hkr = hKeyRoot;\r\n    tbs.pszSubKey = lpszSubKey;\r\n    tbs.pszValueName = lpszValueName;\r\n    SendMessageDx(TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);\r\n}\r\n\r\ninline VOID MToolBarCtrl::RestoreState(\r\n    HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)\r\n{\r\n    TBSAVEPARAMS tbs;\r\n    ZeroMemory(&tbs, sizeof(tbs));\r\n    tbs.hkr = hKeyRoot;\r\n    tbs.pszSubKey = lpszSubKey;\r\n    tbs.pszValueName = lpszValueName;\r\n    SendMessageDx(TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline VOID MToolBarCtrl::LoadImages(\r\n        INT iBitmapID, HINSTANCE hinst/* = ::GetModuleHandle(NULL)*/)\r\n    {\r\n        SendMessageDx(TB_LOADIMAGES, (WPARAM)iBitmapID, (LPARAM)hinst);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline BOOL MToolBarCtrl::MapAccelerator(TCHAR chAccel, UINT* pIDBtn)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)&pIDBtn);\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::MarkButton(\r\n        INT nButtonID, BOOL fHighlight/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_MARKBUTTON, (WPARAM)nButtonID, MAKELPARAM(fHighlight, 0));\r\n    }\r\n\r\n    inline BOOL MToolBarCtrl::MoveButton(UINT nOldPos, UINT nNewPos)\r\n    {\r\n        return (BOOL)SendMessageDx(TB_MOVEBUTTON, (WPARAM)nOldPos, (LPARAM)nNewPos);\r\n    }\r\n\r\n    inline INT MToolBarCtrl::HitTest(LPPOINT ppt) const\r\n    {\r\n        return (INT)SendMessageDx(TB_HITTEST, 0, (LPARAM)ppt);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\ninline VOID MToolBarCtrl::Customize()\r\n{\r\n    SendMessageDx(TB_CUSTOMIZE);\r\n}\r\n\r\ninline INT MToolBarCtrl::AddString(UINT nStringID)\r\n{\r\n    return (INT)SendMessageDx(TB_ADDSTRING, (WPARAM)::GetModuleHandle(NULL), (LPARAM)nStringID);\r\n}\r\n\r\ninline INT MToolBarCtrl::AddStrings(LPCTSTR pszzStrings)\r\n{\r\n    return (INT)SendMessageDx(TB_ADDSTRING, 0, (LPARAM)pszzStrings);\r\n}\r\n\r\ninline VOID MToolBarCtrl::AutoSize()\r\n{\r\n    SendMessageDx(TB_AUTOSIZE);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTOOLBARCTRL_HPP_\r\n
MToolTipCtrl.hpp<>MToolTipCtrl.hpp<>// MToolTipCtrl.hpp -- Win32API tool tip control wrapper        -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTOOLTIPCTRL_HPP_\r\n#define MZC4_MTOOLTIPCTRL_HPP_      2   /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MToolTipCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MToolTipCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    VOID GetText(MString& str, HWND hWnd, UINT nToolID = 0) const;\r\n    BOOL GetToolInfo(LPTOOLINFO lpToolInfo) const;\r\n    VOID SetToolInfo(LPTOOLINFO lpToolInfo);\r\n    VOID SetToolRect(HWND hWnd, UINT nToolID, LPCRECT prc);\r\n    INT GetToolCount() const;\r\n\r\n    VOID SetDelayTime(DWORD dwDuration, INT iTime);\r\n\r\n    #if (_WIN32_IE >= 0x0300)\r\n        INT GetDelayTime(DWORD dwDuration) const;\r\n\r\n        VOID GetMargin(LPRECT lprc) const;\r\n        VOID SetMargin(LPRECT lprc);\r\n\r\n        INT GetMaxTipWidth() const;\r\n        INT SetMaxTipWidth(INT iWidth);\r\n\r\n        COLORREF GetTipBkColor() const;\r\n        VOID SetTipBkColor(COLORREF clr);\r\n\r\n        COLORREF GetTipTextColor() const;\r\n        VOID SetTipTextColor(COLORREF clr);\r\n    #endif  // (_WIN32_IE >= 0x0300)\r\n\r\n    VOID Activate(BOOL bActivate);\r\n\r\n    BOOL AddTool(HWND hWnd, UINT nTextID, LPCRECT lpRectTool = NULL,\r\n        UINT nToolID = 0, HINSTANCE hInstance = NULL);\r\n    BOOL AddTool(HWND hWnd, LPCTSTR lpszText = LPSTR_TEXTCALLBACK,\r\n        LPCRECT lpRectTool = NULL, UINT nToolID = 0);\r\n\r\n    VOID DelTool(HWND hWnd, UINT nToolID = 0);\r\n\r\n    BOOL HitTest(HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const;\r\n    VOID RelayEvent(LPMSG lpMsg);\r\n    VOID UpdateTipText(LPCTSTR lpszText, HWND hWnd, UINT nToolID = 0);\r\n    VOID UpdateTipText(UINT nTextID, HWND hWnd, UINT nToolID = 0,\r\n                       HINSTANCE hInstance = NULL);\r\n    #if (_WIN32_IE >= 0x0400)\r\n        VOID Update();\r\n    #endif  // (_WIN32_IE >= 0x0400)\r\n\r\n    VOID Pop();\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MToolTipCtrl::MToolTipCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MToolTipCtrl::GetWndClassNameDx() const\r\n{\r\n    return TOOLTIPS_CLASS;\r\n}\r\n\r\ninline BOOL MToolTipCtrl::GetToolInfo(LPTOOLINFO lpToolInfo) const\r\n{\r\n    return (BOOL)SendMessageDx(TTM_GETTOOLINFO, 0, (LPARAM)lpToolInfo);\r\n}\r\n\r\ninline VOID MToolTipCtrl::SetToolInfo(LPTOOLINFO lpToolInfo)\r\n{\r\n    SendMessageDx(TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo);\r\n}\r\n\r\ninline INT MToolTipCtrl::GetToolCount() const\r\n{\r\n    return (INT)SendMessageDx(TTM_GETTOOLCOUNT);\r\n}\r\n\r\ninline VOID MToolTipCtrl::SetDelayTime(DWORD dwDuration, INT iTime)\r\n{\r\n    SendMessageDx(TTM_SETDELAYTIME, dwDuration, iTime);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline INT MToolTipCtrl::GetDelayTime(DWORD dwDuration) const\r\n    {\r\n        return (INT)SendMessageDx(TTM_GETDELAYTIME, dwDuration);\r\n    }\r\n\r\n    inline VOID MToolTipCtrl::GetMargin(LPRECT lprc) const\r\n    {\r\n        SendMessageDx(TTM_GETMARGIN, 0, (LPARAM)lprc);\r\n    }\r\n\r\n    inline VOID MToolTipCtrl::SetMargin(LPRECT lprc)\r\n    {\r\n        SendMessageDx(TTM_SETMARGIN, 0, (LPARAM)lprc);\r\n    }\r\n\r\n    inline INT MToolTipCtrl::GetMaxTipWidth() const\r\n    {\r\n        return (INT)SendMessageDx(TTM_GETMAXTIPWIDTH);\r\n    }\r\n\r\n    inline INT MToolTipCtrl::SetMaxTipWidth(INT iWidth)\r\n    {\r\n        return (INT)SendMessageDx(TTM_SETMAXTIPWIDTH, 0, iWidth);\r\n    }\r\n\r\n    inline COLORREF MToolTipCtrl::GetTipBkColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TTM_GETTIPBKCOLOR);\r\n    }\r\n\r\n    inline VOID MToolTipCtrl::SetTipBkColor(COLORREF clr)\r\n    {\r\n        SendMessageDx(TTM_SETTIPBKCOLOR, (WPARAM)clr);\r\n    }\r\n\r\n    inline COLORREF MToolTipCtrl::GetTipTextColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TTM_GETTIPTEXTCOLOR);\r\n    }\r\n\r\n    inline VOID MToolTipCtrl::SetTipTextColor(COLORREF clr)\r\n    {\r\n        SendMessageDx(TTM_SETTIPTEXTCOLOR, (WPARAM)clr);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline VOID MToolTipCtrl::Activate(BOOL bActivate)\r\n{\r\n    SendMessageDx(TTM_ACTIVATE, (WPARAM)bActivate);\r\n}\r\n\r\ninline VOID MToolTipCtrl::DelTool(HWND hWnd, UINT nToolID/* = 0*/)\r\n{\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    SendMessageDx(TTM_DELTOOL, 0, (LPARAM)&ti);\r\n}\r\n\r\ninline BOOL MToolTipCtrl::HitTest(\r\n    HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const\r\n{\r\n    TTHITTESTINFO hti;\r\n    hti.hwnd = hWnd;\r\n    hti.pt = pt;\r\n    hti.ti = *lpToolInfo;\r\n    hti.ti.cbSize = sizeof(TOOLINFO);\r\n    return (BOOL)SendMessageDx(TTM_HITTEST, 0, (LPARAM)&hti);\r\n}\r\n\r\ninline VOID MToolTipCtrl::RelayEvent(LPMSG lpMsg)\r\n{\r\n    SendMessageDx(TTM_RELAYEVENT, 0, (LPARAM)lpMsg);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline VOID MToolTipCtrl::Update()\r\n    {\r\n        SendMessageDx(TTM_UPDATE);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline VOID MToolTipCtrl::Pop()\r\n    {\r\n        SendMessageDx(TTM_POP);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline VOID MToolTipCtrl::GetText(\r\n    MString& str, HWND hWnd, UINT nToolID/* = 0*/) const\r\n{\r\n    TCHAR sz[512];\r\n    TOOLINFO ti;\r\n    ZeroMemory(&ti, sizeof(ti));\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    ti.lpszText = sz;\r\n    SendMessageDx(TTM_GETTEXT, 0, (LPARAM)&ti);\r\n    str = sz;\r\n}\r\n\r\ninline VOID MToolTipCtrl::SetToolRect(HWND hWnd, UINT nToolID, LPCRECT prc)\r\n{\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    ti.rect = *prc;\r\n    SendMessageDx(TTM_NEWTOOLRECT, 0, (LPARAM)&ti);\r\n}\r\n\r\ninline BOOL MToolTipCtrl::AddTool(HWND hWnd, UINT nTextID,\r\n    LPCRECT lpRectTool/* = NULL*/, UINT nToolID/* = 0*/,\r\n    HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    ti.rect = *lpRectTool;\r\n    ti.hinst = hInstance;\r\n    ti.lpszText = MAKEINTRESOURCE(nTextID);\r\n    return (BOOL)SendMessageDx(TTM_ADDTOOL, 0, (LPARAM)&ti);\r\n}\r\n\r\ninline BOOL MToolTipCtrl::AddTool(HWND hWnd,\r\n    LPCTSTR lpszText/* = LPSTR_TEXTCALLBACK*/,\r\n    LPCRECT lpRectTool/* = NULL*/, UINT nToolID/* = 0*/)\r\n{\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    ti.rect = *lpRectTool;\r\n    ti.lpszText = const_cast<LPTSTR>(lpszText);\r\n    return (BOOL)SendMessageDx(TTM_ADDTOOL, 0, (LPARAM)&ti);\r\n}\r\n\r\ninline VOID MToolTipCtrl::UpdateTipText(\r\n    LPCTSTR lpszText, HWND hWnd, UINT nToolID/* = 0*/)\r\n{\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hinst = ::GetModuleHandle(NULL);\r\n    ti.lpszText = const_cast<LPTSTR>(lpszText);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    SendMessageDx(TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);\r\n}\r\n\r\ninline VOID MToolTipCtrl::UpdateTipText(\r\n    UINT nTextID, HWND hWnd, UINT nToolID/* = 0*/,\r\n    HINSTANCE hInstance/* = NULL*/)\r\n{\r\n    if (hInstance == NULL)\r\n        hInstance = ::GetModuleHandle(NULL);\r\n    TOOLINFO ti;\r\n    ti.cbSize = sizeof(TOOLINFO);\r\n    ti.hinst = hInstance;\r\n    ti.lpszText = MAKEINTRESOURCE(nTextID);\r\n    ti.hwnd = hWnd;\r\n    ti.uId = nToolID;\r\n    SendMessageDx(TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTOOLTIPCTRL_HPP_\r\n
MTrackBar.hpp<>MTrackBar.hpp<>// MTrackBar.hpp -- Win32API track bar wrapper                  -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTRACKBAR_HPP_\r\n#define MZC4_MTRACKBAR_HPP_     2       /* Version 2 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MTrackBar : public MWindowBase\r\n{\r\npublic:\r\n    MTrackBar();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    INT GetLineSize() const;\r\n    INT SetLineSize(INT nSize);\r\n\r\n    INT GetPageSize() const;\r\n    INT SetPageSize(INT nSize);\r\n\r\n    INT GetRangeMax() const;\r\n    INT GetRangeMin() const;\r\n\r\n    VOID GetRange(INT& nMin, INT& nMax) const;\r\n    VOID SetRangeMin(INT nMin, BOOL bRedraw = TRUE);\r\n    VOID SetRangeMax(INT nMax, BOOL bRedraw = TRUE);\r\n    VOID SetRange(INT nMin, INT nMax, BOOL bRedraw = TRUE);\r\n\r\n    VOID GetSelection(INT& nMin, INT& nMax) const;\r\n    VOID SetSelection(INT nMin, INT nMax, BOOL bRedraw = TRUE);\r\n\r\n    VOID GetChannelRect(LPRECT lprc) const;\r\n    VOID GetThumbRect(LPRECT lprc) const;\r\n\r\n    INT GetPos() const;\r\n    VOID SetPos(INT nPos);\r\n\r\n    UINT GetNumTics() const;\r\n    DWORD* GetTicArray() const;\r\n\r\n    INT GetTic(INT nTic) const;\r\n    INT GetTicPos(INT nTic) const;\r\n    BOOL SetTic(INT nTic);\r\n    VOID SetTicFreq(INT nFreq);\r\n\r\n    VOID ClearSel(BOOL bRedraw = TRUE);\r\n    VOID VerifyPos();\r\n    VOID ClearTics(BOOL bRedraw = TRUE);\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    HWND GetBuddy(BOOL fLeft = TRUE) const;\r\n    HWND SetBuddy(HWND hwndBuddy, BOOL fLeft = TRUE);\r\n\r\n    HWND GetToolTips() const;\r\n    VOID SetToolTips(HWND hwndTT);\r\n    INT SetTipSide(INT nLocation);\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n};\r\ntypedef MTrackBar MSlider;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MTrackBar::MTrackBar()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MTrackBar::GetWndClassNameDx() const\r\n{\r\n    return TRACKBAR_CLASS;\r\n}\r\n\r\ninline INT MTrackBar::GetLineSize() const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETLINESIZE);\r\n}\r\n\r\ninline INT MTrackBar::SetLineSize(INT nSize)\r\n{\r\n    return (INT)SendMessageDx(TBM_SETLINESIZE, 0, nSize);\r\n}\r\n\r\ninline INT MTrackBar::GetPageSize() const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETPAGESIZE);\r\n}\r\n\r\ninline INT MTrackBar::SetPageSize(INT nSize)\r\n{\r\n    return (INT)SendMessageDx(TBM_SETPAGESIZE, 0, nSize);\r\n}\r\n\r\ninline INT MTrackBar::GetRangeMax() const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETRANGEMAX);\r\n}\r\n\r\ninline INT MTrackBar::GetRangeMin() const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETRANGEMIN);\r\n}\r\n\r\ninline VOID MTrackBar::GetRange(INT& nMin, INT& nMax) const\r\n{\r\n    nMin = GetRangeMin();\r\n    nMax = GetRangeMax();\r\n}\r\n\r\ninline VOID MTrackBar::SetRangeMin(INT nMin, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_SETRANGEMIN, (WPARAM)bRedraw, (LPARAM)nMin);\r\n}\r\n\r\ninline VOID MTrackBar::SetRangeMax(INT nMax, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_SETRANGEMAX, (WPARAM)bRedraw, (LPARAM)nMax);\r\n}\r\n\r\ninline VOID MTrackBar::SetRange(INT nMin, INT nMax, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_SETRANGE, (WPARAM)bRedraw, MAKELPARAM(nMin, nMax));\r\n}\r\n\r\ninline VOID MTrackBar::GetSelection(INT& nMin, INT& nMax) const\r\n{\r\n    nMin = (INT)SendMessageDx(TBM_GETSELSTART);\r\n    nMax = (INT)SendMessageDx(TBM_GETSELEND);\r\n}\r\n\r\ninline VOID MTrackBar::SetSelection(INT nMin, INT nMax, BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_SETSEL, (WPARAM)bRedraw, MAKELPARAM(nMin, nMax));\r\n}\r\n\r\ninline VOID MTrackBar::GetChannelRect(LPRECT lprc) const\r\n{\r\n    SendMessageDx(TBM_GETCHANNELRECT, 0, (LPARAM)lprc);\r\n}\r\n\r\ninline VOID MTrackBar::GetThumbRect(LPRECT lprc) const\r\n{\r\n    SendMessageDx(TBM_GETTHUMBRECT, 0, (LPARAM)lprc);\r\n}\r\n\r\ninline INT MTrackBar::GetPos() const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETPOS);\r\n}\r\n\r\ninline VOID MTrackBar::SetPos(INT nPos)\r\n{\r\n    SendMessageDx(TBM_SETPOS, TRUE, nPos);\r\n}\r\n\r\ninline UINT MTrackBar::GetNumTics() const\r\n{\r\n    return (UINT)SendMessageDx(TBM_GETNUMTICS);\r\n}\r\n\r\ninline DWORD* MTrackBar::GetTicArray() const\r\n{\r\n    return (DWORD *)SendMessageDx(TBM_GETPTICS);\r\n}\r\n\r\ninline INT MTrackBar::GetTic(INT nTic) const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETTIC, (WPARAM)nTic);\r\n}\r\n\r\ninline INT MTrackBar::GetTicPos(INT nTic) const\r\n{\r\n    return (INT)SendMessageDx(TBM_GETTICPOS, (WPARAM)nTic);\r\n}\r\n\r\ninline BOOL MTrackBar::SetTic(INT nTic)\r\n{\r\n    return (BOOL)SendMessageDx(TBM_SETTIC, 0, nTic);\r\n}\r\n\r\ninline VOID MTrackBar::SetTicFreq(INT nFreq)\r\n{\r\n    SendMessageDx(TBM_SETTICFREQ, (WPARAM)nFreq);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline HWND MTrackBar::GetBuddy(BOOL fLeft/* = TRUE*/) const\r\n    {\r\n        return (HWND)SendMessageDx(TBM_GETBUDDY, (WPARAM)fLeft);\r\n    }\r\n\r\n    inline HWND MTrackBar::SetBuddy(HWND hwndBuddy, BOOL fLeft/* = TRUE*/)\r\n    {\r\n        return (HWND)SendMessageDx(TBM_SETBUDDY, (WPARAM)fLeft, (LPARAM)hwndBuddy);\r\n    }\r\n\r\n    inline HWND MTrackBar::GetToolTips() const\r\n    {\r\n        return (HWND)SendMessageDx(TBM_GETTOOLTIPS);\r\n    }\r\n\r\n    inline VOID MTrackBar::SetToolTips(HWND hwndTT)\r\n    {\r\n        SendMessageDx(TBM_SETTOOLTIPS, (WPARAM)hwndTT);\r\n    }\r\n\r\n    inline INT MTrackBar::SetTipSide(INT nLocation)\r\n    {\r\n        return (INT)SendMessageDx(TBM_SETTIPSIDE, (WPARAM)nLocation);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\ninline VOID MTrackBar::ClearSel(BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_CLEARSEL, (WPARAM)bRedraw);\r\n}\r\n\r\ninline VOID MTrackBar::VerifyPos()\r\n{\r\n    SendMessageDx(TBM_SETPOS, (WPARAM)FALSE);\r\n}\r\n\r\ninline VOID MTrackBar::ClearTics(BOOL bRedraw/* = TRUE*/)\r\n{\r\n    SendMessageDx(TBM_CLEARTICS, (WPARAM)bRedraw);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTRACKBAR_HPP_\r\n
MTreeView.hpp<>MTreeView.hpp<>// MTreeView.hpp -- Win32API treeview wrapper                   -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTREEVIEW_HPP_\r\n#define MZC4_MTREEVIEW_HPP_     5       /* Version 5 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MTreeView : public MWindowBase\r\n{\r\npublic:\r\n    MTreeView();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    BOOL GetItemRect(HTREEITEM hItem, LPRECT prc, BOOL bTextOnly) const;\r\n    UINT GetCount() const;\r\n\r\n    UINT GetIndent() const;\r\n    VOID SetIndent(UINT nIndent);\r\n\r\n    HIMAGELIST GetImageList(UINT nImageList) const;\r\n    HIMAGELIST SetImageList(HIMAGELIST hImageList, INT nImageListType);\r\n\r\n    HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const;\r\n    HTREEITEM GetChildItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetPrevSiblingItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetParentItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetFirstVisibleItem() const;\r\n    HTREEITEM GetNextVisibleItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetPrevVisibleItem(HTREEITEM hItem) const;\r\n    HTREEITEM GetSelectedItem() const;\r\n    HTREEITEM GetDropHilightItem() const;\r\n    HTREEITEM GetRootItem() const;\r\n    BOOL GetItem(TV_ITEM* pItem) const;\r\n    INT GetItemText(HTREEITEM hItem, LPTSTR lpszText, INT nLen) const;\r\n    BOOL GetItemImage(HTREEITEM hItem, INT& nImage, INT& nSelectedImage) const;\r\n    UINT GetItemState(HTREEITEM hItem, UINT nStateMask) const;\r\n    DWORD_PTR GetItemData(HTREEITEM hItem) const;\r\n    BOOL SetItem(TV_ITEM* pItem);\r\n    BOOL SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, INT nImage,\r\n        INT nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam);\r\n    BOOL SetItemText(HTREEITEM hItem, LPCTSTR lpszItem);\r\n    BOOL SetItemImage(HTREEITEM hItem, INT nImage, INT nSelectedImage);\r\n    BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask);\r\n    BOOL SetItemData(HTREEITEM hItem, DWORD_PTR dwData);\r\n    BOOL ItemHasChildren(HTREEITEM hItem) const;\r\n    HWND GetEditControl() const;\r\n    UINT GetVisibleCount() const;\r\n\r\n    BOOL GetCheck(HTREEITEM hItem) const;\r\n    BOOL SetCheck(HTREEITEM hItem, BOOL fCheck = TRUE);\r\n\r\n    HTREEITEM InsertItem(LPTVINSERTSTRUCT lpInsertStruct);\r\n    HTREEITEM InsertItem(LPCTSTR lpszItem, INT nImage, INT nSelectedImage,\r\n        UINT nState, UINT nStateMask, LPARAM lParam, HTREEITEM hParent,\r\n        HTREEITEM hInsertAfter);\r\n    HTREEITEM InsertItem(LPCTSTR lpszItem, HTREEITEM hParent = TVI_ROOT,\r\n        HTREEITEM hInsertAfter = TVI_LAST);\r\n    HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, INT nImage,\r\n        INT nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,\r\n        HTREEITEM hParent = TVI_ROOT, HTREEITEM hInsertAfter = TVI_LAST);\r\n    BOOL DeleteItem(HTREEITEM hItem);\r\n    BOOL DeleteAllItems();\r\n    BOOL Expand(HTREEITEM hItem, UINT nCode = TVE_EXPAND);\r\n    BOOL Select(HTREEITEM hItem, UINT nCode);\r\n    BOOL SelectItem(HTREEITEM hItem);\r\n    BOOL SelectDropTarget(HTREEITEM hItem);\r\n    BOOL SelectSetFirstVisible(HTREEITEM hItem);\r\n    HWND EditLabel(HTREEITEM hItem);\r\n    HTREEITEM HitTest(POINT pt, UINT* pTVHT_flags = NULL) const;\r\n    HTREEITEM HitTest(TVHITTESTINFO* pHitTestInfo) const;\r\n    HIMAGELIST CreateDragImage(HTREEITEM hItem);\r\n    BOOL SortChildren(HTREEITEM hItem, BOOL bRecurse = FALSE);\r\n    BOOL EnsureVisible(HTREEITEM hItem);\r\n    BOOL SortChildrenCB(LPTVSORTCB pSort, BOOL bRecurse = FALSE);\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    HWND GetToolTips() const;\r\n    HWND SetToolTips(HWND hwndTT);\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    COLORREF GetBkColor() const;\r\n    COLORREF SetBkColor(COLORREF clr);\r\n\r\n    SHORT GetItemHeight() const;\r\n    SHORT SetItemHeight(SHORT cyHeight);\r\n\r\n    COLORREF GetTextColor() const;\r\n    COLORREF SetTextColor(COLORREF clr);\r\n\r\n    BOOL SetInsertMark(HTREEITEM hItem, BOOL fAfter = TRUE);\r\n    COLORREF GetInsertMarkColor() const;\r\n    COLORREF SetInsertMarkColor(COLORREF clrNew);\r\n\r\n    BOOL GetUnicodeFormat() const;\r\n    BOOL SetUnicodeFormat(BOOL bUnicode = TRUE);\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MTreeView::MTreeView()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MTreeView::GetWndClassNameDx() const\r\n{\r\n    return WC_TREEVIEW;\r\n}\r\n\r\ninline BOOL\r\nMTreeView::GetItemRect(HTREEITEM hItem, LPRECT prc, BOOL bTextOnly) const\r\n{\r\n    *(HTREEITEM*) prc = hItem;\r\n    return (BOOL)SendMessageDx(TVM_GETITEMRECT, (WPARAM)bTextOnly, (LPARAM)prc);\r\n}\r\n\r\ninline UINT MTreeView::GetCount() const\r\n{\r\n    return (UINT)SendMessageDx(TVM_GETCOUNT);\r\n}\r\n\r\ninline UINT MTreeView::GetIndent() const\r\n{\r\n    return (UINT)SendMessageDx(TVM_GETINDENT);\r\n}\r\n\r\ninline VOID MTreeView::SetIndent(UINT nIndent)\r\n{\r\n    SendMessageDx(TVM_SETINDENT, nIndent);\r\n}\r\n\r\ninline HIMAGELIST MTreeView::GetImageList(UINT nImageListType) const\r\n{\r\n    return (HIMAGELIST)SendMessageDx(TVM_GETIMAGELIST, (WPARAM)nImageListType);\r\n}\r\n\r\ninline HIMAGELIST MTreeView::SetImageList(HIMAGELIST hImageList, INT nImageListType)\r\n{\r\n    return (HIMAGELIST)SendMessageDx(TVM_SETIMAGELIST, (WPARAM)nImageListType, (LPARAM)hImageList);\r\n}\r\n\r\ninline HTREEITEM\r\nMTreeView::GetNextItem(HTREEITEM hItem, UINT nCode) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, nCode, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetChildItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetNextSiblingItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); \r\n}\r\n\r\ninline HTREEITEM MTreeView::GetPrevSiblingItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetParentItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); \r\n}\r\n\r\ninline HTREEITEM MTreeView::GetFirstVisibleItem() const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetNextVisibleItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetPrevVisibleItem(HTREEITEM hItem) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetSelectedItem() const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_CARET);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetDropHilightItem() const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_DROPHILITE);\r\n}\r\n\r\ninline HTREEITEM MTreeView::GetRootItem() const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_GETNEXTITEM, TVGN_ROOT);\r\n}\r\n\r\ninline BOOL MTreeView::GetItem(TV_ITEM* pItem) const\r\n{\r\n    return (BOOL)SendMessageDx(TVM_GETITEM, 0, (LPARAM)pItem);\r\n}\r\n\r\ninline BOOL MTreeView::SetItem(TV_ITEM* pItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SETITEM, 0, (LPARAM)pItem);\r\n}\r\n\r\ninline BOOL MTreeView::SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)\r\n{\r\n    return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0);\r\n}\r\n\r\ninline BOOL MTreeView::SetItemImage(HTREEITEM hItem, INT nImage, INT nSelectedImage)\r\n{\r\n    return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, 0);\r\n}\r\n\r\ninline BOOL MTreeView::SetItemState(\r\n    HTREEITEM hItem, UINT nState, UINT nStateMask)\r\n{\r\n    return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, 0);\r\n}\r\n\r\ninline BOOL MTreeView::SetItemData(HTREEITEM hItem, DWORD_PTR dwData)\r\n{\r\n    return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData);\r\n}\r\n\r\ninline BOOL MTreeView::ItemHasChildren(HTREEITEM hItem) const\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = TVIF_CHILDREN;\r\n    SendMessageDx(TVM_GETITEM, 0, (LPARAM)&item);\r\n    return item.cChildren;\r\n}\r\n\r\ninline HWND MTreeView::GetEditControl() const\r\n{\r\n    return (HWND)SendMessageDx(TVM_GETEDITCONTROL);\r\n}\r\n\r\ninline UINT MTreeView::GetVisibleCount() const\r\n{\r\n    return (UINT)SendMessageDx(TVM_GETVISIBLECOUNT);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0300)\r\n    inline HWND MTreeView::GetToolTips() const\r\n    {\r\n        return (HWND)SendMessageDx(TVM_GETTOOLTIPS);\r\n    }\r\n\r\n    inline HWND MTreeView::SetToolTips(HWND hwndTT)\r\n    {\r\n        return (HWND)SendMessageDx(TVM_SETTOOLTIPS, (WPARAM)hwndTT);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline COLORREF MTreeView::GetBkColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_GETBKCOLOR);\r\n    }\r\n\r\n    inline COLORREF MTreeView::SetBkColor(COLORREF clr)\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_SETBKCOLOR, 0, (LPARAM)clr);\r\n    }\r\n\r\n    inline SHORT MTreeView::GetItemHeight() const\r\n    {\r\n        return (SHORT)SendMessageDx(TVM_GETITEMHEIGHT);\r\n    }\r\n\r\n    inline SHORT MTreeView::SetItemHeight(SHORT cyHeight)\r\n    {\r\n        return (SHORT)SendMessageDx(TVM_SETITEMHEIGHT, (WPARAM)cyHeight);\r\n    }\r\n\r\n    inline COLORREF MTreeView::GetTextColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_GETTEXTCOLOR);\r\n    }\r\n\r\n    inline COLORREF MTreeView::SetTextColor(COLORREF clr)\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_SETTEXTCOLOR, 0, (LPARAM)clr);\r\n    }\r\n\r\n    inline BOOL MTreeView::SetInsertMark(HTREEITEM hItem, BOOL fAfter/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(TVM_SETINSERTMARK, (WPARAM)fAfter, (LPARAM)hItem);\r\n    }\r\n\r\n    inline COLORREF MTreeView::GetInsertMarkColor() const\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_GETINSERTMARKCOLOR);\r\n    }\r\n\r\n    inline COLORREF MTreeView::SetInsertMarkColor(COLORREF clrNew)\r\n    {\r\n        return (COLORREF)SendMessageDx(TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clrNew);\r\n    }\r\n\r\n    inline BOOL MTreeView::GetUnicodeFormat() const\r\n    {\r\n        return (BOOL)SendMessageDx(TVM_GETUNICODEFORMAT);\r\n    }\r\n\r\n    inline BOOL MTreeView::SetUnicodeFormat(BOOL bUnicode/* = TRUE*/)\r\n    {\r\n        return (BOOL)SendMessageDx(TVM_SETUNICODEFORMAT, (WPARAM)bUnicode);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\ninline BOOL MTreeView::GetCheck(HTREEITEM hItem) const\r\n{\r\n#if (_WIN32_IE >= 0x0300)\r\n    assert((GetStyleDx() & TVS_CHECKBOXES) != 0);\r\n#endif  // (_WIN32_IE >= 0x0300)\r\n    UINT uRet = GetItemState(hItem, TVIS_STATEIMAGEMASK);\r\n    return (BOOL) ((uRet >> 12) - 1);\r\n}\r\n\r\ninline BOOL MTreeView::SetCheck(HTREEITEM hItem, BOOL fCheck/* = TRUE*/)\r\n{\r\n    INT nCheck = (fCheck ? 2 : 1);\r\n    return SetItemState(hItem, (UINT)INDEXTOSTATEIMAGEMASK(nCheck),\r\n                        (UINT)TVIS_STATEIMAGEMASK);\r\n}\r\n\r\ninline HTREEITEM MTreeView::InsertItem(LPTVINSERTSTRUCT lpInsertStruct)\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);\r\n}\r\n\r\ninline HTREEITEM MTreeView::InsertItem(LPCTSTR lpszItem, INT nImage,\r\n    INT nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,\r\n    HTREEITEM hParent, HTREEITEM hInsertAfter)\r\n{\r\n    return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE,\r\n        lpszItem, nImage, nSelectedImage, nState, nStateMask, lParam,\r\n        hParent, hInsertAfter);\r\n}\r\n\r\ninline HTREEITEM MTreeView::InsertItem(LPCTSTR lpszItem,\r\n    HTREEITEM hParent/* = TVI_ROOT*/, HTREEITEM hInsertAfter/* = TVI_LAST*/)\r\n{\r\n    return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);\r\n}\r\n\r\ninline BOOL MTreeView::DeleteItem(HTREEITEM hItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_DELETEITEM, 0, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::DeleteAllItems()\r\n{\r\n    return (BOOL)SendMessageDx(TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);\r\n}\r\n\r\ninline BOOL MTreeView::Expand(HTREEITEM hItem, UINT nCode/* = TVE_EXPAND*/)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_EXPAND, nCode, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::Select(HTREEITEM hItem, UINT nCode)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SELECTITEM, nCode, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::SelectItem(HTREEITEM hItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::SelectDropTarget(HTREEITEM hItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::SelectSetFirstVisible(HTREEITEM hItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem);\r\n}\r\n\r\ninline HWND MTreeView::EditLabel(HTREEITEM hItem)\r\n{\r\n    return (HWND)SendMessageDx(TVM_EDITLABEL, 0, (LPARAM)hItem);\r\n}\r\n\r\ninline HTREEITEM MTreeView::HitTest(TVHITTESTINFO* pHitTestInfo) const\r\n{\r\n    return (HTREEITEM)SendMessageDx(TVM_HITTEST, 0, (LPARAM)pHitTestInfo);\r\n}\r\n\r\ninline HIMAGELIST MTreeView::CreateDragImage(HTREEITEM hItem)\r\n{\r\n    return (HIMAGELIST)SendMessageDx(TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::SortChildren(HTREEITEM hItem, BOOL bRecurse/* = FALSE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SORTCHILDREN, (WPARAM)bRecurse, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::EnsureVisible(HTREEITEM hItem)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_ENSUREVISIBLE, 0, (LPARAM)hItem);\r\n}\r\n\r\ninline BOOL MTreeView::SortChildrenCB(LPTVSORTCB pSort, BOOL bRecurse/* = FALSE*/)\r\n{\r\n    return (BOOL)SendMessageDx(TVM_SORTCHILDRENCB, (WPARAM)bRecurse, (LPARAM)pSort);\r\n}\r\n\r\ninline INT\r\nMTreeView::GetItemText(HTREEITEM hItem, LPTSTR lpszText, INT nLen) const\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = TVIF_TEXT;\r\n    item.pszText = lpszText;\r\n    item.cchTextMax = nLen;\r\n    return (INT)SendMessageDx(TVM_GETITEM, 0, (LPARAM)&item);\r\n}\r\n\r\ninline BOOL\r\nMTreeView::GetItemImage(HTREEITEM hItem, INT& nImage, INT& nSelectedImage) const\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;\r\n    BOOL bRes = (BOOL)SendMessageDx(TVM_GETITEM, 0, (LPARAM)&item);\r\n    if (bRes)\r\n    {\r\n        nImage = item.iImage;\r\n        nSelectedImage = item.iSelectedImage;\r\n    }\r\n    return bRes;\r\n}\r\n\r\ninline UINT\r\nMTreeView::GetItemState(HTREEITEM hItem, UINT nStateMask) const\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = TVIF_STATE;\r\n    item.state = 0;\r\n    item.stateMask = nStateMask;\r\n    SendMessageDx(TVM_GETITEM, 0, (LPARAM)&item);\r\n    return (item.state & nStateMask);\r\n}\r\n\r\ninline DWORD_PTR\r\nMTreeView::GetItemData(HTREEITEM hItem) const\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = TVIF_PARAM;\r\n    BOOL bRet = (BOOL)SendMessageDx(TVM_GETITEM, 0, (LPARAM)&item);\r\n    return (DWORD_PTR)(bRet ? item.lParam : 0);\r\n}\r\n\r\ninline BOOL\r\nMTreeView::SetItem(HTREEITEM hItem, UINT nMask,\r\n    LPCTSTR lpszItem, INT nImage, INT nSelectedImage, UINT nState,\r\n    UINT nStateMask, LPARAM lParam)\r\n{\r\n    TV_ITEM item;\r\n    ZeroMemory(&item, sizeof(item));\r\n    item.hItem = hItem;\r\n    item.mask = nMask;\r\n    item.pszText = (LPTSTR) lpszItem;\r\n    item.iImage = nImage;\r\n    item.iSelectedImage = nSelectedImage;\r\n    item.state = nState;\r\n    item.stateMask = nStateMask;\r\n    item.lParam = lParam;\r\n    return (BOOL)SendMessageDx(TVM_SETITEM, 0, (LPARAM)&item);\r\n}\r\n\r\ninline HTREEITEM\r\nMTreeView::InsertItem(UINT nMask, LPCTSTR lpszItem,\r\n    INT nImage, INT nSelectedImage, UINT nState, UINT nStateMask,\r\n    LPARAM lParam, HTREEITEM hParent/* = TVI_ROOT*/,\r\n    HTREEITEM hInsertAfter/* = TVI_LAST*/)\r\n{\r\n    TVINSERTSTRUCT tvis;\r\n    ZeroMemory(&tvis, sizeof(tvis));\r\n    tvis.hParent = hParent;\r\n    tvis.hInsertAfter = hInsertAfter;\r\n    tvis.item.mask = nMask;\r\n    tvis.item.pszText = (LPTSTR) lpszItem;\r\n    tvis.item.iImage = nImage;\r\n    tvis.item.iSelectedImage = nSelectedImage;\r\n    tvis.item.state = nState;\r\n    tvis.item.stateMask = nStateMask;\r\n    tvis.item.lParam = lParam;\r\n    return (HTREEITEM)SendMessageDx(TVM_INSERTITEM, 0, (LPARAM)&tvis);\r\n}\r\n\r\ninline HTREEITEM MTreeView::HitTest(POINT pt, UINT* pTVHT_flags/* = NULL*/) const\r\n{\r\n    TVHITTESTINFO hti;\r\n    ZeroMemory(&hti, sizeof(hti));\r\n    hti.pt = pt;\r\n    HTREEITEM hTreeItem = (HTREEITEM)SendMessageDx(TVM_HITTEST, 0, (LPARAM)&hti);\r\n    if (pTVHT_flags)\r\n        *pTVHT_flags = hti.flags;\r\n    return hTreeItem;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTREEVIEW_HPP_\r\n
MTriStateTreeView.hpp<>MTriStateTreeView.hpp<>// MTriStateTreeView.hpp -- Win32API three-state treeview     -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MTRISTATETREEVIEW_HPP_\r\n#define MZC4_MTRISTATETREEVIEW_HPP_     7       /* Version 7 */\r\n\r\n#include "MTreeView.hpp"\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#define UM_TRISTATETREEVIEW     (WM_APP + 100)\r\n\r\n// width and height of check mark\r\n#ifndef CSTATE_WIDTH\r\n    #define CSTATE_WIDTH  16\r\n    #define CSTATE_HEIGHT 16\r\n#endif\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MTriStateTreeView : public MTreeView\r\n{\r\npublic:\r\n    // 3 states\r\n    enum {\r\n        CSTATE_UNCHECKED            = 0,\r\n        CSTATE_CHECKED              = 1,\r\n        CSTATE_INDETERMINATE        = 2,\r\n        CSTATE_GRAYED_UNCHECKED     = 3,  // for future use\r\n        CSTATE_GRAYED_CHECKED       = 4,  // for future use\r\n        CSTATE_GRAYED_INDETERMINATE = 5   // for future use\r\n    };\r\n    MTriStateTreeView();\r\n    virtual ~MTriStateTreeView();\r\n\r\n    // Call me. Please use "3statechecks.bmp" for nBitmapResourceID.\r\n    BOOL InitStateImageList(INT nBitmapResourceID);\r\n\r\n    // Call me from parent's WM_NOTIFY.\r\n    LRESULT OnNotifyFromParent(HWND hwnd, int idFrom, LPNMHDR pnmhdr);\r\n\r\n    BOOL IsValidCheckState(INT nState) const;\r\n    INT GetCheckState(HTREEITEM hItem);\r\n\r\n    void InternalCheck(HTREEITEM hItem, INT nNewState = CSTATE_CHECKED);\r\n    void SetCheckState(HTREEITEM hItem, INT nNewState = CSTATE_CHECKED, BOOL bDoParent = TRUE);\r\n\r\n    virtual INT GetNextCheckState(HTREEITEM hItem, INT nState) const;\r\n\r\nprotected:\r\n    HIMAGELIST m_himl;\r\n    void ChangeParent(HTREEITEM hParent);\r\n    void ChangeItemState(HTREEITEM hItem, INT nNewState);\r\n    LRESULT OnTriStateTreeViewClick(HWND hwnd, WPARAM wParam, LPARAM lParam);\r\n    INT StripCheckState(INT nState) const;\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MTriStateTreeView::MTriStateTreeView() : m_himl(NULL)\r\n{\r\n}\r\n\r\ninline MTriStateTreeView::~MTriStateTreeView()\r\n{\r\n    if (m_himl)\r\n    {\r\n        ImageList_Destroy(m_himl);\r\n        m_himl = NULL;\r\n    }\r\n}\r\n\r\ninline BOOL MTriStateTreeView::IsValidCheckState(INT nState) const\r\n{\r\n    return 0 <= nState && nState < CSTATE_GRAYED_INDETERMINATE;\r\n}\r\n\r\ninline INT MTriStateTreeView::GetCheckState(HTREEITEM hItem)\r\n{\r\n    LRESULT res = SendMessageDx(TVM_GETITEMSTATE, (WPARAM)hItem, TVIS_STATEIMAGEMASK);\r\n    INT nState = (UINT(res) >> 12) - 1;\r\n    assert(IsValidCheckState(nState));\r\n    return nState;\r\n}\r\n\r\ninline INT MTriStateTreeView::StripCheckState(INT nState) const\r\n{\r\n    if (nState < CSTATE_GRAYED_UNCHECKED)\r\n        return nState;\r\n    return nState - CSTATE_GRAYED_UNCHECKED;\r\n}\r\n\r\ninline INT MTriStateTreeView::GetNextCheckState(HTREEITEM hItem, INT nState) const\r\n{\r\n    assert(IsValidCheckState(nState));\r\n    if (nState == CSTATE_UNCHECKED)\r\n    {\r\n        return CSTATE_CHECKED;\r\n    }\r\n    else\r\n    {\r\n        return CSTATE_UNCHECKED;\r\n    }\r\n}\r\n\r\ninline BOOL MTriStateTreeView::InitStateImageList(INT nBitmapResourceID)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n\r\n    ModifyStyleDx(0, TVS_CHECKBOXES);\r\n\r\n    if (m_himl)\r\n    {\r\n        ImageList_Destroy(m_himl);\r\n        m_himl = NULL;\r\n    }\r\n\r\n    m_himl = ImageList_LoadBitmap(\r\n        GetModuleHandle(NULL), MAKEINTRESOURCE(nBitmapResourceID),\r\n        CSTATE_WIDTH, 0, RGB(255, 0, 255));\r\n    SetImageList(m_himl, TVSIL_STATE);\r\n    if (m_himl == NULL)\r\n    {\r\n        DebugPrintDx(TEXT("nBitmapResource:%d is not a valid resource bitmap!\\n"));\r\n    }\r\n\r\n    return m_himl != NULL;\r\n}\r\n\r\ninline void MTriStateTreeView::InternalCheck(HTREEITEM hItem, INT nNewState)\r\n{\r\n    assert(IsValidCheckState(nNewState));\r\n    TV_ITEM item = {0};\r\n    item.mask = TVIF_HANDLE | TVIF_STATE;\r\n    item.hItem = hItem;\r\n    item.state = INDEXTOSTATEIMAGEMASK(nNewState + 1);\r\n    item.stateMask = TVIS_STATEIMAGEMASK;\r\n    SetItem(&item);\r\n}\r\n\r\ninline void MTriStateTreeView::SetCheckState(HTREEITEM hItem, INT nNewState, BOOL bDoParent)\r\n{\r\n    InternalCheck(hItem, nNewState);\r\n\r\n    HTREEITEM hChildItem = GetChildItem(hItem);\r\n    while (hChildItem)\r\n    {\r\n        SetCheckState(hChildItem, nNewState, FALSE);\r\n\r\n        hChildItem = GetNextSiblingItem(hChildItem);\r\n    }\r\n\r\n    if (bDoParent)\r\n    {\r\n        HTREEITEM hParent = GetParentItem(hItem);\r\n        ChangeParent(hParent);\r\n    }\r\n}\r\n\r\ninline void MTriStateTreeView::ChangeParent(HTREEITEM hParent)\r\n{\r\n    while (hParent)\r\n    {\r\n        HTREEITEM hItem = GetChildItem(hParent);\r\n        if (hItem)\r\n        {\r\n            INT nState = GetCheckState(hItem);\r\n            while (hItem)\r\n            {\r\n                INT nAnotherState = GetCheckState(hItem);\r\n                if (nAnotherState != nState)\r\n                {\r\n                    nState = CSTATE_INDETERMINATE;\r\n                    break;\r\n                }\r\n                hItem = GetNextSiblingItem(hItem);\r\n            }\r\n            InternalCheck(hParent, nState);\r\n        }\r\n        hParent = GetParentItem(hParent);\r\n    }\r\n}\r\n\r\ninline void MTriStateTreeView::ChangeItemState(HTREEITEM hItem, INT nNewState)\r\n{\r\n    assert(IsValidCheckState(nNewState));\r\n    SetCheckState(hItem, nNewState, TRUE);\r\n}\r\n\r\ninline LRESULT CALLBACK\r\nMTriStateTreeView::WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (uMsg)\r\n    {\r\n        DO_MESSAGE(UM_TRISTATETREEVIEW, OnTriStateTreeViewClick);\r\n    }\r\n    return DefaultProcDx(hwnd, uMsg, wParam, lParam);\r\n}\r\n\r\ninline LRESULT\r\nMTriStateTreeView::OnTriStateTreeViewClick(HWND hwnd, WPARAM wParam, LPARAM lParam)\r\n{\r\n    HTREEITEM hItem = HTREEITEM(wParam);\r\n    INT nState = INT(lParam);\r\n    nState = GetNextCheckState(hItem, nState);\r\n    assert(IsValidCheckState(nState));\r\n    ChangeItemState(hItem, nState);\r\n}\r\n\r\ninline LRESULT\r\nMTriStateTreeView::OnNotifyFromParent(HWND hwnd, int idFrom, LPNMHDR pnmhdr)\r\n{\r\n    switch (pnmhdr->code)\r\n    {\r\n    case NM_CLICK:\r\n        {\r\n            TV_HITTESTINFO ht = { 0 };\r\n\r\n            DWORD dwPos = GetMessagePos();\r\n            ht.pt.x = GET_X_LPARAM(dwPos);\r\n            ht.pt.y = GET_Y_LPARAM(dwPos);\r\n            ScreenToClient(m_hwnd, &ht.pt);\r\n\r\n            HTREEITEM hItem = HitTest(&ht);\r\n            if (hItem)\r\n            {\r\n                SelectItem(hItem);\r\n                if (ht.flags & TVHT_ONITEMSTATEICON)\r\n                {\r\n                    INT nPreState = GetCheckState(hItem);\r\n                    PostMessageDx(UM_TRISTATETREEVIEW, (WPARAM)ht.hItem, nPreState);\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    case TVN_KEYDOWN:\r\n        if (((LPNMTVKEYDOWN)pnmhdr)->wVKey == VK_SPACE)\r\n        {\r\n            HTREEITEM hItem = GetSelectedItem();\r\n            INT nPreState = GetCheckState(hItem);\r\n            PostMessageDx(UM_TRISTATETREEVIEW, (WPARAM)hItem, nPreState);\r\n            break;\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MTRISTATETREEVIEW_HPP_\r\n
MUnknown.hpp<>MUnknown.hpp<>// MUnknown.hpp --- MZC4 IUnknown implement class               -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MUNKNOWN_HPP_\r\n#define MZC4_MUNKNOWN_HPP_      4   /* Version 4 */\r\n\r\nclass MUnknown;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#include <unknwn.h>\r\n#include <cassert>\r\n\r\nclass MUnknown : public IUnknown\r\n{\r\npublic:\r\n    MUnknown() : m_cRef(1)\r\n    {\r\n    }\r\n\r\n    virtual ~MUnknown()\r\n    {\r\n    }\r\n\r\n    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObj)\r\n    {\r\n        if (!ppvObj)\r\n            return E_INVALIDARG;\r\n\r\n        *ppvObj = NULL;\r\n        if (riid == IID_IUnknown)\r\n        {\r\n            *ppvObj = (void *)this;\r\n            AddRef();\r\n            return S_OK;\r\n        }\r\n        return E_NOINTERFACE;\r\n    }\r\n\r\n    virtual ULONG STDMETHODCALLTYPE AddRef()\r\n    {\r\n        assert(m_cRef != -1);\r\n#ifdef SINGLE_THREAD\r\n        return ++m_cRef;\r\n#else\r\n        return ::InterlockedIncrement(&m_cRef);\r\n#endif\r\n    }\r\n\r\n    virtual ULONG STDMETHODCALLTYPE Release()\r\n    {\r\n        assert(m_cRef);\r\n#ifdef SINGLE_THREAD\r\n        if (--m_cRef == 0)\r\n#else\r\n        if (::InterlockedDecrement(&m_cRef) == 0)\r\n#endif\r\n        {\r\n            delete this;\r\n            return 0;\r\n        }\r\n        return m_cRef;\r\n    }\r\n\r\nprotected:\r\n    LONG m_cRef;\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MUNKNOWN_HPP_\r\n
MUpDownCtrl.hpp<>MUpDownCtrl.hpp<>// MUpDownCtrl.hpp -- Win32API up-down control wrapper          -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MUPDOWNCTRL_HPP_\r\n#define MZC4_MUPDOWNCTRL_HPP_   2       /* Version 2 */\r\n\r\nclass MUpDownCtrl;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\nclass MUpDownCtrl : public MWindowBase\r\n{\r\npublic:\r\n    MUpDownCtrl();\r\n    virtual LPCTSTR GetWndClassNameDx() const;\r\n\r\n    UINT GetAccel(INT nAccel, UDACCEL* pAccel) const;\r\n    BOOL SetAccel(INT nAccel, UDACCEL* pAccel);\r\n\r\n    UINT GetBase() const;\r\n    INT  SetBase(INT nBase);\r\n\r\n    HWND GetBuddy() const;\r\n    HWND SetBuddy(HWND hwndBuddy);\r\n\r\n    INT GetPos() const;\r\n    INT SetPos(INT nPos);\r\n\r\n    DWORD GetRange() const;\r\n    VOID GetRange(INT &lower, INT& upper) const;\r\n    VOID SetRange(INT nLower, INT nUpper);\r\n\r\n#if (_WIN32_IE >= 0x0500)\r\n    INT GetPos32(LPBOOL pError = NULL) const;\r\n    INT SetPos32(INT nPos);\r\n#endif  // (_WIN32_IE >= 0x0500)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    VOID GetRange32(INT& lower, INT& upper) const;\r\n    VOID SetRange32(INT nLower, INT nUpper);\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MUpDownCtrl::MUpDownCtrl()\r\n{\r\n}\r\n\r\ninline /*virtual*/ LPCTSTR MUpDownCtrl::GetWndClassNameDx() const\r\n{\r\n    return UPDOWN_CLASS;\r\n}\r\n\r\ninline BOOL MUpDownCtrl::SetAccel(INT nAccel, UDACCEL* pAccel)\r\n{\r\n    return (BOOL)SendMessageDx(UDM_SETACCEL, (WPARAM)nAccel, (LPARAM)pAccel);\r\n}\r\n\r\ninline UINT MUpDownCtrl::GetAccel(INT nAccel, UDACCEL* pAccel) const\r\n{\r\n    return (UINT)SendMessageDx(UDM_GETACCEL, (WPARAM)nAccel, (LPARAM)pAccel);\r\n}\r\n\r\ninline INT MUpDownCtrl::SetBase(INT nBase)\r\n{\r\n    return (INT)SendMessageDx(UDM_SETBASE, (WPARAM)nBase);\r\n}\r\n\r\ninline UINT MUpDownCtrl::GetBase() const\r\n{\r\n    return (UINT)SendMessageDx(UDM_GETBASE);\r\n}\r\n\r\ninline HWND MUpDownCtrl::SetBuddy(HWND hwndBuddy)\r\n{\r\n    return (HWND)SendMessageDx(UDM_SETBUDDY, (WPARAM)hwndBuddy);\r\n}\r\n\r\ninline HWND MUpDownCtrl::GetBuddy() const\r\n{\r\n    return (HWND)SendMessageDx(UDM_GETBUDDY);\r\n}\r\n\r\ninline INT MUpDownCtrl::SetPos(INT nPos)\r\n{\r\n    return (INT)SendMessageDx(UDM_SETPOS, 0, nPos);\r\n}\r\n\r\ninline INT MUpDownCtrl::GetPos() const\r\n{\r\n    return (INT)SendMessageDx(UDM_GETPOS);\r\n}\r\n\r\ninline VOID MUpDownCtrl::SetRange(INT nLower, INT nUpper)\r\n{\r\n    SendMessageDx(UDM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));\r\n}\r\n\r\ninline DWORD MUpDownCtrl::GetRange() const\r\n{\r\n    return (DWORD)SendMessageDx(UDM_GETRANGE);\r\n}\r\n\r\ninline VOID MUpDownCtrl::GetRange(INT &lower, INT& upper) const\r\n{\r\n    DWORD dw = GetRange();\r\n    lower = (INT)(SHORT) LOWORD(dw);\r\n    upper = (INT)(SHORT) HIWORD(dw);\r\n}\r\n\r\n#if (_WIN32_IE >= 0x0500)\r\n    inline INT MUpDownCtrl::GetPos32(LPBOOL pError/* = NULL*/) const\r\n    {\r\n        return (INT)SendMessageDx(UDM_GETPOS32, 0, (LPARAM)pError);\r\n    }\r\n\r\n    inline INT MUpDownCtrl::SetPos32(INT nPos)\r\n    {\r\n        return (INT)SendMessageDx(UDM_SETPOS32, 0, nPos);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0500)\r\n\r\n#if (_WIN32_IE >= 0x0400)\r\n    inline VOID MUpDownCtrl::GetRange32(INT& lower, INT& upper) const\r\n    {\r\n        SendMessageDx(UDM_GETRANGE32, (WPARAM)&lower, (LPARAM)&upper);\r\n    }\r\n\r\n    inline VOID MUpDownCtrl::SetRange32(INT nLower, INT nUpper)\r\n    {\r\n        SendMessageDx(UDM_SETRANGE32, (WPARAM)nLower, (LPARAM)nUpper);\r\n    }\r\n#endif  // (_WIN32_IE >= 0x0400)\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MUPDOWNCTRL_HPP_\r\n
MWaitCursor.hpp<>MWaitCursor.hpp<>// MWaitCursor.hpp --- Win32API wait cursor manager             -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MWAITCURSOR_HPP_\r\n#define MZC4_MWAITCURSOR_HPP_       2   /* Version 2 */\r\n\r\nclass MWaitCursor;\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#include <cassert>          // assert\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MWaitCursor\r\n{\r\npublic:\r\n    MWaitCursor();\r\n    virtual ~MWaitCursor();\r\n    VOID Restore();\r\n\r\npublic:\r\n    static VOID DoWaitCursor(INT nCode);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline VOID MWaitCursor::DoWaitCursor(INT nCode)\r\n{\r\n    static LONG     s_nCount = 0;\r\n    static HCURSOR  s_hcurRestore = NULL;\r\n\r\n    assert(nCode == 0 || nCode == 1 || nCode == -1);\r\n\r\n    switch (nCode)\r\n    {\r\n    case -1:\r\n        InterlockedDecrement(&s_nCount);\r\n        break;\r\n\r\n    case 1:\r\n        InterlockedIncrement(&s_nCount);\r\n        break;\r\n    }\r\n\r\n    if (s_nCount > 0)\r\n    {\r\n        HCURSOR hcurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));\r\n        if (nCode > 0 && s_nCount == 1)\r\n            s_hcurRestore = hcurPrev;\r\n    }\r\n    else\r\n    {\r\n        s_nCount = 0;\r\n        ::SetCursor(s_hcurRestore);\r\n    }\r\n}\r\n\r\ninline MWaitCursor::MWaitCursor()\r\n{\r\n    MWaitCursor::DoWaitCursor(1);\r\n}\r\n\r\ninline /*virtual*/ MWaitCursor::~MWaitCursor()\r\n{\r\n    MWaitCursor::DoWaitCursor(-1);\r\n}\r\n\r\ninline VOID MWaitCursor::Restore()\r\n{\r\n    MWaitCursor::DoWaitCursor(0);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MWAITCURSOR_HPP_\r\n
MWindowBase.hpp<>MWindowBase.hpp<>// MWindowBase.hpp --- MZC4 window base and dialog base         -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MWINDOWBASE_HPP_\r\n#define MZC4_MWINDOWBASE_HPP_    70     /* Version 70 */\r\n\r\nclass MWindowBase;\r\nclass MDialogBase;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#if _MSC_VER > 1000\r\n    #pragma once        // For speed!\r\n#endif\r\n\r\n#ifndef STRICT\r\n    #define STRICT  1   // We must do strictly! Good bye to old style!\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG) && !defined(_CRTDBG_MAP_ALLOC)\r\n    // for detecting memory leak (MSVC only)\r\n    #define _CRTDBG_MAP_ALLOC\r\n    #include <crtdbg.h>\r\n#endif\r\n\r\n#if __STDC_VERSION__ >= 199901L && !defined(C99)\r\n    #define C99             1\r\n#endif\r\n#if __cplusplus >= 201103L && !defined(CXX11)\r\n    #define CXX11           1\r\n#endif\r\n\r\n//#define MZC4_FAT_AND_RICH   1\r\n//#define MZC4_HANDLE_MAP     1\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// headers\r\n\r\n// Win32API headers\r\n#ifndef _INC_WINDOWS\r\n    #include <windows.h>    // Win32API\r\n#endif\r\n#ifndef _INC_WINDOWSX\r\n    #include <windowsx.h>   // Win32API Macro APIs\r\n#endif\r\n#ifndef _INC_COMMCTRL\r\n    #include <commctrl.h>   // common controls\r\n#endif\r\n#ifndef _INC_COMMDLG\r\n    #include <commdlg.h>    // common dialogs\r\n#endif\r\n#ifndef _INC_TCHAR\r\n    #include <tchar.h>      // generic text mappings\r\n#endif\r\n\r\n#include <dlgs.h>           // dialog control IDs\r\n\r\n#ifndef NO_STRSAFE\r\n    #include <strsafe.h>    // StringCch* or StringCb*\r\n#endif\r\n\r\n// standard C/C++ library\r\n#include <cassert>          // assert\r\n#include <cstring>          // C string library\r\n\r\n#include <map>              // std::map\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _countof\r\n    #define _countof(array)     (sizeof(array) / sizeof(array[0]))\r\n#endif\r\n\r\n// MString\r\n#ifndef MString\r\n    #include <string>       // std::string and std::wstring\r\n    typedef std::string     MStringA;\r\n    typedef std::wstring    MStringW;\r\n    #ifdef UNICODE\r\n        #define MString     MStringW\r\n    #else\r\n        #define MString     MStringA\r\n    #endif\r\n#endif\r\n\r\n// NOTE: Old Digital Mars C/C++ Compiler doesn't define INT_PTR type likely.\r\n#ifdef __DMC__\r\n    #ifndef INT_PTR\r\n        #ifdef _WIN64\r\n            #define INT_PTR     LPARAM\r\n        #else\r\n            #define INT_PTR     BOOL\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// public functions\r\n\r\n#ifndef MZCAPI\r\n    #define MZCAPI      WINAPI\r\n#endif\r\n\r\n#ifndef MZCAPIV\r\n    #define MZCAPIV     WINAPIV\r\n#endif\r\n\r\nVOID MZCAPIV DebugPrintDx(const char *format, ...);\r\nVOID MZCAPIV DebugPrintDx(const WCHAR *format, ...);\r\nRECT MZCAPI GetVirtualScreenRectDx();\r\nVOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc);\r\nRECT MZCAPI WorkAreaFromWindowDx(HWND hwnd);\r\nSIZE MZCAPI SizeFromRectDx(LPCRECT prc);\r\nLPTSTR MZCAPI LoadStringDx(INT nID);\r\nLPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...);\r\nLPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va);\r\nLPCTSTR MZCAPI GetStringDx(INT nStringID);\r\nLPCTSTR MZCAPI GetStringDx(LPCTSTR psz);\r\nBOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);\r\nBOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);\r\nBOOL MZCAPI SetWindowPosDx(HWND hwnd, LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n    HWND hwndInsertAfter = NULL,\r\n    UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\nBOOL MZCAPI SetWindowPosDx(HWND hwnd, const RECT *prc);\r\nLPSTR MZCAPI MakeFilterDx(LPSTR psz);\r\nLPWSTR MZCAPI MakeFilterDx(LPWSTR psz);\r\nHBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height);\r\nvoid MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr);\r\nvoid MZCAPI PremultiplyDx(HBITMAP hbm32bpp);\r\nBOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text);\r\nvoid MZCAPI\r\nPopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y);\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Messaging\r\n\r\n// LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam);\r\n#define HANDLE_MESSAGE(hwnd, uMsg, OnMessage) \\\r\n    case (uMsg): return (OnMessage)((hwnd), (wParam), (lParam))\r\n\r\n// LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n#define HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessageEx) \\\r\n    case (uMsg): return (OnMessageEx)((hwnd), (uMsg), (wParam), (lParam))\r\n\r\n#define DO_MSG(WM_, fn) \\\r\n    case (WM_): return HANDLE_##WM_(hwnd, (wParam), (lParam), (fn))\r\n#define DO_MESSAGE(uMsg, OnMessage) \\\r\n    HANDLE_MESSAGE(hwnd, uMsg, OnMessage)\r\n#define DO_MESSAGE_EX(uMsg, OnMessageEx) \\\r\n    HANDLE_MESSAGE_EX(hwnd, uMsg, OnMessage)\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MWindowBase\r\n{\r\nprotected:\r\n    DWORD           m_dwWindowBaseMagic;\r\n    MSG             m_msg;\r\npublic:\r\n    HWND            m_hwnd;\r\n    WNDPROC         m_fnOldProc;\r\n    MWindowBase *   m_pwndSub;\r\n    bool            m_bDynamicCreated;\r\n\r\n    MWindowBase() :\r\n        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(NULL), m_fnOldProc(NULL),\r\n        m_pwndSub(NULL), m_bDynamicCreated(false)\r\n    {\r\n    }\r\n\r\n    MWindowBase(HWND hwnd) :\r\n        m_dwWindowBaseMagic(0xFEEDFEED), m_hwnd(hwnd), m_fnOldProc(NULL),\r\n        m_pwndSub(NULL), m_bDynamicCreated(false)\r\n    {\r\n    }\r\n\r\n    virtual ~MWindowBase()\r\n    {\r\n    }\r\n\r\n    operator HWND() const\r\n    {\r\n        return Handle();\r\n    }\r\n    bool operator!() const\r\n    {\r\n        return Handle() == NULL;\r\n    }\r\n    HWND Handle() const\r\n    {\r\n        return (this ? m_hwnd : NULL);\r\n    }\r\n\r\n#ifdef MZC4_HANDLE_MAP\r\n    typedef std::map<HWND, void *> handle_map_type;\r\n    static handle_map_type& GetHandleMap()\r\n    {\r\n        static handle_map_type s_map;\r\n        return s_map;\r\n    }\r\n    static MWindowBase *GetUserData(HWND hwnd)\r\n    {\r\n        handle_map_type::iterator it = GetHandleMap().find(hwnd);\r\n        if (it == GetHandleMap().end())\r\n            return NULL;\r\n        return reinterpret_cast<MWindowBase *>(it->second);\r\n    }\r\n    static void SetUserData(HWND hwnd, void *ptr)\r\n    {\r\n        if (ptr)\r\n        {\r\n            GetHandleMap()[hwnd] = ptr;\r\n        }\r\n        else\r\n        {\r\n            GetHandleMap().erase(hwnd);\r\n        }\r\n    }\r\n#else\r\n    static MWindowBase *GetUserData(HWND hwnd)\r\n    {\r\n        return reinterpret_cast<MWindowBase *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));\r\n    }\r\n    static void SetUserData(HWND hwnd, void *ptr)\r\n    {\r\n        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptr);\r\n    }\r\n#endif\r\n    virtual void PostNcDestroy()\r\n    {\r\n        SetUserData(m_hwnd, NULL);\r\n        m_hwnd = NULL;\r\n        if (m_bDynamicCreated)\r\n        {\r\n            delete this;\r\n        }\r\n    }\r\n\r\n    MWindowBase *GetUserData() const\r\n    {\r\n        return GetUserData(m_hwnd);\r\n    }\r\n\r\n    LRESULT CALLBACK\r\n    CallWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    virtual LRESULT MZCAPI\r\n    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        if (m_pwndSub)\r\n        {\r\n            assert(this != m_pwndSub);\r\n            return m_pwndSub->WindowProcDx(hwnd, uMsg, wParam, lParam);\r\n        }\r\n        if (m_fnOldProc)\r\n        {\r\n            return ::CallWindowProc(m_fnOldProc, hwnd, uMsg, wParam, lParam);\r\n        }\r\n        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    LRESULT MZCAPI DefaultProcDx()\r\n    {\r\n        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);\r\n    }\r\n\r\n    VOID SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return DefaultProcDx(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    static LRESULT CALLBACK\r\n    WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("katahiromz's MWindowBase Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n    }\r\n\r\n    BOOL RegisterClassDx();\r\n\r\n    BOOL CreateWindowDx(HWND hwndParent, LPCTSTR pszText,\r\n                        DWORD Style = WS_OVERLAPPEDWINDOW, DWORD ExStyle = 0,\r\n                        INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,\r\n                        INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT,\r\n                        HMENU hMenu = NULL);\r\n    BOOL CreateAsChildDx(HWND hwndParent, LPCTSTR pszText,\r\n                         DWORD Style = WS_CHILD | WS_VISIBLE,\r\n                         DWORD ExStyle = 0, INT nCtrlID = -1,\r\n                         INT x = CW_USEDEFAULT, INT y = CW_USEDEFAULT,\r\n                         INT cx = CW_USEDEFAULT, INT cy = CW_USEDEFAULT);\r\n\r\n    BOOL Attach(HWND hwnd)\r\n    {\r\n        MWindowBase *pwndSub = GetUserData(hwnd);\r\n        m_hwnd = hwnd;\r\n        SetUserData(m_hwnd, this);\r\n        m_pwndSub = pwndSub;\r\n        return m_hwnd != NULL;\r\n    }\r\n\r\n    HWND Detach()\r\n    {\r\n        HWND hwnd = m_hwnd;\r\n        SetUserData(hwnd, m_pwndSub);\r\n        m_hwnd = NULL;\r\n        m_pwndSub = NULL;\r\n        return hwnd;\r\n    }\r\n\r\n    virtual void PostSubclassDx(HWND hwnd)\r\n    {\r\n    }\r\n\r\n    BOOL SubclassDx(HWND hwnd)\r\n    {\r\n        Attach(hwnd);\r\n        if (!m_pwndSub)\r\n        {\r\n            m_fnOldProc = SubclassWindow(hwnd, MWindowBase::WindowProc);\r\n        }\r\n        PostSubclassDx(hwnd);\r\n        return m_pwndSub || m_fnOldProc;\r\n    }\r\n\r\n    VOID UnsubclassDx()\r\n    {\r\n        SubclassWindow(m_hwnd, m_fnOldProc);\r\n        SetUserData(m_hwnd, m_pwndSub);\r\n        m_fnOldProc = NULL;\r\n    }\r\n\r\n    BOOL SubclassChildDx(MWindowBase& child, UINT nItemID)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return child.SubclassDx(::GetDlgItem(m_hwnd, nItemID));\r\n    }\r\n\r\n    INT MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,\r\n                 UINT uType = MB_ICONINFORMATION);\r\n\r\n    INT MsgBoxDx(UINT nStringID, UINT nTitleID, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), MAKEINTRESOURCE(nTitleID), uType);\r\n    }\r\n\r\n    INT MsgBoxDx(UINT nStringID, LPCTSTR pszTitle, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), pszTitle, uType);\r\n    }\r\n\r\n    INT MsgBoxDx(UINT nStringID, UINT uType)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), NULL, uType);\r\n    }\r\n\r\n    INT MsgBoxDx(LPCTSTR pszString, UINT uType)\r\n    {\r\n        return MsgBoxDx(pszString, NULL, uType);\r\n    }\r\n\r\n    INT ErrorBoxDx(UINT nStringID, UINT uType = MB_ICONERROR)\r\n    {\r\n        return MsgBoxDx(MAKEINTRESOURCE(nStringID), TEXT("ERROR"), uType);\r\n    }\r\n    INT ErrorBoxDx(LPCTSTR pszString, UINT uType = MB_ICONERROR)\r\n    {\r\n        return MsgBoxDx(pszString, TEXT("ERROR"), uType);\r\n    }\r\n\r\n    VOID CenterWindowDx() const\r\n    {\r\n        CenterWindowDx(m_hwnd);\r\n    }\r\n\r\n    static INT GetWindowTextLength(HWND hwnd)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetWindowTextLength(hwnd);\r\n    }\r\n    INT GetWindowTextLength() const\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::GetWindowTextLength(Handle());\r\n    }\r\n\r\n    static MString GetWindowText(HWND hwnd);\r\n    static INT GetWindowText(HWND hwnd, LPTSTR pszText, INT cchMax)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetWindowText(hwnd, pszText, cchMax);\r\n    }\r\n    MString GetWindowText() const\r\n    {\r\n        return GetWindowText(m_hwnd);\r\n    }\r\n\r\n    static UINT GetDlgItemText(HWND hwnd, INT nCtrlID, LPTSTR psz, INT cchMax)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetDlgItemText(hwnd, nCtrlID, psz, cchMax);\r\n    }\r\n    static MString GetDlgItemText(HWND hwnd, INT nCtrlID)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return GetWindowText(::GetDlgItem(hwnd, nCtrlID));\r\n    }\r\n    MString GetDlgItemText(INT nCtrlID) const\r\n    {\r\n        return GetWindowText(::GetDlgItem(m_hwnd, nCtrlID));\r\n    }\r\n\r\n    static BOOL SetWindowText(HWND hwnd, LPCTSTR pszText = NULL)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::SetWindowText(hwnd, pszText);\r\n    }\r\n    BOOL SetWindowText(LPCTSTR pszText = NULL)\r\n    {\r\n        return SetWindowText(Handle(), pszText);\r\n    }\r\n\r\n    static VOID CenterWindowDx(HWND hwnd);\r\n\r\n    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, POINT *ppt = NULL, SIZE *psiz = NULL);\r\n    static BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc);\r\n\r\n    BOOL MZCAPI GetWindowPosDx(POINT *ppt = NULL, SIZE *psiz = NULL);\r\n    BOOL MZCAPI GetWindowPosDx(RECT *prc);\r\n\r\n    static BOOL SetWindowPosDx(HWND hwnd,\r\n                               LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n                               HWND hwndInsertAfter = NULL,\r\n                               UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\n    static BOOL SetWindowPosDx(HWND hwnd, const RECT *prc);\r\n\r\n    BOOL SetWindowPosDx(LPPOINT ppt = NULL, LPSIZE psiz = NULL,\r\n                        HWND hwndInsertAfter = NULL,\r\n                        UINT uFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER);\r\n    BOOL SetWindowPosDx(const RECT *prc);\r\n\r\n    static HWND GetAncestorDx(HWND hTarget);\r\n    HWND GetAncestorDx() const\r\n    {\r\n        return GetAncestorDx(m_hwnd);\r\n    }\r\n\r\n    HICON LoadIconDx(INT id)\r\n    {\r\n        return LoadIcon(GetModuleHandle(NULL), MAKEINTRESOURCE(id));\r\n    }\r\n\r\n    HICON LoadSmallIconDx(UINT id)\r\n    {\r\n        INT cxSmall = GetSystemMetrics(SM_CXSMICON);\r\n        INT cySmall = GetSystemMetrics(SM_CYSMICON);\r\n        return HICON(LoadImage(GetModuleHandle(NULL), \r\n                               MAKEINTRESOURCE(id),\r\n                               IMAGE_ICON, cxSmall, cySmall, 0));\r\n    }\r\n\r\n    HFONT GetFontDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowFont(m_hwnd);\r\n    }\r\n    void SetFontDx(HFONT hFont, BOOL bRedraw = TRUE)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        SetWindowFont(m_hwnd, hFont, bRedraw);\r\n    }\r\n    DWORD GetStyleDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowStyle(m_hwnd);\r\n    }\r\n    DWORD SetStyleDx(DWORD dwNewStyle)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return SetWindowLong(m_hwnd, GWL_STYLE, dwNewStyle);\r\n    }\r\n    void ModifyStyleDx(DWORD dwRemove, DWORD dwAdd)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        DWORD style = GetStyleDx();\r\n        style &= ~dwRemove;\r\n        style |= dwAdd;\r\n        SetStyleDx(style);\r\n    }\r\n    DWORD GetExStyleDx() const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return GetWindowExStyle(m_hwnd);\r\n    }\r\n    DWORD SetExStyleDx(DWORD dwNewExStyle)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return SetWindowLong(m_hwnd, GWL_EXSTYLE, dwNewExStyle);\r\n    }\r\n    void ModifyExStyleDx(DWORD dwRemove, DWORD dwAdd)\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        DWORD exstyle = GetExStyleDx();\r\n        exstyle &= ~dwRemove;\r\n        exstyle |= dwAdd;\r\n        SetExStyleDx(exstyle);\r\n    }\r\n\r\n    HWND GetChildDx(HWND hwndChild) const\r\n    {\r\n        return hwndChild;\r\n    }\r\n    HWND GetChildDx(UINT id) const\r\n    {\r\n        return ::GetDlgItem(m_hwnd, id);\r\n    }\r\n    UINT GetCtrlIDDx(HWND hwndChild) const\r\n    {\r\n        return ::GetDlgCtrlID(hwndChild);\r\n    }\r\n    UINT GetCtrlIDDx(UINT nChildID) const\r\n    {\r\n        return nChildID;\r\n    }\r\n\r\n    LRESULT SendMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return ::SendMessage(m_hwnd, uMsg, wParam, lParam);\r\n    }\r\n    BOOL PostMessageDx(UINT uMsg, WPARAM wParam = 0, LPARAM lParam = 0) const\r\n    {\r\n        assert(::IsWindow(m_hwnd));\r\n        return ::PostMessage(m_hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    static HHOOK HookCenterMsgBoxDx(BOOL bHook);\r\n\r\nprivate:\r\n    static inline LRESULT CALLBACK\r\n    _msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam);\r\n\r\n#ifdef MZC4_FAT_AND_RICH\r\npublic:\r\n    #include "MWindowBaseRichMethods.hpp"\r\n#endif\r\n\r\npublic:\r\n    // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC\r\n    typedef MWindowBase *(*FNCREATEINSTANCEDX)();\r\n    typedef std::map<MString, FNCREATEINSTANCEDX> class_to_create_map_t;\r\n\r\n    static class_to_create_map_t& ClassToCreateMap()\r\n    {\r\n        static class_to_create_map_t s_class_to_create_map;\r\n        return s_class_to_create_map;\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC\r\n\r\n#define DECLARE_DYNAMIC(class_name) \\\r\n    static MWindowBase *CreateInstanceDx();\r\n\r\n#define IMPLEMENT_DYNAMIC(class_name) \\\r\n    /*static*/ MWindowBase *class_name::CreateInstanceDx() \\\r\n    { \\\r\n        return new class_name(); \\\r\n    } \\\r\n    struct class_name##AutoDynamicRegister \\\r\n    { \\\r\n        class_name##AutoDynamicRegister() \\\r\n        { \\\r\n            MWindowBase::ClassToCreateMap()[TEXT(#class_name)] = &class_name::CreateInstanceDx; \\\r\n        } \\\r\n    } class_name##AutoDynamicRegister##__LINE__;\r\n\r\n#define IMPLEMENT_DYNAMIC2(class_name, wndclass_name) \\\r\n    /*static*/ MWindowBase *class_name::CreateInstanceDx() \\\r\n    { \\\r\n        return new class_name(); \\\r\n    } \\\r\n    struct class_name##AutoDynamicRegister \\\r\n    { \\\r\n        class_name##AutoDynamicRegister() \\\r\n        { \\\r\n            MWindowBase::ClassToCreateMap()[TEXT(#wndclass_name)] = &class_name::CreateInstanceDx; \\\r\n        } \\\r\n    } class_name##AutoDynamicRegister##__LINE__;\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\nclass MDialogBase : public MWindowBase\r\n{\r\npublic:\r\n    BOOL    m_bModal;\r\n    HWND    m_hwndOwner;\r\n    LPCTSTR m_pDialogName;\r\n\r\n    MDialogBase() : m_bModal(FALSE), m_hwndOwner(NULL), m_pDialogName(NULL)\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner), m_pDialogName(NULL)\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner, INT nDialogID)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner),\r\n          m_pDialogName(MAKEINTRESOURCE(nDialogID))\r\n    {\r\n    }\r\n\r\n    MDialogBase(HWND hwndOwner, LPCTSTR pDialogName)\r\n        : m_bModal(FALSE), m_hwndOwner(hwndOwner),\r\n          m_pDialogName(pDialogName)\r\n    {\r\n    }\r\n\r\n    MDialogBase(INT nDialogID)\r\n        : m_bModal(FALSE), m_hwndOwner(NULL),\r\n          m_pDialogName(MAKEINTRESOURCE(nDialogID))\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("#32770");\r\n    }\r\n\r\n    virtual LRESULT MZCAPI\r\n    DefaultProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    LRESULT MZCAPI DefaultProcDx()\r\n    {\r\n        return DefaultProcDx(m_msg.hwnd, m_msg.message, m_msg.wParam, m_msg.lParam);\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    static INT_PTR CALLBACK\r\n    DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\n    static MDialogBase *GetUserData(HWND hwnd)\r\n    {\r\n        return (MDialogBase *)GetWindowLongPtr(hwnd, DWLP_USER);\r\n    }\r\n    static VOID SetUserData(HWND hwnd, VOID *ptr)\r\n    {\r\n        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)ptr);\r\n    }\r\n\r\n    BOOL CreateDialogDx(HWND hwndOwner, INT nDialogID);\r\n    BOOL CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName);\r\n    INT_PTR DialogBoxDx(HWND hwndOwner, INT nDialogID);\r\n    INT_PTR DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName);\r\n    BOOL CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr);\r\n    INT_PTR DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr);\r\n\r\n    BOOL CreateDialogDx(HWND hwndOwner)\r\n    {\r\n        return CreateDialogDx(hwndOwner, m_pDialogName);\r\n    }\r\n\r\n    INT_PTR DialogBoxDx(HWND hwndOwner)\r\n    {\r\n        return DialogBoxDx(hwndOwner, m_pDialogName);\r\n    }\r\n\r\n    DWORD GetDefID() const\r\n    {\r\n        return (DWORD)SendMessageDx(DM_GETDEFID);\r\n    }\r\n    BOOL SetDefID(UINT nID)\r\n    {\r\n        return (BOOL)SendMessageDx(DM_SETDEFID, (WPARAM)nID);\r\n    }\r\n\r\n    BOOL EndDialog(INT_PTR nResult)\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::EndDialog(Handle(), nResult);\r\n    }\r\n    static BOOL EndDialog(HWND hwnd, INT_PTR nResult)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::EndDialog(hwnd, nResult);\r\n    }\r\n\r\n    VOID NextDlgCtrl() const\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, FALSE);\r\n    }\r\n    VOID PrevDlgCtrl() const\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, TRUE);\r\n    }\r\n    VOID GotoDlgCtrl(HWND hwndCtrl)\r\n    {\r\n        PostMessageDx(WM_NEXTDLGCTL, (WPARAM)hwndCtrl, 1);\r\n    }\r\n\r\n    BOOL MapDialogRect(LPRECT prc) const\r\n    {\r\n        assert(IsWindow(Handle()));\r\n        return ::MapDialogRect(Handle(), prc);\r\n    }\r\n    static BOOL MapDialogRect(HWND hwnd, LPRECT prc)\r\n    {\r\n        assert(IsWindow(hwnd));\r\n        return ::MapDialogRect(hwnd, prc);\r\n    }\r\n\r\n    BOOL IsDialogMessage(LPMSG pMsg)\r\n    {\r\n        return ::IsDialogMessage(Handle(), pMsg);\r\n    }\r\n\r\n    BOOL Attach(HWND hwnd)\r\n    {\r\n        m_hwnd = hwnd;\r\n        SetUserData(m_hwnd, this);\r\n        return m_hwnd != NULL;\r\n    }\r\n\r\n    HWND Detach()\r\n    {\r\n        HWND hwnd = m_hwnd;\r\n        SetUserData(hwnd, NULL);\r\n        m_hwnd = NULL;\r\n        return hwnd;\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// public inline functions\r\n\r\ninline VOID MZCAPIV DebugPrintDx(const char *format, ...)\r\n{\r\n    #ifndef NDEBUG\r\n        char szBuff[512];\r\n        va_list va;\r\n        va_start(va, format);\r\n#ifdef NO_STRSAFE\r\n        wsprintfA(szBuff, format, va);\r\n#else\r\n        StringCchVPrintfA(szBuff, _countof(szBuff), format, va);\r\n#endif\r\n        va_end(va);\r\n        OutputDebugStringA(szBuff);\r\n    #endif\r\n}\r\n\r\ninline VOID MZCAPIV DebugPrintDx(const WCHAR *format, ...)\r\n{\r\n    #ifndef NDEBUG\r\n        WCHAR szBuff[512];\r\n        va_list va;\r\n        va_start(va, format);\r\n#ifdef NO_STRSAFE\r\n        wsprintfW(szBuff, format, va);\r\n#else\r\n        StringCchVPrintfW(szBuff, _countof(szBuff), format, va);\r\n#endif\r\n        va_end(va);\r\n        OutputDebugStringW(szBuff);\r\n    #endif\r\n}\r\n\r\ninline RECT MZCAPI GetVirtualScreenRectDx()\r\n{\r\n    RECT rc;\r\n#ifndef SM_XVIRTUALSCREEN\r\n    #define SM_XVIRTUALSCREEN   76\r\n    #define SM_YVIRTUALSCREEN   77\r\n    #define SM_CXVIRTUALSCREEN  78\r\n    #define SM_CYVIRTUALSCREEN  79\r\n#endif\r\n    INT x = ::GetSystemMetrics(SM_XVIRTUALSCREEN);\r\n    INT y = ::GetSystemMetrics(SM_YVIRTUALSCREEN);\r\n    INT cx = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);\r\n    INT cy = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);\r\n    if (cx == 0)\r\n        cx = ::GetSystemMetrics(SM_CXSCREEN);\r\n    if (cy == 0)\r\n        cy = ::GetSystemMetrics(SM_CYSCREEN);\r\n    SetRect(&rc, x, y, x + cx, y + cy);\r\n    return rc;\r\n}\r\n\r\ninline VOID MZCAPI RepositionPointDx(LPPOINT ppt, SIZE siz, LPCRECT prc)\r\n{\r\n    if (ppt->x + siz.cx > prc->right)\r\n        ppt->x = prc->right - siz.cx;\r\n    if (ppt->y + siz.cy > prc->bottom)\r\n        ppt->y = prc->bottom - siz.cy;\r\n    if (ppt->x < prc->left)\r\n        ppt->x = prc->left;\r\n    if (ppt->y < prc->top)\r\n        ppt->y = prc->top;\r\n}\r\n\r\ninline RECT MZCAPI WorkAreaFromWindowDx(HWND hwnd)\r\n{\r\n#if (WINVER >= 0x0500)\r\n    MONITORINFO mi;\r\n    mi.cbSize = sizeof(mi);\r\n    HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);\r\n    if (GetMonitorInfo(hMonitor, &mi))\r\n    {\r\n        return mi.rcWork;\r\n    }\r\n#endif\r\n    RECT rc;\r\n    ::SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);\r\n    return rc;\r\n}\r\n\r\ninline SIZE MZCAPI SizeFromRectDx(LPCRECT prc)\r\n{\r\n    SIZE siz;\r\n    siz.cx = prc->right - prc->left;\r\n    siz.cy = prc->bottom - prc->top;\r\n    return siz;\r\n}\r\n\r\ninline LPTSTR MZCAPI LoadStringDx(INT nID)\r\n{\r\n    static UINT s_index = 0;\r\n    const UINT cchBuffMax = 1024;\r\n    static TCHAR s_sz[4][cchBuffMax];\r\n\r\n    TCHAR *pszBuff = s_sz[s_index];\r\n    s_index = (s_index + 1) % _countof(s_sz);\r\n    pszBuff[0] = 0;\r\n    if (!::LoadString(NULL, nID, pszBuff, cchBuffMax))\r\n        assert(0);\r\n    return pszBuff;\r\n}\r\n\r\ninline LPTSTR MZCAPI LoadStringVPrintfDx(INT nID, va_list va)\r\n{\r\n    static UINT s_index = 0;\r\n    const UINT cchBuffMax = 1024;\r\n    static TCHAR s_sz[4][cchBuffMax];\r\n\r\n    TCHAR *pszBuff = s_sz[s_index];\r\n    s_index = (s_index + 1) % _countof(s_sz);\r\n    pszBuff[0] = 0;\r\n#ifdef NO_STRSAFE\r\n    wvsprintf(pszBuff, LoadStringDx(nID), va);\r\n#else\r\n    StringCchVPrintf(pszBuff, cchBuffMax, LoadStringDx(nID), va);\r\n#endif\r\n    return pszBuff;\r\n}\r\n\r\ninline LPTSTR MZCAPIV LoadStringPrintfDx(INT nID, ...)\r\n{\r\n    va_list va;\r\n    va_start(va, nID);\r\n    LPTSTR psz = LoadStringVPrintfDx(nID, va);\r\n    va_end(va);\r\n    return psz;\r\n}\r\n\r\ninline LPCTSTR MZCAPI GetStringDx(LPCTSTR psz)\r\n{\r\n    if (psz == NULL)\r\n        return NULL;\r\n    if (IS_INTRESOURCE(psz))\r\n        return LoadStringDx(LOWORD(psz));\r\n    return psz;\r\n}\r\n\r\ninline LPCTSTR MZCAPI GetStringDx(INT nStringID)\r\n{\r\n    return LoadStringDx(nStringID);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nGetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    RECT rc;\r\n    if (!GetWindowRect(hwnd, &rc))\r\n        return FALSE;\r\n\r\n    if (ppt)\r\n    {\r\n        ppt->x = rc.left;\r\n        ppt->y = rc.top;\r\n        if (GetWindowStyle(hwnd) & WS_CHILD)\r\n        {\r\n            MapWindowPoints(NULL, GetParent(hwnd), ppt, 1);\r\n        }\r\n    }\r\n    if (psiz)\r\n    {\r\n        psiz->cx = rc.right - rc.left;\r\n        psiz->cy = rc.bottom - rc.top;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MZCAPI GetWindowPosDx(HWND hwnd, RECT *prc)\r\n{\r\n    POINT pt;\r\n    SIZE siz;\r\n    if (!GetWindowPosDx(hwnd, &pt, &siz))\r\n        return FALSE;\r\n    prc->left = pt.x;\r\n    prc->top = pt.y;\r\n    prc->right = pt.x + siz.cx;\r\n    prc->bottom = pt.x + siz.cy;\r\n    return TRUE;\r\n}\r\n\r\ninline BOOL MZCAPI\r\nSetWindowPosDx(HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    if (hwndInsertAfter == NULL)\r\n    {\r\n        uFlags |= SWP_NOZORDER;\r\n    }\r\n\r\n    INT x = 0, y = 0;\r\n    if (ppt == NULL)\r\n    {\r\n        uFlags |= SWP_NOMOVE;\r\n    }\r\n    else\r\n    {\r\n        x = ppt->x;\r\n        y = ppt->y;\r\n    }\r\n\r\n    INT cx = 0, cy = 0;\r\n    if (psiz == NULL)\r\n    {\r\n        uFlags |= SWP_NOSIZE;\r\n    }\r\n    else\r\n    {\r\n        cx = psiz->cx;\r\n        cy = psiz->cy;\r\n    }\r\n\r\n    return ::SetWindowPos(hwnd, hwndInsertAfter, x, y, cx, cy, uFlags);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nSetWindowPosDx(HWND hwnd, const RECT *prc)\r\n{\r\n    assert(prc);\r\n    POINT pt;\r\n    SIZE siz;\r\n    pt.x = prc->left;\r\n    pt.y = prc->top;\r\n    siz.cx = prc->right - prc->left;\r\n    siz.cy = prc->bottom - prc->top;\r\n    return ::SetWindowPosDx(hwnd, &pt, &siz);\r\n}\r\n\r\ninline LPSTR MZCAPI MakeFilterDx(LPSTR psz)\r\n{\r\n    for (LPSTR pch = psz; *pch; ++pch)\r\n    {\r\n        if (*pch == '|')\r\n            *pch = 0;\r\n    }\r\n    return psz;\r\n}\r\n\r\ninline LPWSTR MZCAPI MakeFilterDx(LPWSTR psz)\r\n{\r\n    for (LPWSTR pch = psz; *pch; ++pch)\r\n    {\r\n        if (*pch == L'|')\r\n            *pch = 0;\r\n    }\r\n    return psz;\r\n}\r\n\r\ninline HBITMAP MZCAPI Create24BppBitmapDx(INT width, INT height)\r\n{\r\n    BITMAPINFO bi;\r\n    ZeroMemory(&bi, sizeof(bi));\r\n    bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\r\n    bi.bmiHeader.biWidth = width;\r\n    bi.bmiHeader.biHeight = height;\r\n    bi.bmiHeader.biPlanes = 1;\r\n    bi.bmiHeader.biBitCount = 24;\r\n    bi.bmiHeader.biCompression = BI_RGB;\r\n    HDC hDC = CreateCompatibleDC(NULL);\r\n    LPVOID pvBits;\r\n    HBITMAP hbm = CreateDIBSection(hDC, &bi, DIB_RGB_COLORS,\r\n                                   &pvBits, NULL, 0);\r\n    DeleteDC(hDC);\r\n    return hbm;\r\n}\r\n\r\ninline void MZCAPI FillBitmapDx(HBITMAP hbm, HBRUSH hbr)\r\n{\r\n    BITMAP bm;\r\n    if (!GetObject(hbm, sizeof(bm), &bm))\r\n        return;\r\n\r\n    HDC hDC = CreateCompatibleDC(NULL);\r\n    {\r\n        HGDIOBJ hbmOld = SelectObject(hDC, hbm);\r\n        {\r\n            RECT rc;\r\n            SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);\r\n            FillRect(hDC, &rc, hbr);\r\n            DeleteObject(hbr);\r\n        }\r\n        SelectObject(hDC, hbmOld);\r\n    }\r\n    DeleteDC(hDC);\r\n}\r\n\r\ninline void MZCAPI\r\nPremultiplyDx(HBITMAP hbm32bpp)\r\n{\r\n    BITMAP bm;\r\n    DWORD cdw;\r\n    LPBYTE pb;\r\n    BYTE alpha;\r\n    GetObject(hbm32bpp, sizeof(bm), &bm);\r\n    if (bm.bmBitsPixel == 32)\r\n    {\r\n        cdw = bm.bmWidth * bm.bmHeight;\r\n        pb = (LPBYTE) bm.bmBits;\r\n        while (cdw--)\r\n        {\r\n            alpha = pb[3];\r\n            pb[0] = (BYTE) ((DWORD) pb[0] * alpha / 255);\r\n            pb[1] = (BYTE) ((DWORD) pb[1] * alpha / 255);\r\n            pb[2] = (BYTE) ((DWORD) pb[2] * alpha / 255);\r\n            pb += 4;\r\n        }\r\n    }\r\n}\r\n\r\ninline BOOL MZCAPI CopyTextDx(HWND hwnd, const MString& text)\r\n{\r\n#ifdef UNICODE\r\n    UINT CF_ = CF_UNICODETEXT;\r\n#else\r\n    UINT CF_ = CF_TEXT;\r\n#endif\r\n    DWORD size = DWORD((text.size() + 1) * sizeof(TCHAR));\r\n    LPTSTR psz = (LPTSTR)GlobalAllocPtr(GMEM_SHARE | GMEM_MOVEABLE, size);\r\n    if (psz)\r\n    {\r\n        HGLOBAL hGlobal = GlobalPtrHandle(psz);\r\n        CopyMemory(psz, text.c_str(), size);\r\n        GlobalUnlockPtr(psz);\r\n\r\n        if (OpenClipboard(hwnd))\r\n        {\r\n            EmptyClipboard();\r\n            SetClipboardData(CF_, hGlobal);\r\n            return CloseClipboard();\r\n        }\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline void MZCAPI\r\nPopupMenuDx(HWND hwnd, HWND hContext, UINT nMenuID, INT iSubMenu, INT x, INT y)\r\n{\r\n    HMENU hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(nMenuID));\r\n    HMENU hSubMenu = GetSubMenu(hMenu, iSubMenu);\r\n\r\n    if (x == 0xFFFF && y == 0xFFFF)\r\n    {\r\n        RECT rc;\r\n        GetWindowRect(hContext, &rc);\r\n        x = rc.left;\r\n        y = rc.top;\r\n    }\r\n\r\n    SetForegroundWindow(hwnd);\r\n    TrackPopupMenu(hSubMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON,\r\n        x, y, 0, hwnd, NULL);\r\n    PostMessage(hwnd, WM_NULL, 0, 0);\r\n    DestroyMenu(hMenu);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\ninline VOID\r\nMWindowBase::SaveMessageDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    m_msg.hwnd = hwnd;\r\n    m_msg.message = uMsg;\r\n    m_msg.wParam = wParam;\r\n    m_msg.lParam = lParam;\r\n    m_msg.time = GetMessageTime();\r\n    LONG nPos = GetMessagePos();\r\n    m_msg.pt.x = GET_X_LPARAM(nPos);\r\n    m_msg.pt.y = GET_Y_LPARAM(nPos);\r\n}\r\n\r\ninline /*static*/ LRESULT CALLBACK\r\nMWindowBase::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n {\r\n    MWindowBase *base;\r\n    if (uMsg == WM_CREATE)\r\n    {\r\n        TCHAR szClass[128];\r\n        GetClassName(hwnd, szClass, _countof(szClass));\r\n\r\n        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;\r\n        if (pcs->lpCreateParams &&\r\n            !IsBadReadPtr(pcs->lpCreateParams, sizeof(MWindowBase)) &&\r\n            ((MWindowBase*)(pcs->lpCreateParams))->m_dwWindowBaseMagic == 0xFEEDFEED)\r\n        {\r\n            base = reinterpret_cast<MWindowBase *>(pcs->lpCreateParams);\r\n            base->m_hwnd = hwnd;\r\n        }\r\n        else\r\n        {\r\n            // for DECLARE_DYNAMIC/IMPLEMENT_DYNAMIC\r\n            class_to_create_map_t::const_iterator it;\r\n            it = MWindowBase::ClassToCreateMap().find(szClass);\r\n            if (it == MWindowBase::ClassToCreateMap().end())\r\n            {\r\n                assert(0);\r\n                return 0;\r\n            }\r\n\r\n            base = (*it->second)();\r\n            base->m_bDynamicCreated = true;\r\n            base->Attach(hwnd);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        base = GetUserData(hwnd);\r\n    }\r\n\r\n    LRESULT ret = 0;\r\n    if (base)\r\n    {\r\n#ifndef NDEBUG\r\n        TCHAR szClass[128];\r\n        GetClassName(hwnd, szClass, _countof(szClass));\r\n#endif\r\n        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);\r\n        ret = base->WindowProcDx(hwnd, uMsg, wParam, lParam);\r\n\r\n        if (uMsg == WM_NCDESTROY)\r\n        {\r\n            base->PostNcDestroy();\r\n        }\r\n    }\r\n    else\r\n    {\r\n        ret = ::DefWindowProc(hwnd, uMsg, wParam, lParam);\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline BOOL MWindowBase::RegisterClassDx()\r\n{\r\n    HMODULE hMod = ::GetModuleHandle(NULL);\r\n\r\n    WNDCLASSEX wcx;\r\n    LPCTSTR pszClass = GetWndClassNameDx();\r\n    if (::GetClassInfoEx(NULL, pszClass, &wcx) ||\r\n        ::GetClassInfoEx(hMod, pszClass, &wcx))\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    ZeroMemory(&wcx, sizeof(wcx));\r\n    wcx.cbSize = sizeof(wcx);\r\n    wcx.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;\r\n    wcx.lpfnWndProc = MWindowBase::WindowProc;\r\n    wcx.hInstance = hMod;\r\n    wcx.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);\r\n    wcx.hCursor = ::LoadCursor(NULL, IDC_ARROW);\r\n    wcx.hbrBackground = ::GetSysColorBrush(COLOR_3DFACE);\r\n    wcx.lpszMenuName = NULL;\r\n    wcx.lpszClassName = pszClass;\r\n    wcx.hIconSm = ::LoadIcon(NULL, IDI_APPLICATION);\r\n\r\n    ModifyWndClassDx(wcx);\r\n\r\n    return ::RegisterClassEx(&wcx);\r\n}\r\n\r\ninline BOOL MWindowBase::CreateWindowDx(\r\n    HWND hwndParent, LPCTSTR pszText,\r\n    DWORD Style/* = WS_OVERLAPPEDWINDOW*/, DWORD ExStyle/* = 0*/,\r\n    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,\r\n    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/,\r\n    HMENU hMenu/* = NULL*/)\r\n{\r\n    if (!RegisterClassDx())\r\n        return FALSE;\r\n\r\n    HWND hwnd = ::CreateWindowEx(ExStyle, GetWndClassNameDx(),\r\n        GetStringDx(pszText), Style, x, y, cx, cy, hwndParent,\r\n        hMenu, GetModuleHandle(NULL), this);\r\n    return Attach(hwnd);\r\n}\r\n\r\ninline BOOL\r\nMWindowBase::CreateAsChildDx(\r\n    HWND hwndParent, LPCTSTR pszText,\r\n    DWORD Style/* = WS_CHILD | WS_VISIBLE*/,\r\n    DWORD ExStyle/* = 0*/, INT nCtrlID/* = -1*/,\r\n    INT x/* = CW_USEDEFAULT*/, INT y/* = CW_USEDEFAULT*/,\r\n    INT cx/* = CW_USEDEFAULT*/, INT cy/* = CW_USEDEFAULT*/)\r\n{\r\n    Style |= WS_CHILD;\r\n    return CreateWindowDx(hwndParent, pszText, Style, ExStyle,\r\n        x, y, cx, cy, (HMENU)(INT_PTR)nCtrlID);\r\n}\r\n\r\ninline INT\r\nMWindowBase::MsgBoxDx(LPCTSTR pszString, LPCTSTR pszTitle,\r\n                      UINT uType/* = MB_ICONINFORMATION*/)\r\n{\r\n    MString Title;\r\n    if (pszTitle == NULL)\r\n    {\r\n#ifdef IDS_APPNAME\r\n        Title = LoadStringDx(IDS_APPNAME);\r\n#else\r\n        if (m_hwnd)\r\n        {\r\n            Title = GetWindowText(GetAncestorDx());\r\n            size_t i = Title.find(TEXT(" - "));\r\n            if (i != MString::npos)\r\n            {\r\n                Title = Title.substr(i + 3);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Title = TEXT("ERROR");\r\n        }\r\n#endif\r\n    }\r\n    else\r\n    {\r\n        Title = GetStringDx(pszTitle);\r\n    }\r\n\r\n    MWindowBase::HookCenterMsgBoxDx(TRUE);\r\n    INT nID = ::MessageBox(m_hwnd, GetStringDx(pszString),\r\n                           Title.c_str(), uType);\r\n    MWindowBase::HookCenterMsgBoxDx(FALSE);\r\n\r\n    return nID;\r\n}\r\n\r\ninline /*static*/ MString MWindowBase::GetWindowText(HWND hwnd)\r\n{\r\n    INT cch = ::GetWindowTextLength(hwnd);\r\n    MString ret;\r\n    ret.resize(cch);\r\n    if (!::GetWindowText(hwnd, &ret[0], cch + 1))\r\n        ret.clear();\r\n    return ret;\r\n}\r\n\r\ninline /*static*/ VOID MWindowBase::CenterWindowDx(HWND hwnd)\r\n{\r\n    assert(IsWindow(hwnd));\r\n\r\n    BOOL bChild = !!(GetWindowStyle(hwnd) & WS_CHILD);\r\n\r\n    HWND hwndParent;\r\n    if (bChild)\r\n        hwndParent = ::GetParent(hwnd);\r\n    else\r\n        hwndParent = ::GetWindow(hwnd, GW_OWNER);\r\n\r\n    RECT rcWorkArea = WorkAreaFromWindowDx(hwnd);\r\n\r\n    RECT rcParent;\r\n    if (hwndParent)\r\n        ::GetWindowRect(hwndParent, &rcParent);\r\n    else\r\n        rcParent = rcWorkArea;\r\n\r\n    SIZE sizParent = SizeFromRectDx(&rcParent);\r\n\r\n    RECT rc;\r\n    ::GetWindowRect(hwnd, &rc);\r\n    SIZE siz = SizeFromRectDx(&rc);\r\n\r\n    POINT pt;\r\n    pt.x = rcParent.left + (sizParent.cx - siz.cx) / 2;\r\n    pt.y = rcParent.top + (sizParent.cy - siz.cy) / 2;\r\n\r\n    if (bChild && hwndParent)\r\n    {\r\n        ::GetClientRect(hwndParent, &rcParent);\r\n        ::MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);\r\n        RepositionPointDx(&pt, siz, &rcParent);\r\n\r\n        ::ScreenToClient(hwndParent, &pt);\r\n    }\r\n    else\r\n    {\r\n        RepositionPointDx(&pt, siz, &rcWorkArea);\r\n    }\r\n\r\n    ::SetWindowPos(hwnd, NULL, pt.x, pt.y, 0, 0,\r\n                   SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);\r\n}\r\n\r\ninline /*static*/ BOOL MZCAPI\r\nMWindowBase::GetWindowPosDx(HWND hwnd, POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::GetWindowPosDx(hwnd, ppt, psiz);\r\n}\r\n\r\ninline BOOL MZCAPI\r\nMWindowBase::GetWindowPosDx(POINT *ppt/* = NULL*/, SIZE *psiz/* = NULL*/)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::GetWindowPosDx(m_hwnd, ppt, psiz);\r\n}\r\n\r\ninline /*static*/ BOOL MZCAPI MWindowBase::GetWindowPosDx(HWND hwnd, RECT *prc)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::GetWindowPosDx(hwnd, prc);\r\n}\r\n\r\ninline BOOL MZCAPI MWindowBase::GetWindowPosDx(RECT *prc)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::GetWindowPosDx(m_hwnd, prc);\r\n}\r\n\r\ninline /*static*/ BOOL\r\nMWindowBase::SetWindowPosDx(\r\n    HWND hwnd, LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::SetWindowPosDx(hwnd, ppt, psiz, hwndInsertAfter, uFlags);\r\n}\r\n\r\ninline /*static*/ BOOL MWindowBase::SetWindowPosDx(HWND hwnd, const RECT *prc)\r\n{\r\n    assert(IsWindow(hwnd));\r\n    return ::SetWindowPosDx(hwnd, prc);\r\n}\r\n\r\ninline BOOL\r\nMWindowBase::SetWindowPosDx(\r\n    LPPOINT ppt/* = NULL*/, LPSIZE psiz/* = NULL*/,\r\n    HWND hwndInsertAfter/* = NULL*/,\r\n    UINT uFlags/* = SWP_NOACTIVATE | SWP_NOOWNERZORDER*/)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::SetWindowPosDx(m_hwnd, ppt, psiz, hwndInsertAfter, uFlags);\r\n}\r\n\r\ninline BOOL MWindowBase::SetWindowPosDx(const RECT *prc)\r\n{\r\n    assert(IsWindow(m_hwnd));\r\n    return ::SetWindowPosDx(m_hwnd, prc);\r\n}\r\n\r\ninline /*static*/ HWND MWindowBase::GetAncestorDx(HWND hTarget)\r\n{\r\n    HWND hwndParent;\r\n    for (;;)\r\n    {\r\n        hwndParent = ::GetParent(hTarget);\r\n        if (hwndParent == NULL)\r\n        {\r\n            hwndParent = ::GetWindow(hTarget, GW_OWNER);\r\n            if (hwndParent == NULL)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        hTarget = hwndParent;\r\n    }\r\n    return hTarget;\r\n}\r\n\r\n/*static*/ inline LRESULT CALLBACK\r\nMWindowBase::_msgBoxCbtProcDx(INT nCode, WPARAM wParam, LPARAM lParam)\r\n{\r\n#ifndef MZC_NO_CENTER_MSGBOX\r\n    if (nCode == HCBT_ACTIVATE)\r\n    {\r\n        HWND hwnd = (HWND)wParam;\r\n        TCHAR szClassName[16];\r\n        ::GetClassName(hwnd, szClassName, _countof(szClassName));\r\n        if (lstrcmpi(szClassName, TEXT("#32770")) == 0)\r\n        {\r\n            CenterWindowDx(hwnd);\r\n        }\r\n    }\r\n#endif  // ndef MZC_NO_CENTER_MSGBOX\r\n\r\n    return 0;   // allow the operation\r\n}\r\n\r\ninline /*static*/ HHOOK MWindowBase::HookCenterMsgBoxDx(BOOL bHook)\r\n{\r\n#ifdef MZC_NO_CENTER_MSGBOX\r\n    return NULL;\r\n#else   // ndef MZC_NO_CENTER_MSGBOX\r\n    static HHOOK s_hHook = NULL;\r\n    if (bHook)\r\n    {\r\n        if (s_hHook == NULL)\r\n        {\r\n            DWORD dwThreadID = GetCurrentThreadId();\r\n            s_hHook = ::SetWindowsHookEx(WH_CBT, _msgBoxCbtProcDx, NULL, dwThreadID);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if (s_hHook)\r\n        {\r\n            if (::UnhookWindowsHookEx(s_hHook))\r\n            {\r\n                s_hHook = NULL;\r\n            }\r\n        }\r\n    }\r\n    return s_hHook;\r\n#endif  // ndef MZC_NO_CENTER_MSGBOX\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\ninline /*static*/ INT_PTR CALLBACK\r\nMDialogBase::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    MDialogBase *base;\r\n    if (uMsg == WM_INITDIALOG)\r\n    {\r\n        assert(lParam);\r\n        base = (MDialogBase *)lParam;\r\n        base->Attach(hwnd);\r\n    }\r\n    else\r\n    {\r\n        base = GetUserData(hwnd);\r\n    }\r\n\r\n    INT_PTR ret = 0;\r\n    if (base)\r\n    {\r\n        base->SaveMessageDx(hwnd, uMsg, wParam, lParam);\r\n        ret = base->DialogProcDx(hwnd, uMsg, wParam, lParam);\r\n        if (uMsg == WM_NCDESTROY)\r\n        {\r\n            base->PostNcDestroy();\r\n        }\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\ninline BOOL MDialogBase::CreateDialogDx(HWND hwndOwner, INT nDialogID)\r\n{\r\n    return CreateDialogDx(hwndOwner, MAKEINTRESOURCE(nDialogID));\r\n}\r\n\r\ninline INT_PTR MDialogBase::DialogBoxDx(HWND hwndOwner, INT nDialogID)\r\n{\r\n    return DialogBoxDx(hwndOwner, MAKEINTRESOURCE(nDialogID));\r\n}\r\n\r\ninline BOOL\r\nMDialogBase::CreateDialogIndirectDx(HWND hwndOwner, const VOID *ptr)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = FALSE;\r\n    HWND hwnd = ::CreateDialogIndirectParam(::GetModuleHandle(NULL),\r\n        reinterpret_cast<const DLGTEMPLATE *>(ptr),\r\n        m_hwndOwner, MDialogBase::DialogProc,\r\n        reinterpret_cast<LPARAM>(this));\r\n    if (hwnd == NULL)\r\n    {\r\n        Detach();\r\n    }\r\n    return hwnd != NULL;\r\n}\r\n\r\ninline INT_PTR\r\nMDialogBase::DialogBoxIndirectDx(HWND hwndOwner, const VOID *ptr)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = TRUE;\r\n    INT_PTR nID = ::DialogBoxIndirectParam(::GetModuleHandle(NULL),\r\n                                           (const DLGTEMPLATE *)ptr,\r\n                                           m_hwndOwner,\r\n                                           MDialogBase::DialogProc,\r\n                                           reinterpret_cast<LPARAM>(this));\r\n    return nID;\r\n}\r\n\r\ninline BOOL\r\nMDialogBase::CreateDialogDx(HWND hwndOwner, LPCTSTR pDialogName)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = FALSE;\r\n    HWND hwnd = ::CreateDialogParam(::GetModuleHandle(NULL), pDialogName,\r\n                                    m_hwndOwner, MDialogBase::DialogProc,\r\n                                    reinterpret_cast<LPARAM>(this));\r\n    if (hwnd == NULL)\r\n    {\r\n        Detach();\r\n    }\r\n    return hwnd != NULL;\r\n}\r\n\r\ninline INT_PTR\r\nMDialogBase::DialogBoxDx(HWND hwndOwner, LPCTSTR pDialogName)\r\n{\r\n    if (hwndOwner)\r\n    {\r\n        m_hwndOwner = hwndOwner;\r\n    }\r\n    m_bModal = TRUE;\r\n    INT_PTR nID = ::DialogBoxParam(::GetModuleHandle(NULL),\r\n        pDialogName, m_hwndOwner, MDialogBase::DialogProc, (LPARAM)this);\r\n    return nID;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MWINDOWBASE_HPP_\r\n
MWindowBaseRichMethods.hpp<>MWindowBaseRichMethods.hpp<>// MWindowBaseRichMethods.hpp --- MWindowBase rich methods      -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MWINDOWBASE_HPP_\r\n    #error Do not #include "MWindowBaseRichMethods.hpp" directly. You lose.\r\n#endif\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#if (WINVER >= 0x0500)\r\n    BOOL AnimateWindow(DWORD dwTime, DWORD dwAW_)\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::AnimateWindow(Handle(), dwTime, dwAW_);\r\n    }\r\n    static BOOL AnimateWindow(HWND hwnd, DWORD dwTime, DWORD dwAW_)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::AnimateWindow(hwnd, dwTime, dwAW_);\r\n    }\r\n#endif\r\n\r\nUINT ArrangeIconicWindows()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ArrangeIconicWindows(Handle());\r\n}\r\nstatic UINT ArrangeIconicWindows(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ArrangeIconicWindows(hwnd);\r\n}\r\n\r\nHDC BeginPaint(PAINTSTRUCT* pPS)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    assert(pPS);\r\n    return ::BeginPaint(Handle(), pPS);\r\n}\r\nstatic HDC BeginPaint(HWND hwnd, PAINTSTRUCT* pPS)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    assert(pPS);\r\n    return ::BeginPaint(hwnd, pPS);\r\n}\r\n\r\nBOOL BringWindowToTop()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::BringWindowToTop(Handle());\r\n}\r\nstatic BOOL BringWindowToTop(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::BringWindowToTop(hwnd);\r\n}\r\n\r\nBOOL AdjustWindowRect(LPRECT prcClientToWindow)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::AdjustWindowRect(prcClientToWindow, GetStyleDx(),\r\n                              ::GetMenu(Handle()) != NULL);\r\n}\r\n\r\nBOOL AdjustWindowRectEx(LPRECT prcClientToWindow)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::AdjustWindowRectEx(prcClientToWindow, GetStyleDx(),\r\n                                ::GetMenu(Handle()) != NULL, GetExStyleDx());\r\n}\r\n\r\nBOOL CheckDlgButton(INT nButtonID, UINT nBST_)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::CheckDlgButton(Handle(), nButtonID, nBST_);\r\n}\r\nstatic BOOL CheckDlgButton(HWND hwnd, INT nButtonID, UINT nBST_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::CheckDlgButton(hwnd, nButtonID, nBST_);\r\n}\r\n\r\nHWND ChildWindowFromPoint(POINT pt)\r\n{\r\n    assert(Handle() == NULL || ::IsWindow(Handle()));\r\n    return ::ChildWindowFromPoint(Handle(), pt);\r\n}\r\nstatic HWND ChildWindowFromPoint(HWND hwnd, POINT pt)\r\n{\r\n    assert(hwnd == NULL || ::IsWindow(hwnd));\r\n    return ::ChildWindowFromPoint(hwnd, pt);\r\n}\r\n\r\nHWND ChildWindowFromPointEx(POINT pt, UINT nCWP_ = CWP_ALL)\r\n{\r\n    assert(Handle() == NULL || ::IsWindow(Handle()));\r\n    return ::ChildWindowFromPointEx(Handle(), pt, nCWP_);\r\n}\r\nstatic HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT nCWP_ = CWP_ALL)\r\n{\r\n    assert(hwnd == NULL || ::IsWindow(hwnd));\r\n    return ::ChildWindowFromPointEx(hwnd, pt, nCWP_);\r\n}\r\n\r\nBOOL ClientToScreen(LPPOINT ppt) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ClientToScreen(Handle(), ppt);\r\n}\r\nstatic BOOL ClientToScreen(HWND hwnd, LPPOINT ppt)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ClientToScreen(hwnd, ppt);\r\n}\r\n\r\nBOOL ClientToScreen(RECT *prc) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MapWindowPoints(Handle(), NULL, (LPPOINT)prc, 2);\r\n}\r\nstatic BOOL ClientToScreen(HWND hwnd, RECT *prc)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MapWindowPoints(hwnd, NULL, (LPPOINT)prc, 2);\r\n}\r\n\r\nBOOL CloseWindow()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::CloseWindow(Handle());\r\n}\r\nstatic BOOL CloseWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::CloseWindow(hwnd);\r\n}\r\n\r\nBOOL CreateCaret(HBITMAP hbm)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    BITMAP bm;\r\n    ::GetObject(hbm, sizeof(bm), &bm);\r\n    return ::CreateCaret(Handle(), hbm, bm.bmWidth, bm.bmHeight);\r\n}\r\nstatic BOOL CreateCaret(HWND hwnd, HBITMAP hbm)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    BITMAP bm;\r\n    ::GetObject(hbm, sizeof(bm), &bm);\r\n    return ::CreateCaret(hwnd, hbm, bm.bmWidth, bm.bmHeight);\r\n}\r\n\r\nBOOL CreateCaret(HBITMAP hbm, INT cx, INT cy)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::CreateCaret(Handle(), hbm, cx, cy);\r\n}\r\nstatic BOOL CreateCaret(HWND hwnd, HBITMAP hbm, INT cx, INT cy)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::CreateCaret(hwnd, hbm, cx, cy);\r\n}\r\n\r\nBOOL CreateGrayCaret(INT cx, INT cy)\r\n{\r\n    return CreateCaret((HBITMAP)1, cx, cy);\r\n}\r\nstatic BOOL CreateGrayCaret(HWND hwnd, INT cx, INT cy)\r\n{\r\n    return CreateCaret(hwnd, (HBITMAP)1, cx, cy);\r\n}\r\n\r\nBOOL CreateSolidCaret(INT cx, INT cy)\r\n{\r\n    return CreateCaret(NULL, cx, cy);\r\n}\r\nstatic BOOL CreateSolidCaret(HWND hwnd, INT cx, INT cy)\r\n{\r\n    return CreateCaret(hwnd, NULL, cx, cy);\r\n}\r\n\r\nBOOL DestroyWindow()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DestroyWindow(Handle());\r\n}\r\nstatic BOOL DestroyWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DestroyWindow(hwnd);\r\n}\r\n\r\nINT DlgDirList(LPTSTR pPathSpec, INT nListBoxID, INT nPathStaticID, UINT nDDL_ = DDL_DRIVES)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DlgDirList(Handle(), pPathSpec, nListBoxID, nPathStaticID, nDDL_);\r\n}\r\nstatic INT DlgDirList(HWND hwnd, LPTSTR pPathSpec, INT nListBoxID, INT nPathStaticID, UINT nDDL_ = DDL_DRIVES)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DlgDirList(hwnd, pPathSpec, nListBoxID, nPathStaticID, nDDL_);\r\n}\r\n\r\nINT DlgDirListComboBox(LPTSTR pPathSpec, INT nComboBoxID, INT nPathStaticID, UINT nDDL_ = DDL_DRIVES)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DlgDirListComboBox(Handle(), pPathSpec, nComboBoxID, nPathStaticID, nDDL_);\r\n}\r\nstatic INT DlgDirListComboBox(HWND hwnd, LPTSTR pPathSpec, INT nComboBoxID, INT nPathStaticID, UINT nDDL_ = DDL_DRIVES)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DlgDirListComboBox(hwnd, pPathSpec, nComboBoxID, nPathStaticID, nDDL_);\r\n}\r\n\r\nBOOL DlgDirSelectEx(LPTSTR pszPath, INT cchPath, INT nListBoxID)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DlgDirSelectEx(Handle(), pszPath, cchPath, nListBoxID);\r\n}\r\nstatic BOOL DlgDirSelectEx(HWND hwnd, LPTSTR pszPath, INT cchPath, INT nListBoxID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DlgDirSelectEx(hwnd, pszPath, cchPath, nListBoxID);\r\n}\r\n\r\nBOOL DlgDirSelectComboBoxEx(LPTSTR pszPath, INT cchPath, INT nComboBoxID)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DlgDirSelectComboBoxEx(Handle(), pszPath, cchPath, nComboBoxID);\r\n}\r\nstatic BOOL DlgDirSelectComboBoxEx(HWND hwnd, LPTSTR pszPath, INT cchPath, INT nComboBoxID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DlgDirSelectComboBoxEx(hwnd, pszPath, cchPath, nComboBoxID);\r\n}\r\n\r\nVOID DragAcceptFiles(BOOL bAccept = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DragAcceptFiles(Handle(), bAccept);\r\n}\r\nstatic VOID DragAcceptFiles(HWND hwnd, BOOL bAccept = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DragAcceptFiles(hwnd, bAccept);\r\n}\r\n\r\nBOOL DragDetect(POINT pt) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DragDetect(Handle(), pt);\r\n}\r\nstatic BOOL DragDetect(HWND hwnd, POINT pt)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DragDetect(hwnd, pt);\r\n}\r\n\r\nBOOL DrawAnimatedRects(const RECT *prcFrom, const RECT *prcTo, INT idAni = 0)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DrawAnimatedRects(Handle(), idAni, prcFrom, prcTo);\r\n}\r\nstatic BOOL DrawAnimatedRects(HWND hwnd, const RECT *prcFrom, const RECT *prcTo, INT idAni = 0)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DrawAnimatedRects(hwnd, idAni, prcFrom, prcTo);\r\n}\r\n\r\nBOOL DrawCaption(HDC hDC, const RECT *prc, UINT nDC_)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DrawCaption(Handle(), hDC, prc, nDC_);\r\n}\r\nstatic BOOL DrawCaption(HWND hwnd, HDC hDC, const RECT *prc, UINT nDC_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DrawCaption(hwnd, hDC, prc, nDC_);\r\n}\r\n\r\nBOOL DrawMenuBar()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::DrawMenuBar(Handle());\r\n}\r\nstatic BOOL DrawMenuBar(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::DrawMenuBar(hwnd);\r\n}\r\n\r\nBOOL EnableScrollBar(UINT nSB_, UINT nESB_ = ESB_ENABLE_BOTH)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::EnableScrollBar(Handle(), nSB_, nESB_);\r\n}\r\nstatic BOOL EnableScrollBar(HWND hwnd, UINT nSB_, UINT nESB_ = ESB_ENABLE_BOTH)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::EnableScrollBar(hwnd, nSB_, nESB_);\r\n}\r\n\r\nBOOL EnableScrollBarCtrl(UINT nBarID, BOOL bEnable = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    HWND hwndSB = ::GetDlgItem(Handle(), nBarID);\r\n    return ::EnableScrollBar(hwndSB, SB_CTL,\r\n        (bEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH));\r\n}\r\nstatic BOOL EnableScrollBarCtrl(HWND hwnd, UINT nBarID, BOOL bEnable = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    HWND hwndSB = ::GetDlgItem(hwnd, nBarID);\r\n    return ::EnableScrollBar(hwndSB, SB_CTL,\r\n        (bEnable ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH));\r\n}\r\n\r\n// TODO: EnableToolTips\r\n\r\nBOOL EnableWindow(BOOL bEnable = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::EnableWindow(Handle(), bEnable);\r\n}\r\nstatic BOOL EnableWindow(HWND hwnd, BOOL bEnable = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::EnableWindow(hwnd, bEnable);\r\n}\r\n\r\nBOOL EndPaint(const PAINTSTRUCT *pPS)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    assert(pPS);\r\n    return ::EndPaint(Handle(), pPS);\r\n}\r\nstatic BOOL EndPaint(HWND hwnd, const PAINTSTRUCT *pPS)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    assert(pPS);\r\n    return ::EndPaint(hwnd, pPS);\r\n}\r\n\r\n// TODO: ExecuteDlgInit(LPCTSTR pszResName)\r\n\r\nBOOL FlashWindow(BOOL bInvert)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::FlashWindow(Handle(), bInvert);\r\n}\r\nstatic BOOL FlashWindow(HWND hwnd, BOOL bInvert)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::FlashWindow(hwnd, bInvert);\r\n}\r\n\r\n#if (WINVER >= 0x0500)\r\n    BOOL FlashWindowEx(DWORD dwFLASHW_, UINT uCount, DWORD dwTimeout)\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        FLASHWINFO info;\r\n        ZeroMemory(&info, sizeof(info));\r\n        info.cbSize = sizeof(info);\r\n        info.hwnd = Handle();\r\n        info.dwFlags = dwFLASHW_;\r\n        info.uCount = uCount;\r\n        info.dwTimeout = dwTimeout;\r\n        return ::FlashWindowEx(&info);\r\n    }\r\n    static BOOL FlashWindowEx(HWND hwnd, DWORD dwFLASHW_, UINT uCount, DWORD dwTimeout)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        FLASHWINFO info;\r\n        ZeroMemory(&info, sizeof(info));\r\n        info.cbSize = sizeof(info);\r\n        info.hwnd = hwnd;\r\n        info.dwFlags = dwFLASHW_;\r\n        info.uCount = uCount;\r\n        info.dwTimeout = dwTimeout;\r\n        return ::FlashWindowEx(&info);\r\n    }\r\n#endif\r\n\r\n#if WINVER >= 0x0500\r\n    HWND GetAncestor(UINT nGA_)\r\n    {\r\n        assert(::IsWindow(Handle()));\r\n        return ::GetAncestor(Handle(), nGA_);\r\n    }\r\n    static HWND GetAncestor(HWND hwnd, UINT nGA_)\r\n    {\r\n        assert(::IsWindow(hwnd));\r\n        return ::GetAncestor(hwnd, nGA_);\r\n    }\r\n#endif\r\n\r\nINT GetCheckedRadioButton(INT nFirstID, INT nLastID) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    while (nFirstID < nLastID)\r\n    {\r\n        if (::IsDlgButtonChecked(Handle(), nFirstID) == BST_CHECKED)\r\n            return nFirstID;\r\n        ++nFirstID;\r\n    }\r\n    return 0;\r\n}\r\nstatic INT GetCheckedRadioButton(HWND hwnd, INT nFirstID, INT nLastID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    while (nFirstID < nLastID)\r\n    {\r\n        if (::IsDlgButtonChecked(hwnd, nFirstID) == BST_CHECKED)\r\n            return nFirstID;\r\n        ++nFirstID;\r\n    }\r\n    return 0;\r\n}\r\n\r\nBOOL GetClientRect(RECT *prc) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetClientRect(Handle(), prc);\r\n}\r\nstatic BOOL GetClientRect(HWND hwnd, RECT *prc)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetClientRect(hwnd, prc);\r\n}\r\n\r\nRECT GetClientRect() const\r\n{\r\n    RECT rc;\r\n    GetClientRect(&rc);\r\n    return rc;\r\n}\r\nstatic RECT GetClientRect(HWND hwnd)\r\n{\r\n    RECT rc;\r\n    GetClientRect(hwnd, &rc);\r\n    return rc;\r\n}\r\n\r\nHDC GetDC()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDC(Handle());\r\n}\r\nstatic HDC GetDC(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDC(hwnd);\r\n}\r\n\r\nHDC GetDCEx(HRGN hRgnClip, DWORD dwDCX_)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDCEx(Handle(), hRgnClip, dwDCX_);\r\n}\r\nstatic HDC GetDCEx(HWND hwnd, HRGN hRgnClip, DWORD dwDCX_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDCEx(hwnd, hRgnClip, dwDCX_);\r\n}\r\n\r\nINT GetDlgCtrlID() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDlgCtrlID(Handle());\r\n}\r\nstatic INT GetDlgCtrlID(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDlgCtrlID(hwnd);\r\n}\r\n\r\nHWND GetDlgItem(INT nID) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDlgItem(Handle(), nID);\r\n}\r\nstatic HWND GetDlgItem(HWND hwnd, INT nID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDlgItem(hwnd, nID);\r\n}\r\n\r\nUINT GetDlgItemInt(INT nID, BOOL *lpTranslated = NULL, BOOL bSigned = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDlgItemInt(Handle(), nID, lpTranslated, bSigned);\r\n}\r\nstatic UINT GetDlgItemInt(HWND hwnd, INT nID, BOOL *lpTranslated = NULL, BOOL bSigned = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDlgItemInt(hwnd, nID, lpTranslated, bSigned);\r\n}\r\n\r\nINT GetDlgItemText(INT nID, LPTSTR psz, INT cchMax) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetDlgItemText(Handle(), nID, psz, cchMax);\r\n}\r\nstatic INT GetDlgItemText(HWND hwnd, INT nID, LPTSTR psz, INT cchMax)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetDlgItemText(hwnd, nID, psz, cchMax);\r\n}\r\n\r\nHFONT GetFontDx() const\r\n{\r\n    return (HFONT)SendMessageDx(WM_GETFONT, 0, 0);\r\n}\r\n\r\nHICON GetIconDx(BOOL bBigIcon = TRUE) const\r\n{\r\n    return (HICON)SendMessageDx(WM_GETICON, (bBigIcon ? ICON_BIG : ICON_SMALL));\r\n}\r\n\r\nHWND GetLastActivePopup() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetLastActivePopup(Handle());\r\n}\r\nstatic HWND GetLastActivePopup(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetLastActivePopup(hwnd);\r\n}\r\n\r\nHMENU GetMenu() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetMenu(Handle());\r\n}\r\nstatic HMENU GetMenu(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetMenu(hwnd);\r\n}\r\n\r\nHWND GetNextDlgGroupItem(HWND hwndCtrl, BOOL bPrevious = FALSE) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetNextDlgGroupItem(Handle(), hwndCtrl, bPrevious);\r\n}\r\nHWND GetNextDlgGroupItem(HWND hwnd, HWND hwndCtrl, BOOL bPrevious = FALSE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetNextDlgGroupItem(hwnd, hwndCtrl, bPrevious);\r\n}\r\n\r\nHWND GetNextDlgTabItem(HWND hwndCtrl, BOOL bPrevious = FALSE) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetNextDlgTabItem(Handle(), hwndCtrl, bPrevious);\r\n}\r\nstatic HWND GetNextDlgTabItem(HWND hwnd, HWND hwndCtrl, BOOL bPrevious = FALSE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetNextDlgTabItem(hwnd, hwndCtrl, bPrevious);\r\n}\r\n\r\n#undef GetNextWindow\r\nHWND GetNextWindow(UINT nGW_ = GW_HWNDNEXT) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindow(Handle(), nGW_);\r\n}\r\nstatic HWND GetNextWindow(HWND hwnd, UINT nGW_ = GW_HWNDNEXT)\r\n{\r\n    return ::GetWindow(hwnd, nGW_);\r\n}\r\n\r\nHWND GetOwnerDx() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindow(Handle(), GW_OWNER);\r\n}\r\n\r\nHWND GetParent() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetParent(Handle());\r\n}\r\nstatic HWND GetParent(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetParent(hwnd);\r\n}\r\n\r\n// TODO: GetParentFrame\r\n// TODO: GetParentOwner\r\n// TODO: GetScrollBarCtrl\r\n\r\nBOOL GetScrollInfo(INT nSB_, SCROLLINFO *pInfo) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetScrollInfo(Handle(), nSB_, pInfo);\r\n}\r\nstatic BOOL GetScrollInfo(HWND hwnd, INT nSB_, SCROLLINFO *pInfo)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetScrollInfo(hwnd, nSB_, pInfo);\r\n}\r\n\r\nINT GetScrollPos(INT nSB_) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetScrollPos(Handle(), nSB_);\r\n}\r\nstatic INT GetScrollPos(HWND hwnd, INT nSB_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetScrollPos(hwnd, nSB_);\r\n}\r\n\r\nBOOL GetScrollRange(INT nSB_, LPINT pMinPos, LPINT pMaxPos) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetScrollRange(Handle(), nSB_, pMinPos, pMaxPos);\r\n}\r\nstatic BOOL GetScrollRange(HWND hwnd, INT nSB_, LPINT pMinPos, LPINT pMaxPos)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetScrollRange(hwnd, nSB_, pMinPos, pMaxPos);\r\n}\r\n\r\nHMENU GetSystemMenu(BOOL bRevert = FALSE) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetSystemMenu(Handle(), bRevert);\r\n}\r\nstatic HMENU GetSystemMenu(HWND hwnd, BOOL bRevert = FALSE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetSystemMenu(hwnd, bRevert);\r\n}\r\n\r\nHWND GetTopWindow() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetTopWindow(Handle());\r\n}\r\nstatic HWND GetTopWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetTopWindow(hwnd);\r\n}\r\n\r\nBOOL GetUpdateRect(RECT *prc = NULL, BOOL bErase = TRUE) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetUpdateRect(Handle(), prc, bErase);\r\n}\r\nstatic BOOL GetUpdateRect(HWND hwnd, RECT *prc = NULL, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetUpdateRect(hwnd, prc, bErase);\r\n}\r\n\r\nINT GetUpdateRgn(HRGN hRgn, BOOL bErase = TRUE) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetUpdateRgn(Handle(), hRgn, bErase);\r\n}\r\nstatic INT GetUpdateRgn(HWND hwnd, HRGN hRgn, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetUpdateRgn(hwnd, hRgn, bErase);\r\n}\r\n\r\nHWND GetWindow(UINT nGW_) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindow(Handle(), nGW_);\r\n}\r\nstatic HWND GetWindow(HWND hwnd, UINT nGW_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindow(hwnd, nGW_);\r\n}\r\n\r\nDWORD GetWindowContextHelpId() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindowContextHelpId(Handle());\r\n}\r\nstatic DWORD GetWindowContextHelpId(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindowContextHelpId(hwnd);\r\n}\r\n\r\nHDC GetWindowDC()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindowDC(Handle());\r\n}\r\nstatic HDC GetWindowDC(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindowDC(hwnd);\r\n}\r\n\r\nBOOL GetWindowPlacement(WINDOWPLACEMENT *pwndpl) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindowPlacement(Handle(), pwndpl);\r\n}\r\nstatic BOOL GetWindowPlacement(HWND hwnd, WINDOWPLACEMENT *pwndpl)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindowPlacement(hwnd, pwndpl);\r\n}\r\n\r\nBOOL GetWindowRect(RECT *prc) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindowRect(Handle(), prc);\r\n}\r\nstatic BOOL GetWindowRect(HWND hwnd, RECT *prc)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindowRect(hwnd, prc);\r\n}\r\n\r\nRECT GetWindowRect() const\r\n{\r\n    RECT rc;\r\n    GetWindowRect(&rc);\r\n    return rc;\r\n}\r\nstatic RECT GetWindowRect(HWND hwnd)\r\n{\r\n    RECT rc;\r\n    GetWindowRect(hwnd, &rc);\r\n    return rc;\r\n}\r\n\r\nINT GetWindowRgn(HRGN hRgn) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::GetWindowRgn(Handle(), hRgn);\r\n}\r\nstatic INT GetWindowRgn(HWND hwnd, HRGN hRgn)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::GetWindowRgn(hwnd, hRgn);\r\n}\r\n\r\nBOOL HideCaret()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::HideCaret(Handle());\r\n}\r\nstatic BOOL HideCaret(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::HideCaret(hwnd);\r\n}\r\n\r\nBOOL HiliteMenuItem(HMENU hMenu, UINT nItem,\r\n                    UINT nMF_ = MF_BYCOMMAND | MF_HILITE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::HiliteMenuItem(Handle(), hMenu, nItem, nMF_);\r\n}\r\nstatic BOOL\r\nHiliteMenuItem(HWND hwnd, HMENU hMenu, UINT nItem,\r\n               UINT nMF_ = MF_BYCOMMAND | MF_HILITE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::HiliteMenuItem(hwnd, hMenu, nItem, nMF_);\r\n}\r\n\r\n// TODO: HtmlHelp\r\n\r\nBOOL Invalidate(BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::InvalidateRect(Handle(), NULL, bErase);\r\n}\r\n\r\nBOOL InvalidateRect(const RECT *prc, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::InvalidateRect(Handle(), prc, bErase);\r\n}\r\nstatic BOOL InvalidateRect(HWND hwnd, const RECT *prc, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::InvalidateRect(hwnd, prc, bErase);\r\n}\r\n\r\nBOOL InvalidateRgn(HRGN hRgn, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::InvalidateRgn(Handle(), hRgn, bErase);\r\n}\r\nstatic BOOL InvalidateRgn(HWND hwnd, HRGN hRgn, BOOL bErase = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::InvalidateRgn(hwnd, hRgn, bErase);\r\n}\r\n\r\nBOOL IsChild(HWND hwndChild) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsChild(Handle(), hwndChild);\r\n}\r\nstatic BOOL IsChild(HWND hwnd, HWND hwndChild)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsChild(hwnd, hwndChild);\r\n}\r\n\r\nUINT IsDlgButtonChecked(INT nID) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsDlgButtonChecked(Handle(), nID);\r\n}\r\nstatic UINT IsDlgButtonChecked(HWND hwnd, INT nID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsDlgButtonChecked(hwnd, nID);\r\n}\r\n\r\nBOOL IsIconic() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsIconic(Handle());\r\n}\r\nstatic BOOL IsIconic(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsIconic(hwnd);\r\n}\r\n\r\nBOOL IsWindowEnabled() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsWindowEnabled(Handle());\r\n}\r\nstatic BOOL IsWindowEnabled(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsWindowEnabled(hwnd);\r\n}\r\n\r\nBOOL IsWindowVisible() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsWindowVisible(Handle());\r\n}\r\nstatic BOOL IsWindowVisible(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsWindowVisible(hwnd);\r\n}\r\n\r\nBOOL IsZoomed() const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::IsZoomed(Handle());\r\n}\r\nstatic BOOL IsZoomed(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::IsZoomed(hwnd);\r\n}\r\n\r\nBOOL KillTimer(UINT_PTR nTimerID)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::KillTimer(Handle(), nTimerID);\r\n}\r\nstatic BOOL KillTimer(HWND hwnd, UINT_PTR nTimerID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::KillTimer(hwnd, nTimerID);\r\n}\r\n\r\nBOOL LockWindowUpdate()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::LockWindowUpdate(Handle());\r\n}\r\nstatic BOOL LockWindowUpdate(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::LockWindowUpdate(hwnd);\r\n}\r\n\r\nINT MapWindowPoints(HWND hwndTo, LPRECT prc) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MapWindowPoints(Handle(), hwndTo, (LPPOINT)prc, 2);\r\n}\r\nstatic INT MapWindowPoints(HWND hwnd, HWND hwndTo, LPRECT prc)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MapWindowPoints(hwnd, hwndTo, (LPPOINT)prc, 2);\r\n}\r\n\r\nINT MapWindowPoints(HWND hwndTo, LPPOINT ppt, UINT cPoints) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MapWindowPoints(Handle(), hwndTo, ppt, cPoints);\r\n}\r\nstatic INT MapWindowPoints(HWND hwnd, HWND hwndTo, LPPOINT ppt, UINT cPoints)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MapWindowPoints(hwnd, hwndTo, ppt, cPoints);\r\n}\r\n\r\nBOOL MoveWindow(INT x, INT y, INT cx, INT cy, BOOL bRepaint = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MoveWindow(Handle(), x, y, cx, cy, bRepaint);\r\n}\r\nstatic BOOL MoveWindow(HWND hwnd, INT x, INT y, INT cx, INT cy, BOOL bRepaint = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MoveWindow(hwnd, x, y, cx, cy, bRepaint);\r\n}\r\n\r\nBOOL MoveWindow(const RECT *prc, BOOL bRepaint = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MoveWindow(Handle(), prc->left, prc->top,\r\n                        prc->right - prc->left, prc->bottom - prc->top,\r\n                        bRepaint);\r\n}\r\nstatic BOOL MoveWindow(HWND hwnd, const RECT *prc, BOOL bRepaint = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MoveWindow(hwnd, prc->left, prc->top,\r\n                        prc->right - prc->left, prc->bottom - prc->top,\r\n                        bRepaint);\r\n}\r\n\r\nVOID Print(HDC hDC, UINT nPRF_) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    SendMessageDx(WM_PRINT, (WPARAM)hDC, (LPARAM)nPRF_);\r\n}\r\nstatic VOID Print(HWND hwnd, HDC hDC, UINT nPRF_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    ::SendMessage(hwnd, WM_PRINT, (WPARAM)hDC, (LPARAM)nPRF_);\r\n}\r\n\r\nVOID PrintClient(HDC hDC, UINT nPRF_) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    SendMessageDx(WM_PRINTCLIENT, (WPARAM)hDC, (LPARAM)nPRF_);\r\n}\r\nstatic VOID PrintClient(HWND hwnd, HDC hDC, UINT nPRF_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    ::SendMessage(hwnd, WM_PRINTCLIENT, (WPARAM)hDC, (LPARAM)nPRF_);\r\n}\r\n\r\nBOOL RedrawWindow(const RECT *prcUpdate = NULL, HRGN hRgnUpdate = NULL,\r\n    UINT nRDW_ = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::RedrawWindow(Handle(), prcUpdate, hRgnUpdate, nRDW_);\r\n}\r\nstatic BOOL RedrawWindow(HWND hwnd,\r\n    const RECT *prcUpdate = NULL, HRGN hRgnUpdate = NULL,\r\n    UINT nRDW_ = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::RedrawWindow(hwnd, prcUpdate, hRgnUpdate, nRDW_);\r\n}\r\n\r\nINT ReleaseDC(HDC hDC)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ReleaseDC(Handle(), hDC);\r\n}\r\nstatic INT ReleaseDC(HWND hwnd, HDC hDC)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ReleaseDC(hwnd, hDC);\r\n}\r\n\r\nBOOL ScreenToClient(POINT *ppt) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ScreenToClient(Handle(), ppt);\r\n}\r\nstatic BOOL ScreenToClient(HWND hwnd, POINT *ppt)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ScreenToClient(hwnd, ppt);\r\n}\r\n\r\nBOOL ScreenToClient(RECT *prc) const\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::MapWindowPoints(NULL, Handle(), (LPPOINT)prc, 2);\r\n}\r\nstatic BOOL ScreenToClient(HWND hwnd, RECT *prc)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::MapWindowPoints(NULL, hwnd, (LPPOINT)prc, 2);\r\n}\r\n\r\nBOOL ScrollWindow(INT dx, INT dy, const RECT *prc = NULL,\r\n                  const RECT *prcClip = NULL)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ScrollWindow(Handle(), dx, dy, prc, prcClip);\r\n}\r\nstatic BOOL\r\nScrollWindow(HWND hwnd, INT dx, INT dy, const RECT *prc = NULL,\r\n             const RECT *prcClip = NULL)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ScrollWindow(hwnd, dx, dy, prc, prcClip);\r\n}\r\n\r\nBOOL ScrollWindowEx(INT dx, INT dy, const RECT *prc, const RECT *prcClip,\r\n                    HRGN hRgnUpdate, RECT *prcUpdate, UINT nSW_)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ScrollWindowEx(Handle(), dx, dy, prc, prcClip, hRgnUpdate,\r\n                            prcUpdate, nSW_);\r\n}\r\nstatic BOOL\r\nScrollWindowEx(HWND hwnd, INT dx, INT dy, const RECT *prc, const RECT *prcClip,\r\n               HRGN hRgnUpdate, RECT *prcUpdate, UINT nSW_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ScrollWindowEx(hwnd, dx, dy, prc, prcClip, hRgnUpdate,\r\n                            prcUpdate, nSW_);\r\n}\r\n\r\nLRESULT SendDlgItemMessageDx(INT nCtrlID, UINT uMsg,\r\n                             WPARAM wParam = 0, LPARAM lParam = 0)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SendDlgItemMessage(Handle(), nCtrlID, uMsg, wParam, lParam);\r\n}\r\n\r\nHWND SetActiveWindow()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetActiveWindow(Handle());\r\n}\r\nstatic HWND SetActiveWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetActiveWindow(hwnd);\r\n}\r\n\r\nINT SetDlgCtrlID(INT nID)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return SetWindowLong(Handle(), GWL_ID, nID);\r\n}\r\nstatic INT SetDlgCtrlID(HWND hwnd, INT nID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return SetWindowLong(hwnd, GWL_ID, nID);\r\n}\r\n\r\nBOOL SetDlgItemInt(INT nCtrlID, UINT nValue, BOOL bSigned = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetDlgItemInt(Handle(), nCtrlID, nValue, bSigned);\r\n}\r\nstatic BOOL SetDlgItemInt(HWND hwnd, INT nCtrlID, UINT nValue, BOOL bSigned = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetDlgItemInt(hwnd, nCtrlID, nValue, bSigned);\r\n}\r\n\r\nBOOL SetDlgItemText(INT nCtrlID, LPCTSTR pszText)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetDlgItemText(Handle(), nCtrlID, pszText);\r\n}\r\nstatic BOOL SetDlgItemText(HWND hwnd, INT nCtrlID, LPCTSTR pszText)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetDlgItemText(hwnd, nCtrlID, pszText);\r\n}\r\n\r\nBOOL SetForegroundWindow()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetForegroundWindow(Handle());\r\n}\r\nstatic BOOL SetForegroundWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetForegroundWindow(hwnd);\r\n}\r\n\r\nHWND SetFocus()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetFocus(Handle());\r\n}\r\nstatic HWND SetFocus(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetFocus(hwnd);\r\n}\r\n\r\nVOID SetFontDx(HFONT hFont, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    SendMessageDx(WM_SETFONT, (WPARAM)hFont, bRedraw);\r\n}\r\n\r\nHICON SetIconDx(HICON hIcon, BOOL bBigIcon = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return (HICON)SendMessageDx(WM_SETICON,\r\n        (bBigIcon ? ICON_BIG : ICON_SMALL), (LPARAM)hIcon);\r\n}\r\n\r\nBOOL SetMenu(HMENU hMenu)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetMenu(Handle(), hMenu);\r\n}\r\nstatic BOOL SetMenu(HWND hwnd, HMENU hMenu)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetMenu(hwnd, hMenu);\r\n}\r\n\r\nHWND SetParent(HWND hwndParent)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetParent(Handle(), hwndParent);\r\n}\r\nstatic HWND SetParent(HWND hwnd, HWND hwndParent)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetParent(hwnd, hwndParent);\r\n}\r\n\r\nvoid SetRedrawDx(BOOL fRedraw)\r\n{\r\n    SendMessageDx(WM_SETREDRAW, fRedraw);\r\n}\r\n\r\nINT SetScrollInfo(INT nSB_, SCROLLINFO *pInfo, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetScrollInfo(Handle(), nSB_, pInfo, bRedraw);\r\n}\r\nstatic INT SetScrollInfo(HWND hwnd, INT nSB_, SCROLLINFO *pInfo, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetScrollInfo(hwnd, nSB_, pInfo, bRedraw);\r\n}\r\n\r\nINT SetScrollPos(INT nSB_, INT nPos, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetScrollPos(Handle(), nSB_, nPos, bRedraw);\r\n}\r\nstatic INT SetScrollPos(HWND hwnd, INT nSB_, INT nPos, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetScrollPos(hwnd, nSB_, nPos, bRedraw);\r\n}\r\n\r\nBOOL SetScrollRange(INT nSB_, INT nMinPos, INT nMaxPos, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetScrollRange(Handle(), nSB_, nMinPos, nMaxPos, bRedraw);\r\n}\r\nstatic BOOL SetScrollRange(HWND hwnd, INT nSB_, INT nMinPos, INT nMaxPos, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetScrollRange(hwnd, nSB_, nMinPos, nMaxPos, bRedraw);\r\n}\r\n\r\nUINT_PTR SetTimer(UINT_PTR nEventID, UINT uElapse, TIMERPROC lpTimerFunc = NULL)\r\n{\r\n    assert(Handle() == NULL || ::IsWindow(Handle()));\r\n    return ::SetTimer(Handle(), nEventID, uElapse, lpTimerFunc);\r\n}\r\nstatic UINT_PTR SetTimer(HWND hwnd, UINT_PTR nEventID, UINT uElapse, TIMERPROC lpTimerFunc = NULL)\r\n{\r\n    assert(hwnd == NULL || ::IsWindow(hwnd));\r\n    return ::SetTimer(hwnd, nEventID, uElapse, lpTimerFunc);\r\n}\r\n\r\nBOOL SetWindowContextHelpId(DWORD dwContextID)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetWindowContextHelpId(Handle(), dwContextID);\r\n}\r\nstatic BOOL SetWindowContextHelpId(HWND hwnd, DWORD dwContextID)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetWindowContextHelpId(hwnd, dwContextID);\r\n}\r\n\r\nBOOL SetWindowPlacement(const WINDOWPLACEMENT *pwndpl)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetWindowPlacement(Handle(), pwndpl);\r\n}\r\nstatic BOOL SetWindowPlacement(HWND hwnd, const WINDOWPLACEMENT *pwndpl)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetWindowPlacement(hwnd, pwndpl);\r\n}\r\n\r\nBOOL SetWindowPos(HWND hwndInsertAfter, INT x, INT y, INT cx, INT cy,\r\n                  UINT nSWP_)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetWindowPos(Handle(), hwndInsertAfter, x, y, cx, cy, nSWP_);\r\n}\r\nstatic BOOL\r\nSetWindowPos(HWND hwnd, HWND hwndInsertAfter, INT x, INT y, INT cx, INT cy,\r\n             UINT nSWP_)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetWindowPos(hwnd, hwndInsertAfter, x, y, cx, cy, nSWP_);\r\n}\r\n\r\nINT SetWindowRgn(HRGN hRgn = NULL, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::SetWindowRgn(Handle(), hRgn, bRedraw);\r\n}\r\nstatic INT SetWindowRgn(HWND hwnd, HRGN hRgn = NULL, BOOL bRedraw = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::SetWindowRgn(hwnd, hRgn, bRedraw);\r\n}\r\n\r\nBOOL ShowCaret()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ShowCaret(Handle());\r\n}\r\nstatic BOOL ShowCaret(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ShowCaret(hwnd);\r\n}\r\n\r\nBOOL ShowOwnedPopups(BOOL bShow = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ShowOwnedPopups(Handle(), bShow);\r\n}\r\nstatic BOOL ShowOwnedPopups(HWND hwnd, BOOL bShow = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ShowOwnedPopups(hwnd, bShow);\r\n}\r\n\r\nBOOL ShowScrollBar(INT nSB_, BOOL bShow = TRUE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ShowScrollBar(Handle(), nSB_, bShow);\r\n}\r\nstatic BOOL ShowScrollBar(HWND hwnd, INT nSB_, BOOL bShow = TRUE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ShowScrollBar(hwnd, nSB_, bShow);\r\n}\r\n\r\nBOOL ShowWindow(INT nSW_ = SW_SHOWNOACTIVATE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ShowWindow(Handle(), nSW_);\r\n}\r\nstatic BOOL ShowWindow(HWND hwnd, INT nSW_ = SW_SHOWNOACTIVATE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ShowWindow(hwnd, nSW_);\r\n}\r\n\r\nBOOL ShowWindowAsync(INT nSW_ = SW_SHOWNOACTIVATE)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ShowWindowAsync(Handle(), nSW_);\r\n}\r\nstatic BOOL ShowWindowAsync(HWND hwnd, INT nSW_ = SW_SHOWNOACTIVATE)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ShowWindowAsync(hwnd, nSW_);\r\n}\r\n\r\nstatic BOOL UnlockWindowUpdate()\r\n{\r\n    return ::LockWindowUpdate(NULL);\r\n}\r\n\r\nBOOL UpdateWindow()\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::UpdateWindow(Handle());\r\n}\r\nstatic BOOL UpdateWindow(HWND hwnd)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::UpdateWindow(hwnd);\r\n}\r\n\r\nBOOL ValidateRect(const RECT *prc = NULL)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ValidateRect(Handle(), prc);\r\n}\r\nstatic BOOL ValidateRect(HWND hwnd, const RECT *prc = NULL)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ValidateRect(hwnd, prc);\r\n}\r\n\r\nBOOL ValidateRgn(HRGN hRgn = NULL)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::ValidateRgn(Handle(), hRgn);\r\n}\r\nstatic BOOL ValidateRgn(HWND hwnd, HRGN hRgn = NULL)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::ValidateRgn(hwnd, hRgn);\r\n}\r\n\r\nBOOL WinHelp(LPCTSTR pszHelpFile, UINT nHELP_, ULONG_PTR dwData)\r\n{\r\n    assert(::IsWindow(Handle()));\r\n    return ::WinHelp(Handle(), pszHelpFile, nHELP_, dwData);\r\n}\r\nstatic BOOL WinHelp(HWND hwnd, LPCTSTR pszHelpFile, UINT nHELP_, ULONG_PTR dwData)\r\n{\r\n    assert(::IsWindow(hwnd));\r\n    return ::WinHelp(hwnd, pszHelpFile, nHELP_, dwData);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
MWindowClass<>MWindowClass<>class MWindowClass : public MWindowBase\r\n{\r\npublic:\r\n    MWindowClass()\r\n    {\r\n    }\r\n\r\n    virtual ~MWindowClass()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MWindowClass Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n};
MyProject.cpp (Dialog)<>MyProject.cpp (Dialog)<>// MyProject.cpp\r\n\r\n#include "targetver.h"\r\n#include "MWindowBase.hpp"\r\n\r\nclass MMainDlg : public MDialogBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n\r\n    MMainDlg(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : MDialogBase(1), m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainDlg()\r\n    {\r\n    }\r\n\r\n    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)\r\n    {\r\n        SendMessageDx(WM_SETICON, ICON_BIG, LPARAM(m_hIcon));\r\n        SendMessageDx(WM_SETICON, ICON_SMALL, LPARAM(m_hIconSm));\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        switch (id)\r\n        {\r\n        case IDOK:\r\n            EndDialog(IDOK);\r\n            break;\r\n        case IDCANCEL:\r\n            EndDialog(IDCANCEL);\r\n            break;\r\n        }\r\n    }\r\n\r\n    virtual INT_PTR CALLBACK\r\n    DialogProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        return INT(DialogBoxDx(NULL));\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Win32 main function\r\n\r\nextern "C"\r\nINT APIENTRY _tWinMain(\r\n    HINSTANCE   hInstance,\r\n    HINSTANCE   hPrevInstance,\r\n    LPTSTR      lpCmdLine,\r\n    INT         nCmdShow)\r\n{\r\n    int ret = -1;\r\n\r\n    {\r\n        MMainDlg app(__argc, __targv, hInstance);\r\n\r\n        ::InitCommonControls();\r\n\r\n        if (app.StartDx(nCmdShow))\r\n        {\r\n            ret = app.RunDx();\r\n        }\r\n    }\r\n\r\n#if (WINVER >= 0x0500)\r\n    HANDLE hProcess = GetCurrentProcess();\r\n    DebugPrintDx(TEXT("Count of GDI objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_GDIOBJECTS));\r\n    DebugPrintDx(TEXT("Count of USER objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_USEROBJECTS));\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG)\r\n    // for detecting memory leak (MSVC only)\r\n    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\r\n#endif\r\n\r\n    return ret;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
MyProject.cpp (Window)<>MyProject.cpp (Window)<>// MyProject.cpp\r\n\r\n#include "targetver.h"\r\n#include "MWindowBase.hpp"\r\n\r\nclass MMainWnd : public MWindowBase\r\n{\r\npublic:\r\n    INT         m_argc;         // number of command line parameters\r\n    TCHAR **    m_targv;        // command line parameters\r\n    HINSTANCE   m_hInst;        // the instance handle\r\n    HICON       m_hIcon;        // the main icon\r\n    HICON       m_hIconSm;      // the small icon\r\n    HACCEL      m_hAccel;       // the access keys\r\n\r\n    MMainWnd(INT argc, TCHAR **targv, HINSTANCE hInst)\r\n        : m_argc(argc), m_targv(targv), m_hInst(hInst),\r\n          m_hIcon(NULL), m_hIconSm(NULL), m_hAccel(NULL)\r\n    {\r\n    }\r\n\r\n    virtual ~MMainWnd()\r\n    {\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MZC4 MMainWnd Class");\r\n    }\r\n\r\n    virtual VOID ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n        wcx.lpszMenuName = MAKEINTRESOURCE(1);\r\n        wcx.hIcon = m_hIcon;\r\n        wcx.hIconSm = m_hIconSm;\r\n    }\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n    {\r\n        return TRUE;\r\n    }\r\n\r\n    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)\r\n    {\r\n        if (id == 1)\r\n        {\r\n            DestroyWindow(hwnd);\r\n        }\r\n    }\r\n\r\n    void OnDestroy(HWND hwnd)\r\n    {\r\n        ::PostQuitMessage(0);\r\n    }\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n    {\r\n        switch (uMsg)\r\n        {\r\n        HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);\r\n        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);\r\n        default:\r\n            return DefaultProcDx();\r\n        }\r\n    }\r\n\r\n    BOOL StartDx(INT nCmdShow)\r\n    {\r\n        m_hIcon = LoadIconDx(1);\r\n        m_hIconSm = LoadSmallIconDx(1);\r\n        m_hAccel = ::LoadAccelerators(m_hInst, MAKEINTRESOURCE(1));\r\n\r\n        if (!CreateWindowDx(NULL, LoadStringDx(1)))\r\n        {\r\n            MsgBoxDx(TEXT("failure of CreateWindow"), NULL, MB_ICONERROR);\r\n            return FALSE;\r\n        }\r\n\r\n        ::ShowWindow(*this, nCmdShow);\r\n        ::UpdateWindow(*this);\r\n\r\n        return TRUE;\r\n    }\r\n\r\n    INT RunDx()\r\n    {\r\n        // message loop\r\n        MSG msg;\r\n        while (::GetMessage(&msg, NULL, 0, 0))\r\n        {\r\n            if (!::TranslateAccelerator(m_hwnd, m_hAccel, &msg))\r\n            {\r\n                ::TranslateMessage(&msg);\r\n                ::DispatchMessage(&msg);\r\n            }\r\n        }\r\n        return INT(msg.wParam);\r\n    }\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n// Win32 main function\r\n\r\nextern "C"\r\nINT APIENTRY _tWinMain(\r\n    HINSTANCE   hInstance,\r\n    HINSTANCE   hPrevInstance,\r\n    LPTSTR      lpCmdLine,\r\n    INT         nCmdShow)\r\n{\r\n    int ret = -1;\r\n\r\n    {\r\n        MMainWnd app(__argc, __targv, hInstance);\r\n\r\n        ::InitCommonControls();\r\n\r\n        if (app.StartDx(nCmdShow))\r\n        {\r\n            ret = app.RunDx();\r\n        }\r\n    }\r\n\r\n#if (WINVER >= 0x0500)\r\n    HANDLE hProcess = GetCurrentProcess();\r\n    DebugPrintDx(TEXT("Count of GDI objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_GDIOBJECTS));\r\n    DebugPrintDx(TEXT("Count of USER objects: %ld\\n"),\r\n                 GetGuiResources(hProcess, GR_USEROBJECTS));\r\n#endif\r\n\r\n#if defined(_MSC_VER) && !defined(NDEBUG)\r\n    // for detecting memory leak (MSVC only)\r\n    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\r\n#endif\r\n\r\n    return ret;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
MyProject_res.rc<>MyProject_res.rc<>#include <windows.h>\r\n#include "resource.h"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Encoding\r\n\r\n#pragma code_page(65001)    // UTF-8\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Icon\r\n\r\n1 ICON "MainIcon.ico"\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Menus\r\n\r\n1 MENU\r\n{\r\n    POPUP "&File"\r\n    {\r\n        MENUITEM "E&xit\\tAlt+F4", 1\r\n    }\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Dialogs\r\n\r\n1 DIALOG 0, 0, 215, 135\r\nCAPTION "Sample Dialog"\r\nSTYLE DS_MODALFRAME | WS_POPUPWINDOW | WS_DLGFRAME\r\nFONT 9, "MS Shell Dlg"\r\n{\r\n    DEFPUSHBUTTON "OK", IDOK, 35, 115, 60, 14\r\n    PUSHBUTTON "Cancel", IDCANCEL, 115, 115, 60, 14\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Version Info\r\n\r\nVS_VERSION_INFO VERSIONINFO\r\nFILEVERSION     0, 0, 0, 0\r\nPRODUCTVERSION  0, 0, 0, 0\r\nFILEOS          VOS_NT_WINDOWS32\r\nFILETYPE        VFT_APP\r\nBEGIN\r\n    // English (U.S.)\r\n    BLOCK "StringFileInfo"\r\n    BEGIN\r\n        BLOCK "040904E4"\r\n        BEGIN\r\n            VALUE "CompanyName", "Katayama Hirofumi MZ\\0"\r\n            VALUE "FileDescription", "MyProject\\0"\r\n            VALUE "FileVersion", "0.0\\0"\r\n            VALUE "LegalCopyright", "Copyright (C) 2018 Katayama Hirofumi MZ\\0"\r\n            VALUE "ProductName", "MyProject\\0"\r\n            VALUE "ProductVersion", "0.0\\0"\r\n        END\r\n    END\r\n    // Japanese\r\n    BLOCK "StringFileInfo"\r\n    BEGIN\r\n        BLOCK "041103A4"\r\n        BEGIN\r\n            VALUE "CompanyName", "RMZ\\0"\r\n            VALUE "FileDescription", "MyProject\\0"\r\n            VALUE "FileVersion", "0.0\\0"\r\n            VALUE "LegalCopyright", "Copyright (C) 2018 RMZ\\0"\r\n            VALUE "ProductName", "MyProject\\0"\r\n            VALUE "ProductVersion", "0.0\\0"\r\n        END\r\n    END\r\n    BLOCK "VarFileInfo"\r\n    BEGIN\r\n        // English (U.S.)\r\n        VALUE "Translation", 0x0409, 0x04E4\r\n    END\r\nEND\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n
OnMessage<>OnMessage<>LRESULT OnMessage(HWND hwnd, WPARAM wParam, LPARAM lParam)
OnMessageEx<>OnMessageEx<>LRESULT OnMessageEx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
UTF16_validator.h<>UTF16_validator.h<>/* UTF16_validator.h --- MZC4 UTF-16 Validator\r\n */\r\n\r\n#ifndef MZC4_UTF16_VALIDATOR_H_\r\n#define MZC4_UTF16_VALIDATOR_H_      3   /* Version 3 */\r\n\r\n#include "UTF8_validator.h"\r\n\r\n#ifdef __cplusplus\r\n    #include <cstring>\r\n    #include <cassert>\r\n#else\r\n    #include <string.h>\r\n    #include <assert.h>\r\n#endif\r\n\r\nbool UTF16_validate(const void *pv, size_t cb);\r\n\r\n/****************************************************************************/\r\n\r\ninline bool\r\nUTF16_validate(const void *pv, size_t cb)\r\n{\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    return !!IsTextUnicode(pv, (int)cb, NULL);\r\n#else\r\n    const WCHAR *wide_str;\r\n    int cch, k;\r\n    bool bASCII;\r\n\r\n    assert(sizeof(WCHAR) == 2);\r\n\r\n    /* check zero length */\r\n    if (cb == 0)\r\n        return true;\r\n\r\n    /* check odd length */\r\n    if ((cb & 1) != 0)\r\n        return false;\r\n\r\n    wide_str = (const WCHAR *)pv;\r\n    cch = cb / 2;\r\n\r\n    /* check BOM */\r\n    if (memcmp(pv, "\\xFE\\xFF", 2) == 0)   /* UTF-16BE */\r\n    {\r\n        return false;\r\n    }\r\n    if (memcmp(pv, "\\xFF\\xFE", 2) == 0)   /* UTF-16LE */\r\n    {\r\n        return true;\r\n    }\r\n    if (cb >= 3)\r\n    {\r\n        if (memcmp(pv, "\\xEF\\xBB\\xBF", 3) == 0)   /* UTF-8 */\r\n        {\r\n            return false;\r\n        }\r\n        if (memcmp(pv, "\\x2B\\x2F\\x76", 3) == 0)   /* UTF-7 */\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    if (cb >= 4)\r\n    {\r\n        if (memcmp(pv, "\\0\\0\\xFE\\xFF", 4) == 0)   /* UTF-32BE */\r\n        {\r\n            return false;\r\n        }\r\n        if (memcmp(pv, "\\xFF\\xFE\\0\\0", 4) == 0)   /* UTF-32LE */\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* check illegal */\r\n    for (k = 0; k < cch; ++k)\r\n    {\r\n        WCHAR wch = wide_str[k];\r\n        if (wch == 0 || wch == 0xFFFF ||\r\n            memcmp(&wch, "\\xFE\\xFF", 2) == 0 ||\r\n            memcmp(&wch, "\\r\\n", 2) == 0)\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /* check ASCII */\r\n    bASCII = true;\r\n    for (k = 0; k < cch; ++k)\r\n    {\r\n        if (wide_str[k] & 0xFF00)\r\n        {\r\n            bASCII = false;\r\n            break;\r\n        }\r\n    }\r\n    if (bASCII)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    /* check UTF-8 */\r\n    if (UTF8_validate(pv, cb))\r\n        return false;\r\n\r\n    return true;\r\n#endif\r\n} /* UTF16_validate */\r\n\r\n/****************************************************************************/\r\n\r\n#endif  /* ndef MZC4_UTF16_VALIDATOR_H_ */\r\n
UTF8_validator.h<>UTF8_validator.h<>/* UTF8_validator.h --- MZC4 UTF-8 Validator\r\n *\r\n * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>\r\n * Copyright (c) 2018 Katayama Hirofumi MZ <katayama.hirofumi.mz@gmail.com>\r\n *\r\n * See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n#ifndef MZC4_UTF8_VALIDATOR_H_\r\n#define MZC4_UTF8_VALIDATOR_H_      3   /* Version 3 */\r\n\r\n#if __cplusplus >= 201103L          /* C++11 */\r\n    #include <cstdint>\r\n#elif __STDC_VERSION__ >= 199901L   /* C99 */\r\n    #include <stdint.h>\r\n    #include <stdbool.h>\r\n#else\r\n    #include "pstdint.h"\r\n    #include "pstdbool.h"\r\n#endif\r\n\r\n/****************************************************************************/\r\n\r\n#define UTF8_ACCEPT 0\r\n#define UTF8_REJECT 1\r\n\r\ninline const uint8_t *\r\nUTF8_table(void)\r\n{\r\n    static const uint8_t utf8d[] =\r\n    {\r\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 00..1f */\r\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 20..3f */\r\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 40..5f */\r\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* 60..7f */\r\n        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, /* 80..9f */\r\n        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, /* a0..bf */\r\n        8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, /* c0..df */\r\n        0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, /* e0..ef */\r\n        0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, /* f0..ff */\r\n        0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, /* s0..s0 */\r\n        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, /* s1..s2 */\r\n        1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, /* s3..s4 */\r\n        1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, /* s5..s6 */\r\n        1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, /* s7..s8 */\r\n    };\r\n    return utf8d;\r\n}\r\n\r\ninline uint32_t\r\nUTF8_decode(uint32_t* state, uint32_t* codep, uint32_t byte)\r\n{\r\n    uint32_t type = UTF8_table()[byte];\r\n\r\n    *codep = (*state != UTF8_ACCEPT) ?\r\n        (byte & 0x3fu) | (*codep << 6) :\r\n        (0xff >> type) & (byte);\r\n\r\n    *state = UTF8_table()[256 + *state * 16 + type];\r\n    return *state;\r\n}\r\n\r\ninline bool\r\nUTF8_count_code_points(const char *str, size_t *count)\r\n{\r\n    uint32_t codepoint, state = 0;\r\n\r\n    for (*count = 0; *str; ++str)\r\n    {\r\n        if (!UTF8_decode(&state, &codepoint, *str))\r\n        {\r\n            ++(*count);\r\n        }\r\n    }\r\n\r\n    return state != UTF8_ACCEPT;\r\n}\r\n\r\ninline uint32_t\r\nUTF8_validate_state(uint32_t *state, const char *str, size_t len)\r\n{\r\n    size_t i;\r\n    uint32_t type;\r\n\r\n    for (i = 0; i < len; i++)\r\n    {\r\n        type = UTF8_table()[(uint8_t)str[i]];\r\n        *state = UTF8_table()[256 + (*state) * 16 + type];\r\n\r\n        if (*state == UTF8_REJECT)\r\n            break;\r\n    }\r\n\r\n    return *state;\r\n}\r\n\r\ninline bool\r\nUTF8_validate(const void *str, size_t len)\r\n{\r\n    uint32_t state = UTF8_ACCEPT;\r\n    return UTF8_validate_state(&state, (const char *)str, len) == UTF8_ACCEPT;\r\n}\r\n\r\n/****************************************************************************/\r\n\r\n#endif  /* ndef MZC4_UTF8_VALIDATOR_H_ */\r\n
WM_ACTIVATE<>OnActivate<>void OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized)
WM_ACTIVATEAPP<>OnActivateApp<>void OnActivateApp(HWND hwnd, BOOL fActivate, DWORD dwThreadId)
WM_ASKCBFORMATNAME<>OnAskCBFormatName<>void OnAskCBFormatName(HWND hwnd, int cchMax, LPTSTR rgchName)
WM_CANCELMODE<>OnCancelMode<>void OnCancelMode(HWND hwnd)
WM_CHANGECBCHAIN<>OnChangeCBChain<>void OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext)
WM_CHAR<>OnChar<>void OnChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_CHARTOITEM<>OnCharToItem<>int OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret)
WM_CHILDACTIVATE<>OnChildActivate<>void OnChildActivate(HWND hwnd)
WM_CLEAR<>OnClear<>void OnClear(HWND hwnd)
WM_CLOSE<>OnClose<>void OnClose(HWND hwnd)
WM_COMMAND<>OnCommand<>void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
WM_COMMNOTIFY<>OnCommNotify<>void OnCommNotify(HWND hwnd, int cid, UINT flags)
WM_COMPACTING<>OnCompacting<>void OnCompacting(HWND hwnd, UINT compactRatio)
WM_COMPAREITEM<>OnCompareItem<>int OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT * lpCompareItem)
WM_CONTEXTMENU<>OnContextMenu<>void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
WM_COPY<>OnCopy<>void OnCopy(HWND hwnd)
WM_COPYDATA<>OnCopyData<>BOOL OnCopyData(HWND hwnd, HWND hwndFrom, PCOPYDATASTRUCT pcds);
WM_CREATE<>OnCreate<>BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
WM_CTLCOLORBTN<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORDLG<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLOREDIT<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORLISTBOX<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORMSGBOX<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORSCROLLBAR<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CTLCOLORSTATIC<>OnCtlColor<>HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
WM_CUT<>OnCut<>void OnCut(HWND hwnd)
WM_DEADCHAR<>OnDeadChar<>void OnDeadChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_DELETEITEM<>OnDeleteItem<>void OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT * lpDeleteItem)
WM_DESTROY<>OnDestroy<>void OnDestroy(HWND hwnd)
WM_DESTROYCLIPBOARD<>OnDestroyClipboard<>void OnDestroyClipboard(HWND hwnd)
WM_DEVICECHANGE<>OnDeviceChange<>BOOL OnDeviceChange(HWND hwnd, UINT uEvent, DWORD dwEventData)
WM_DEVMODECHANGE<>OnDevModeChange<>void OnDevModeChange(HWND hwnd, LPCTSTR lpszDeviceName)
WM_DISPLAYCHANGE<>OnDisplayChange<>void OnDisplayChange(HWND hwnd, UINT bitsPerPixel, UINT cxScreen, UINT cyScreen)
WM_DRAWCLIPBOARD<>OnDrawClipboard<>void OnDrawClipboard(HWND hwnd)
WM_DRAWITEM<>OnDrawItem<>void OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
WM_DROPFILES<>OnDropFiles<>void OnDropFiles(HWND hwnd, HDROP hdrop)
WM_ENABLE<>OnEnable<>void OnEnable(HWND hwnd, BOOL fEnable)
WM_ENDSESSION<>OnEndSession<>void OnEndSession(HWND hwnd, BOOL fEnding)
WM_ENTERIDLE<>OnEnterIdle<>void OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource)
WM_ERASEBKGND<>OnEraseBkgnd<>BOOL OnEraseBkgnd(HWND hwnd, HDC hdc)
WM_FONTCHANGE<>OnFontChange<>void OnFontChange(HWND hwnd)
WM_GETDLGCODE<>OnGetDlgCode<>UINT OnGetDlgCode(HWND hwnd, LPMSG lpmsg)
WM_GETFONT<>OnGetFont<>HFONT OnGetFont(HWND hwnd)
WM_GETMINMAXINFO<>OnGetMinMaxInfo<>void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpMinMaxInfo)
WM_GETTEXT<>OnGetText<>INT OnGetText(HWND hwnd, int cchTextMax, LPTSTR lpszText)
WM_GETTEXTLENGTH<>OnGetTextLength<>INT OnGetTextLength(HWND hwnd)
WM_HOTKEY<>OnHotKey<>void OnHotKey(HWND hwnd, int idHotKey, UINT fuModifiers, UINT vk)
WM_HSCROLL<>OnHScroll<>void OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
WM_HSCROLLCLIPBOARD<>OnHScrollClipboard<>void OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos)
WM_ICONERASEBKGND<>OnIconEraseBkgnd<>BOOL OnIconEraseBkgnd(HWND hwnd, HDC hdc)
WM_INITDIALOG<>OnInitDialog<>BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
WM_INITMENU<>OnInitMenu<>void OnInitMenu(HWND hwnd, HMENU hMenu)
WM_INITMENUPOPUP<>OnInitMenuPopup<>void OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
WM_KEYDOWN<>OnKey<>void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_KEYUP<>OnKey<>void OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_KILLFOCUS<>OnKillFocus<>void OnKillFocus(HWND hwnd, HWND hwndNewFocus)
WM_LBUTTONDBLCLK<>OnLButtonDown<>void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_LBUTTONDOWN<>OnLButtonDown<>void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_LBUTTONUP<>OnLButtonUp<>void OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
WM_MBUTTONDBLCLK<>OnMButtonDown<>void OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_MBUTTONDOWN<>OnMButtonDown<>void OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_MBUTTONUP<>OnMButtonUp<>void OnMButtonUp(HWND hwnd, int x, int y, UINT flags)
WM_MDIACTIVATE<>MDIActivate<>void MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate)
WM_MDICASCADE<>MDICascade<>BOOL MDICascade(HWND hwnd, UINT cmd)
WM_MDICREATE<>MDICreate<>HWND MDICreate(HWND hwnd, const LPMDICREATESTRUCT lpmcs)
WM_MDIDESTROY<>MDIDestroy<>void MDIDestroy(HWND hwnd, HWND hwndDestroy)
WM_MDIGETACTIVE<>MDIGetActive<>HWND MDIGetActive(HWND hwnd)
WM_MDIICONARRANGE<>MDIIconArrange<>void MDIIconArrange(HWND hwnd)
WM_MDIMAXIMIZE<>MDIMaximize<>void MDIMaximize(HWND hwnd, HWND hwndMaximize)
WM_MDINEXT<>MDINext<>HWND MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev)
WM_MDIRESTORE<>MDIRestore<>void MDIRestore(HWND hwnd, HWND hwndRestore)
WM_MDISETMENU<>MDISetMenu<>HMENU MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow)
WM_MDITILE<>MDITile<>BOOL MDITile(HWND hwnd, UINT cmd)
WM_MEASUREITEM<>OnMeasureItem<>void OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpMeasureItem)
WM_MENUCHAR<>OnMenuChar<>DWORD OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu)
WM_MENUSELECT<>OnMenuSelect<>void OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
WM_MOUSEACTIVATE<>OnMouseActivate<>int OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg)
WM_MOUSEMOVE<>OnMouseMove<>void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
WM_MOUSEWHEEL<>OnMouseWheel<>void OnMouseWheel(HWND hwnd, int xPos, int yPos, int zDelta, UINT fwKeys)
WM_MOVE<>OnMove<>void OnMove(HWND hwnd, int x, int y)
WM_NCACTIVATE<>OnNCActivate<>BOOL OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized)
WM_NCCALCSIZE<>OnNCCalcSize<>UINT OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS * lpcsp)
WM_NCCREATE<>OnNCCreate<>BOOL OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
WM_NCDESTROY<>OnNCDestroy<>void OnNCDestroy(HWND hwnd)
WM_NCHITTEST<>OnNCHitTest<>UINT OnNCHitTest(HWND hwnd, int x, int y)
WM_NCLBUTTONDBLCLK<>OnNCLButtonDown<>void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCLBUTTONDOWN<>OnNCLButtonDown<>void OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCLBUTTONUP<>OnNCLButtonUp<>void OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCMBUTTONDBLCLK<>OnNCMButtonDown<>void OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCMBUTTONDOWN<>OnNCMButtonDown<>void OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCMBUTTONUP<>OnNCMButtonUp<>void OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCMOUSEMOVE<>OnNCMouseMove<>void OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NCPAINT<>OnNCPaint<>void OnNCPaint(HWND hwnd, HRGN hrgn)
WM_NCRBUTTONDBLCLK<>OnNCRButtonDown<>void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCRBUTTONDOWN<>OnNCRButtonDown<>void OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest)
WM_NCRBUTTONUP<>OnNCRButtonUp<>void OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest)
WM_NEXTDLGCTL<>OnNextDlgCtl<>HWND OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext)
WM_NOTIFY<>OnNotify<>LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
WM_PAINT<>OnPaint<>void OnPaint(HWND hwnd)
WM_PAINTCLIPBOARD<>OnPaintClipboard<>void OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const LPPAINTSTRUCT lpPaintStruct)
WM_PALETTECHANGED<>OnPaletteChanged<>void OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange)
WM_PALETTEISCHANGING<>OnPaletteIsChanging<>void OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange)
WM_PARENTNOTIFY<>OnParentNotify<>void OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild)
WM_PASTE<>OnPaste<>void OnPaste(HWND hwnd)
WM_POWER<>OnPower<>void OnPower(HWND hwnd, int code)
WM_QUERYDRAGICON<>OnQueryDragIcon<>HICON OnQueryDragIcon(HWND hwnd)
WM_QUERYENDSESSION<>OnQueryEndSession<>BOOL OnQueryEndSession(HWND hwnd)
WM_QUERYNEWPALETTE<>OnQueryNewPalette<>BOOL OnQueryNewPalette(HWND hwnd)
WM_QUERYOPEN<>OnQueryOpen<>BOOL OnQueryOpen(HWND hwnd)
WM_QUEUESYNC<>OnQueueSync<>void OnQueueSync(HWND hwnd)
WM_QUIT<>OnQuit<>void OnQuit(HWND hwnd, int exitCode)
WM_RBUTTONDBLCLK<>OnRButtonDown<>void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_RBUTTONDOWN<>OnRButtonDown<>void OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
WM_RBUTTONUP<>OnRButtonUp<>void OnRButtonUp(HWND hwnd, int x, int y, UINT flags)
WM_RENDERALLFORMATS<>OnRenderAllFormats<>void OnRenderAllFormats(HWND hwnd)
WM_RENDERFORMAT<>OnRenderFormat<>HANDLE OnRenderFormat(HWND hwnd, UINT fmt)
WM_SETCURSOR<>OnSetCursor<>BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
WM_SETFOCUS<>OnSetFocus<>void OnSetFocus(HWND hwnd, HWND hwndOldFocus)
WM_SETFONT<>OnSetFont<>void OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw)
WM_SETREDRAW<>OnSetRedraw<>void OnSetRedraw(HWND hwnd, BOOL fRedraw)
WM_SETTEXT<>OnSetText<>void OnSetText(HWND hwnd, LPCTSTR lpszText)
WM_SHOWWINDOW<>OnShowWindow<>void OnShowWindow(HWND hwnd, BOOL fShow, UINT status)
WM_SIZE<>OnSize<>void OnSize(HWND hwnd, UINT state, int cx, int cy)
WM_SIZECLIPBOARD<>OnSizeClipboard<>void OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const LPRECT lprc)
WM_SPOOLERSTATUS<>OnSpoolerStatus<>void OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue)
WM_SYSCHAR<>OnSysChar<>void OnSysChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_SYSCOLORCHANGE<>OnSysColorChange<>void OnSysColorChange(HWND hwnd)
WM_SYSCOMMAND<>OnSysCommand<>void OnSysCommand(HWND hwnd, UINT cmd, int x, int y)
WM_SYSDEADCHAR<>OnSysDeadChar<>void OnSysDeadChar(HWND hwnd, TCHAR ch, int cRepeat)
WM_SYSKEYDOWN<>OnSysKey<>void OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_SYSKEYUP<>OnSysKey<>void OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
WM_SYSTEMERROR<>OnSystemError<>void OnSystemError(HWND hwnd, int errCode)
WM_TIMECHANGE<>OnTimeChange<>void OnTimeChange(HWND hwnd)
WM_TIMER<>OnTimer<>void OnTimer(HWND hwnd, UINT id)
WM_UNDO<>OnUndo<>void OnUndo(HWND hwnd)
WM_VKEYTOITEM<>OnVkeyToItem<>int OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret)
WM_VSCROLL<>OnVScroll<>void OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
WM_VSCROLLCLIPBOARD<>OnVScrollClipboard<>void OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos)
WM_WINDOWPOSCHANGED<>OnWindowPosChanged<>void OnWindowPosChanged(HWND hwnd, const LPWINDOWPOS lpwpos)
WM_WINDOWPOSCHANGING<>OnWindowPosChanging<>BOOL OnWindowPosChanging(HWND hwnd, LPWINDOWPOS lpwpos)
WM_WININICHANGE<>OnWinIniChange<>void OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
WinMain<>WinMain<>INT WINAPI\r\nWinMain(HINSTANCE   hInstance,\r\n        HINSTANCE   hPrevInstance,\r\n        LPSTR       lpCmdLine,\r\n        INT         nCmdShow)
WindowProc<>WindowProc<>LRESULT CALLBACK\r\nWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
WindowProcDx<>WindowProcDx<>virtual LRESULT CALLBACK\r\nWindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
_tWinMain<>_tWinMain<>extern "C" INT WINAPI\r\n_tWinMain(HINSTANCE   hInstance,\r\n          HINSTANCE   hPrevInstance,\r\n          LPTSTR      lpCmdLine,\r\n          INT         nCmdShow)
afxres.h<>afxres.h<>// afxres.h --- MZC4 resource header                            -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_AFXRES_H_\r\n#define MZC4_AFXRES_H_\r\n\r\n#include <windows.h>\r\n#include <commctrl.h>\r\n\r\n#ifndef IDC_STATIC\r\n    #define IDC_STATIC  -1\r\n#endif\r\n\r\n#ifndef MANIFEST\r\n    #define MANIFEST    24\r\n#endif\r\n\r\n#endif  /* ndef MZC4_AFXRES_H_ */\r\n
pstdbool.h<>pstdbool.h<>/* pstdbool.h --- MZC4 portable standard boolean */\r\n/* Written by katahiromz <katayama.hirofumi.mz@gmail.com>. */\r\n/* You can use this as replacement of <stdbool.h> and <cstdbool>. */\r\n/* This file is public domain software (PDS). */\r\n#ifndef __bool_true_false_are_defined\r\n    #ifdef __cplusplus\r\n        /* already defined */\r\n    #elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)\r\n        #include <stdbool.h>\r\n    #else\r\n        #define true        1\r\n        #define false       0\r\n        typedef signed char bool;\r\n    #endif\r\n    #define __bool_true_false_are_defined   1\r\n#endif  /* ndef __bool_true_false_are_defined */\r\n
pstdint.h<>pstdint.h<>/* pstdint.h -- portable standard integers                      -*- C++ -*- */\r\n/* This file is part of MZC4.  See file "ReadMe.txt" and "License.txt". */\r\n/****************************************************************************/\r\n\r\n#ifndef MZC4_PSTDINT_H_\r\n#define MZC4_PSTDINT_H_     16   /* Version 16 */\r\n\r\n#if __cplusplus >= 201103L\r\n    #include <cstdint>\r\n#elif __STDC_VERSION__ >= 199901L\r\n    #include <stdint.h>\r\n#elif defined(_WIN32) && !defined(WONVER)\r\n    #ifndef _INC_WINDOWS\r\n        #include <windows.h>\r\n    #endif\r\n    typedef signed char int8_t;\r\n    typedef SHORT       int16_t;\r\n    typedef INT         int32_t;\r\n    typedef LONGLONG    int64_t;\r\n    typedef BYTE        uint8_t;\r\n    typedef WORD        uint16_t;\r\n    typedef UINT        uint32_t;\r\n    typedef DWORDLONG   uint64_t;\r\n#else\r\n    #ifdef __cplusplus\r\n        #include <cstddef>\r\n        #include <climits>\r\n    #else\r\n        #include <stddef.h>\r\n        #include <limits.h>\r\n    #endif\r\n    #ifndef INT8_MIN\r\n        #define INT8_MIN (-128)\r\n        #define INT8_MAX 127\r\n        #define UINT8_MAX 0xFF\r\n    #endif\r\n    #ifndef INT16_MIN\r\n        #define INT16_MIN (-32768)\r\n        #define INT16_MAX 32767\r\n        #define UINT16_MAX 0xFFFF\r\n    #endif\r\n    #ifndef INT32_MIN\r\n        #define INT32_MIN (-2147483647 - 1)\r\n        #define INT32_MAX 2147483647\r\n        #define UINT32_MAX 0xFFFFFFFF\r\n    #endif\r\n    typedef signed char                 int8_t;\r\n    typedef unsigned char               uint8_t;\r\n    typedef short                       int16_t;\r\n    typedef unsigned short              uint16_t;\r\n    #ifdef MSDOS\r\n        typedef long                    int32_t;\r\n        typedef unsigned long           uint32_t;\r\n    #else\r\n        typedef int                     int32_t;\r\n        typedef unsigned int            uint32_t;\r\n        #ifndef INT64_MAX\r\n            #ifdef _I64_MAX\r\n                #define INT64_MIN _I64_MIN\r\n                #define INT64_MAX _I64_MAX\r\n                #define UINT64_MAX _UI64_MAX\r\n                typedef __int64             int64_t;\r\n                typedef unsigned __int64    uint64_t;\r\n            #else\r\n                #if defined(__LP64__) && !defined(__APPLE__)\r\n                    #define INT64_MIN (-9223372036854775807L - 1)\r\n                    #define INT64_MAX 9223372036854775807L\r\n                    #define UINT64_MAX 0xFFFFFFFFFFFFFFFFL\r\n                    typedef long           int64_t;\r\n                    typedef unsigned long  uint64_t;\r\n                #else\r\n                    #define INT64_MIN (-9223372036854775807LL - 1)\r\n                    #define INT64_MAX 9223372036854775807LL\r\n                    #define UINT64_MAX 0xFFFFFFFFFFFFFFFFLL\r\n                    typedef long long           int64_t;\r\n                    typedef unsigned long long  uint64_t;\r\n                #endif\r\n            #endif\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\ntypedef char MZC4_PSTDINT_TEST_01_[(sizeof(int8_t) == 1) ? 1 : -1];\r\ntypedef char MZC4_PSTDINT_TEST_02_[(sizeof(uint8_t) == 1) ? 1 : -1];\r\ntypedef char MZC4_PSTDINT_TEST_03_[(sizeof(int16_t) == 2) ? 1 : -1];\r\ntypedef char MZC4_PSTDINT_TEST_04_[(sizeof(uint16_t) == 2) ? 1 : -1];\r\ntypedef char MZC4_PSTDINT_TEST_05_[(sizeof(int32_t) == 4) ? 1 : -1];\r\ntypedef char MZC4_PSTDINT_TEST_06_[(sizeof(uint32_t) == 4) ? 1 : -1];\r\n#ifndef MSDOS\r\n    typedef char MZC4_PSTDINT_TEST_07_[(sizeof(int64_t) == 8) ? 1 : -1];\r\n    typedef char MZC4_PSTDINT_TEST_08_[(sizeof(uint64_t) == 8) ? 1 : -1];\r\n#endif\r\n\r\n/****************************************************************************/\r\n\r\n#endif  /* ndef MZC4_PSTDINT_H_ */\r\n
targetver.h<>targetver.h<>// targetver.h --- target versioning header for Win             -*- C++ -*-\r\n//////////////////////////////////////////////////////////////////////////////\r\n\r\n// targetver.h is used to define the Win32API macros that target the \r\n// version of the Win you wish to support.\r\n\r\n// For Win95\r\n//#define WINVER          0x0400\r\n//#define _WIN32_WINDOWS  0x0400\r\n//#define _WIN32_WINNT    0x0400\r\n//#define _WIN32_IE       0x0300\r\n\r\n// For Win98\r\n//#define WINVER          0x0410\r\n//#define _WIN32_WINDOWS  0x0410\r\n//#define _WIN32_WINNT    0x0410\r\n//#define _WIN32_IE       0x0401\r\n\r\n// For WinNT4\r\n//#define WINVER          0x0400\r\n//#define _WIN32_WINNT    0x0400\r\n//#define _WIN32_IE       0x0200\r\n//#define NTDDI_VERSION   0x05000000\r\n\r\n// For WinME\r\n//#define WINVER          0x0500\r\n//#define _WIN32_WINNT    0x0500\r\n//#define _WIN32_IE       0x0500\r\n\r\n// For Win2000\r\n//#define WINVER          0x0500\r\n//#define _WIN32_WINNT    0x0500\r\n//#define _WIN32_IE       0x0500\r\n//#define NTDDI_VERSION   0x05000000\r\n\r\n// For WinXP\r\n#define WINVER          0x0501\r\n#define _WIN32_WINNT    0x0501\r\n#define _WIN32_IE       0x0501\r\n#define NTDDI_VERSION   0x05010000\r\n\r\n// For WinVista\r\n//#define WINVER          0x0600\r\n//#define _WIN32_WINNT    0x0600\r\n//#define _WIN32_IE       0x0600\r\n//#define NTDDI_VERSION   0x06000000\r\n\r\n// For Win7\r\n//#define WINVER          0x0601\r\n//#define _WIN32_WINNT    0x0601\r\n//#define _WIN32_IE       0x0601\r\n//#define NTDDI_VERSION   0x06010000\r\n\r\n// For Win8.1\r\n//#define WINVER          0x0602\r\n//#define _WIN32_WINNT    0x0602\r\n//#define _WIN32_IE       0x0602\r\n//#define NTDDI_VERSION   0x06030000\r\n\r\n// For Win10\r\n//#define WINVER          0x0A00\r\n//#define _WIN32_WINNT    0x0A00\r\n//#define _WIN32_IE       0x0A00\r\n//#define NTDDI_VERSION   0x0A000000\r\n\r\n// Users of Visual Studio 10+ can do this instead\r\n// #include "SDKDDKver.h"\r\n\r\n//////////////////////////////////////////////////////////////////////////////\r\n
wWinMain<>wWinMain<>extern "C" INT WINAPI\r\nwWinMain(HINSTANCE   hInstance,\r\n         HINSTANCE   hPrevInstance,\r\n         LPWSTR      lpCmdLine,\r\n         INT         nCmdShow)
wondef.h<>wondef.h<>/* wondef.h --- Wonders API by katahiromz */\r\n/**************************************************************************/\r\n\r\n#ifndef WONDEF_H\r\n#define WONDEF_H    2  /* Version 2 */\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    #include <windows.h>\r\n#else\r\n\r\n#include "wonnt.h"\r\n\r\n#define MAX_PATH 260\r\n\r\n#ifndef NULL\r\n    #ifdef __cplusplus\r\n        #ifdef _WIN64\r\n            #define NULL 0LL\r\n        #else\r\n            #define NULL 0\r\n        #endif\r\n    #else\r\n        #define NULL ((void *)0)\r\n    #endif\r\n#endif\r\n\r\n#ifndef FALSE\r\n    #define FALSE 0\r\n#endif\r\n\r\n#ifndef TRUE\r\n    #define TRUE 1\r\n#endif\r\n\r\n#ifndef MAKEWORD\r\n    #define MAKEWORD(a,b) ((WORD) (((BYTE) (((DWORD_PTR) (a)) & 0xff)) | ((WORD) ((BYTE) (((DWORD_PTR) (b)) & 0xff))) << 8))\r\n    #define MAKELONG(a, b) ((LONG) (((WORD) (((DWORD_PTR) (a)) & 0xffff)) | ((DWORD) ((WORD) (((DWORD_PTR) (b)) & 0xffff))) << 16))\r\n    #define LOWORD(l) ((WORD) (((DWORD_PTR) (l)) & 0xffff))\r\n    #define HIWORD(l) ((WORD) ((((DWORD_PTR) (l)) >> 16) & 0xffff))\r\n    #define LOBYTE(w) ((BYTE) (((DWORD_PTR) (w)) & 0xff))\r\n    #define HIBYTE(w) ((BYTE) ((((DWORD_PTR) (w)) >> 8) & 0xff))\r\n#endif\r\n\r\n#endif  /* !(defined(_WIN32) && !defined(WONVER)) */\r\n#endif  /* ndef WONDEF_H */\r\n
wonnt.h<>wonnt.h<>/* wonnt.h --- Wonders API by katahiromz */\r\n/**************************************************************************/\r\n\r\n#ifndef WONNT_H\r\n#define WONNT_H     14  /* Version 14 */\r\n\r\n#if defined(_WIN32) && !defined(WONVER)\r\n    #include <windows.h>\r\n#else\r\n\r\n/**************************************************************************/\r\n\r\n#ifndef WINAPI\r\n    #define WINAPI      /*empty*/\r\n    #define WINAPIV     /*empty*/\r\n#endif\r\n\r\n#ifndef NTAPI\r\n    #define NTAPI       /*empty*/\r\n#endif\r\n\r\n/**************************************************************************/\r\n\r\n#if __cplusplus >= 201103L\r\n    #include <cstdint>\r\n#elif __STDC_VERSION__ >= 199901L\r\n    #include <stdint.h>\r\n#else\r\n    #include "pstdint.h"\r\n#endif\r\n\r\ntypedef char CHAR;\r\ntypedef signed char SCHAR;\r\ntypedef uint8_t BYTE, UCHAR;\r\ntypedef int16_t SHORT;\r\ntypedef uint16_t WORD, USHORT;\r\ntypedef int32_t LONG;\r\ntypedef uint32_t DWORD, ULONG;\r\ntypedef int32_t INT, BOOL;\r\ntypedef uint32_t UINT;\r\ntypedef int64_t LONGLONG;\r\ntypedef uint64_t ULONGLONG, DWORDLONG;\r\n\r\n/* WCHAR */\r\n#ifndef __WCHAR_DEFINED\r\n    #define __WCHAR_DEFINED\r\n    #ifdef _WIN32\r\n        typedef wchar_t WCHAR;\r\n    #else\r\n        #if __cplusplus >= 201103L\r\n            typedef char16_t WCHAR;\r\n        #else\r\n            typedef uint16_t WCHAR;\r\n        #endif\r\n    #endif\r\n#endif\r\n\r\n#if defined(_WIN64) || defined(__LP64__) || defined(_LP64)\r\n    typedef int64_t LONG_PTR;\r\n    typedef uint64_t ULONG_PTR, DWORD_PTR;\r\n#else\r\n    typedef LONG LONG_PTR;\r\n    typedef ULONG ULONG_PTR, DWORD_PTR;\r\n#endif\r\n\r\ntypedef BYTE BOOLEAN;\r\n\r\n#ifdef UNICODE\r\n    typedef WCHAR TCHAR;\r\n#else\r\n    typedef char TCHAR;\r\n#endif\r\n\r\ntypedef void *HANDLE;\r\ntypedef INT HFILE;\r\n\r\n#define C_ASSERT(x)  typedef char WONNT_STATIC_ASSERT_##__LINE__[(x) ? 1 : -1]\r\n\r\nC_ASSERT(sizeof(CHAR) == 1);\r\nC_ASSERT(sizeof(SCHAR) == 1);\r\nC_ASSERT(sizeof(UCHAR) == 1);\r\nC_ASSERT(sizeof(BYTE) == 1);\r\n\r\nC_ASSERT(sizeof(SHORT) == 2);\r\nC_ASSERT(sizeof(USHORT) == 2);\r\nC_ASSERT(sizeof(WORD) == 2);\r\n\r\nC_ASSERT(sizeof(LONG) == 4);\r\nC_ASSERT(sizeof(ULONG) == 4);\r\nC_ASSERT(sizeof(DWORD) == 4);\r\n\r\nC_ASSERT(sizeof(LONGLONG) == 8);\r\nC_ASSERT(sizeof(ULONGLONG) == 8);\r\nC_ASSERT(sizeof(DWORDLONG) == 8);\r\n\r\nC_ASSERT(sizeof(INT) == sizeof(int));\r\nC_ASSERT(sizeof(UINT) == sizeof(unsigned int));\r\n\r\nC_ASSERT(sizeof(BOOL) == 4);\r\nC_ASSERT(sizeof(BOOLEAN) == 1);\r\n\r\nC_ASSERT(sizeof(HANDLE) == sizeof(void *));\r\n\r\nC_ASSERT(sizeof(WCHAR) == 2);\r\n\r\ntypedef WORD LANGID;\r\n\r\n#define MAKELANGID(p, s)       ((((WORD)(s)) << 10) | (WORD)(p))\r\n#define PRIMARYLANGID(lgid)    ((WORD)(lgid) & 0x3ff)\r\n#define SUBLANGID(lgid)        ((WORD)(lgid) >> 10)\r\n\r\n/**************************************************************************/\r\n\r\n#define IMAGE_DOS_SIGNATURE 0x5A4D\r\ntypedef struct {\r\n    WORD e_magic;\r\n    WORD e_cblp;\r\n    WORD e_cp;\r\n    WORD e_crlc;\r\n    WORD e_cparhdr;\r\n    WORD e_minalloc;\r\n    WORD e_maxalloc;\r\n    WORD e_ss;\r\n    WORD e_sp;\r\n    WORD e_csum;\r\n    WORD e_ip;\r\n    WORD e_cs;\r\n    WORD e_lfarlc;\r\n    WORD e_ovno;\r\n    WORD e_res[4];\r\n    WORD e_oemid;\r\n    WORD e_oeminfo;\r\n    WORD e_res2[10];\r\n    LONG e_lfanew;\r\n} IMAGE_DOS_HEADER;\r\n\r\ntypedef struct {\r\n    WORD Machine;\r\n    WORD NumberOfSections;\r\n    DWORD TimeDateStamp;\r\n    DWORD PointerToSymbolTable;\r\n    DWORD NumberOfSymbols;\r\n    WORD SizeOfOptionalHeader;\r\n    WORD Characteristics;\r\n} IMAGE_FILE_HEADER;\r\n\r\n#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16\r\n\r\ntypedef struct {\r\n    DWORD VirtualAddress;\r\n    DWORD Size;\r\n} IMAGE_DATA_DIRECTORY;\r\n\r\ntypedef struct {\r\n    WORD Magic;\r\n    BYTE MajorLinkerVersion;\r\n    BYTE MinorLinkerVersion;\r\n    DWORD SizeOfCode;\r\n    DWORD SizeOfInitializedData;\r\n    DWORD SizeOfUninitializedData;\r\n    DWORD AddressOfEntryPoint;\r\n    DWORD BaseOfCode;\r\n    DWORD BaseOfData;\r\n    DWORD ImageBase;\r\n    DWORD SectionAlignment;\r\n    DWORD FileAlignment;\r\n    WORD MajorOperatingSystemVersion;\r\n    WORD MinorOperatingSystemVersion;\r\n    WORD MajorImageVersion;\r\n    WORD MinorImageVersion;\r\n    WORD MajorSubsystemVersion;\r\n    WORD MinorSubsystemVersion;\r\n    DWORD Win32VersionValue;\r\n    DWORD SizeOfImage;\r\n    DWORD SizeOfHeaders;\r\n    DWORD CheckSum;\r\n    WORD Subsystem;\r\n    WORD DllCharacteristics;\r\n    DWORD SizeOfStackReserve;\r\n    DWORD SizeOfStackCommit;\r\n    DWORD SizeOfHeapReserve;\r\n    DWORD SizeOfHeapCommit;\r\n    DWORD LoaderFlags;\r\n    DWORD NumberOfRvaAndSizes;\r\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\r\n} IMAGE_OPTIONAL_HEADER32;\r\n\r\ntypedef struct {\r\n    WORD Magic;\r\n    BYTE MajorLinkerVersion;\r\n    BYTE MinorLinkerVersion;\r\n    DWORD SizeOfCode;\r\n    DWORD SizeOfInitializedData;\r\n    DWORD SizeOfUninitializedData;\r\n    DWORD AddressOfEntryPoint;\r\n    DWORD BaseOfCode;\r\n    ULONGLONG ImageBase;\r\n    DWORD SectionAlignment;\r\n    DWORD FileAlignment;\r\n    WORD MajorOperatingSystemVersion;\r\n    WORD MinorOperatingSystemVersion;\r\n    WORD MajorImageVersion;\r\n    WORD MinorImageVersion;\r\n    WORD MajorSubsystemVersion;\r\n    WORD MinorSubsystemVersion;\r\n    DWORD Win32VersionValue;\r\n    DWORD SizeOfImage;\r\n    DWORD SizeOfHeaders;\r\n    DWORD CheckSum;\r\n    WORD Subsystem;\r\n    WORD DllCharacteristics;\r\n    ULONGLONG SizeOfStackReserve;\r\n    ULONGLONG SizeOfStackCommit;\r\n    ULONGLONG SizeOfHeapReserve;\r\n    ULONGLONG SizeOfHeapCommit;\r\n    DWORD LoaderFlags;\r\n    DWORD NumberOfRvaAndSizes;\r\n    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\r\n} IMAGE_OPTIONAL_HEADER64;\r\n\r\n#define IMAGE_NT_SIGNATURE 0x00004550\r\ntypedef struct {\r\n    DWORD Signature;\r\n    IMAGE_FILE_HEADER FileHeader;\r\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\r\n} IMAGE_NT_HEADERS32;\r\ntypedef struct {\r\n    DWORD Signature;\r\n    IMAGE_FILE_HEADER FileHeader;\r\n    IMAGE_OPTIONAL_HEADER64 OptionalHeader;\r\n} IMAGE_NT_HEADERS64;\r\n\r\n#ifdef _WIN64\r\n    typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;\r\n    typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;\r\n#else\r\n    typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;\r\n    typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;\r\n#endif\r\n\r\n#define IMAGE_DIRECTORY_ENTRY_EXPORT 0\r\n#define IMAGE_DIRECTORY_ENTRY_IMPORT 1\r\n#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2\r\n#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3\r\n#define IMAGE_DIRECTORY_ENTRY_SECURITY 4\r\n#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5\r\n#define IMAGE_DIRECTORY_ENTRY_DEBUG 6\r\n#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7\r\n#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8\r\n#define IMAGE_DIRECTORY_ENTRY_TLS 9\r\n#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10\r\n#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11\r\n#define IMAGE_DIRECTORY_ENTRY_IAT 12\r\n#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13\r\n#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14\r\n\r\ntypedef struct {\r\n    union {\r\n        DWORD Characteristics;\r\n        DWORD OriginalFirstThunk;\r\n    };\r\n    DWORD TimeDateStamp;\r\n\r\n    DWORD ForwarderChain;\r\n    DWORD Name;\r\n    DWORD FirstThunk;\r\n} IMAGE_IMPORT_DESCRIPTOR;\r\n\r\ntypedef struct {\r\n    DWORD Characteristics;\r\n    DWORD TimeDateStamp;\r\n    WORD MajorVersion;\r\n    WORD MinorVersion;\r\n    DWORD Name;\r\n    DWORD Base;\r\n    DWORD NumberOfFunctions;\r\n    DWORD NumberOfNames;\r\n    DWORD AddressOfFunctions;\r\n    DWORD AddressOfNames;\r\n    DWORD AddressOfNameOrdinals;\r\n} IMAGE_EXPORT_DIRECTORY;\r\n\r\n#define IMAGE_SIZEOF_SHORT_NAME 8\r\n\r\ntypedef struct {\r\n    BYTE Name[IMAGE_SIZEOF_SHORT_NAME];\r\n    union {\r\n        DWORD PhysicalAddress;\r\n        DWORD VirtualSize;\r\n    } Misc;\r\n    DWORD VirtualAddress;\r\n    DWORD SizeOfRawData;\r\n    DWORD PointerToRawData;\r\n    DWORD PointerToRelocations;\r\n    DWORD PointerToLinenumbers;\r\n    WORD NumberOfRelocations;\r\n    WORD NumberOfLinenumbers;\r\n    DWORD Characteristics;\r\n} IMAGE_SECTION_HEADER;\r\n\r\n#define IMAGE_ORDINAL_FLAG64 0x8000000000000000ull\r\n#define IMAGE_ORDINAL_FLAG32 0x80000000\r\n#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffffull)\r\n#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)\r\n#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64)!=0)\r\n#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32)!=0)\r\n\r\ntypedef struct {\r\n    WORD Hint;\r\n    BYTE Name[1];\r\n} IMAGE_IMPORT_BY_NAME;\r\n\r\n#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000\r\n#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000\r\n\r\ntypedef struct {\r\n    DWORD   Characteristics;\r\n    DWORD   TimeDateStamp;\r\n    WORD    MajorVersion;\r\n    WORD    MinorVersion;\r\n    WORD    NumberOfNamedEntries;\r\n    WORD    NumberOfIdEntries;\r\n} IMAGE_RESOURCE_DIRECTORY;\r\n\r\ntypedef struct {\r\n    union {\r\n        struct {\r\n            DWORD NameOffset:31;\r\n            DWORD NameIsString:1;\r\n        };\r\n        DWORD   Name;\r\n        WORD    Id;\r\n    };\r\n    union {\r\n        DWORD   OffsetToData;\r\n        struct {\r\n            DWORD   OffsetToDirectory:31;\r\n            DWORD   DataIsDirectory:1;\r\n        };\r\n    };\r\n} IMAGE_RESOURCE_DIRECTORY_ENTRY;\r\n\r\n/**************************************************************************/\r\n\r\n#ifndef FIELD_OFFSET\r\n    #define FIELD_OFFSET(type, field) \\\r\n        ((LONG)(LONG_PTR)&(((type *)0)->field))\r\n#endif\r\n\r\n#ifndef RTL_FIELD_SIZE\r\n    #define RTL_FIELD_SIZE(type, field) \\\r\n        (sizeof(((type *)0)->field))\r\n#endif\r\n\r\n#ifndef RTL_SIZEOF_THROUGH_FIELD\r\n    #define RTL_SIZEOF_THROUGH_FIELD(type, field) \\\r\n        (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))\r\n#endif\r\n\r\n#ifndef IMAGE_FIRST_SECTION\r\n    #define IMAGE_FIRST_SECTION(nt) ((IMAGE_SECTION_HEADER *)             \\\r\n        ((ULONG_PTR)nt + FIELD_OFFSET(IMAGE_NT_HEADERS, OptionalHeader) + \\\r\n         ((IMAGE_NT_HEADERS *)(nt))->FileHeader.SizeOfOptionalHeader))\r\n#endif\r\n\r\n/**************************************************************************/\r\n\r\n#endif  /* !(defined(_WIN32) && !defined(_WONVER)) */\r\n#endif  /* ndef WONNT_H */\r\n
MOleCtrl.hpp<>MOleCtrl.hpp<>// MOleCtrl.hpp -- Win32API OLE control wrapper                 -*- C++ -*-\r\n// This file is part of MZC4.  See file "ReadMe.txt" and "License.txt".\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef MZC4_MOLECTRL_HPP_\r\n#define MZC4_MOLECTRL_HPP_      28      /* Version 28 */\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#include "MWindowBase.hpp"\r\n\r\n#include <cguid.h>      // for IID_NULL\r\n#include <exdisp.h>\r\n#include <ocidl.h>\r\n\r\nstruct MVariant;\r\nclass MOleCtrl;\r\n\r\nstruct MDispException;\r\n\r\nvoid MZCAPI\r\nInvokeDx(IDispatch *disp, const WCHAR *pszName, UINT cArgs, VARIANT *pArray,\r\n         WORD wFlags = DISPATCH_METHOD,\r\n         VARIANT *pResult = NULL); // throws MDispException\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MVariant --- the variant class (VARIANT wrapper)\r\n\r\nstruct MVariant : VARIANT\r\n{\r\n    MVariant()\r\n    {\r\n        vt = VT_EMPTY;\r\n    }\r\n\r\n    MVariant(LONG i4)\r\n    {\r\n        vt = VT_I4;\r\n        lVal = i4;\r\n    }\r\n\r\n    MVariant(const WCHAR *psz)\r\n    {\r\n        vt = VT_BSTR;\r\n        bstrVal = ::SysAllocString(psz);\r\n    }\r\n\r\n    MVariant(const void *pv, UINT cb);\r\n\r\n    MVariant(IUnknown *punk)\r\n    {\r\n        vt = VT_UNKNOWN;\r\n        punkVal = punk;\r\n        punkVal->AddRef();\r\n    }\r\n\r\n    MVariant(IDispatch *pdisp)\r\n    {\r\n        vt = VT_DISPATCH;\r\n        pdispVal = pdisp;\r\n        pdispVal->AddRef();\r\n    }\r\n\r\n    MVariant(const MVariant& var)\r\n    {\r\n        Copy(var);\r\n    }\r\n\r\n    MVariant& operator=(const MVariant& var);\r\n\r\n    void Copy(const MVariant& var);\r\n\r\n    bool empty() const\r\n    {\r\n        return vt == VT_EMPTY;\r\n    }\r\n\r\n    void clear()\r\n    {\r\n        VariantClear(this);\r\n    }\r\n\r\n    ~MVariant()\r\n    {\r\n        clear();\r\n    }\r\n\r\n    operator VARIANT *()\r\n    {\r\n        return this;\r\n    }\r\n\r\n    operator const VARIANT *() const\r\n    {\r\n        return this;\r\n    }\r\n\r\n    operator LONG() const\r\n    {\r\n        assert(vt == VT_I4);\r\n        return lVal;\r\n    }\r\n\r\n    operator LONG&()\r\n    {\r\n        assert(vt == VT_I4);\r\n        return lVal;\r\n    }\r\n\r\n    operator BSTR()\r\n    {\r\n        return bstrVal;\r\n    }\r\n\r\n    operator BSTR *()\r\n    {\r\n        VariantClear(this);\r\n        vt = VT_BSTR;\r\n        return &bstrVal;\r\n    }\r\n\r\n    operator BYTE *()\r\n    {\r\n        assert(vt == (VT_ARRAY | VT_UI1));\r\n        return reinterpret_cast<BYTE *>(parray->pvData);\r\n    }\r\n\r\n    operator const BYTE *() const\r\n    {\r\n        assert(vt == (VT_ARRAY | VT_UI1));\r\n        return reinterpret_cast<const BYTE *>(parray->pvData);\r\n    }\r\n\r\n    operator IUnknown *()\r\n    {\r\n        assert(vt == VT_UNKNOWN);\r\n        return punkVal;\r\n    }\r\n\r\n    operator IDispatch *()\r\n    {\r\n        assert(vt == VT_DISPATCH);\r\n        return pdispVal;\r\n    }\r\n\r\n    IUnknown *DetachUnknown();\r\n    IDispatch *DetachDispatch();\r\n\r\n    void InvokeDx(const WCHAR *pszName, UINT cArgs, VARIANT *pArray,\r\n                  WORD wFlags = DISPATCH_METHOD, VARIANT *pResult = NULL)\r\n    {\r\n        assert(vt == VT_DISPATCH);\r\n        ::InvokeDx(pdispVal, pszName, cArgs, pArray, wFlags, pResult);\r\n    }\r\n\r\n    template <typename T_OBJ>\r\n    HRESULT QueryInterfaceDx(REFIID riid, T_OBJ **ppvObj);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MDispException --- exception for InvokeDx function\r\n\r\nstruct MDispException\r\n{\r\n    HRESULT m_hr;\r\n    UINT m_uArgErr;\r\n\r\n    MDispException(HRESULT hr) : m_hr(hr)\r\n    {\r\n    }\r\n    MDispException(HRESULT hr, UINT uArgErr) : m_hr(hr), m_uArgErr(uArgErr)\r\n    {\r\n    }\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// MOleCtrl --- MZC4 OLE control class\r\n// NOTE: IMPLEMENT_DYNAMIC(MOleCtrl) is required in a *.cpp source file.\r\n\r\nclass MOleCtrl :\r\n    public MWindowBase, public IOleClientSite, public IOleInPlaceSite,\r\n    public IOleInPlaceFrame, public IOleControlSite, public IDispatch\r\n{\r\npublic:\r\n    DECLARE_DYNAMIC(MOleCtrl)\r\n\r\n    MOleCtrl();\r\n    virtual ~MOleCtrl();\r\n\r\n    static BOOL RegisterDx()\r\n    {\r\n        MOleCtrl oc;\r\n        return oc.RegisterClassDx();\r\n    }\r\n\r\n    virtual LPCTSTR GetWndClassNameDx() const\r\n    {\r\n        return TEXT("MOleCtrl");\r\n    }\r\n\r\n    virtual void ModifyWndClassDx(WNDCLASSEX& wcx)\r\n    {\r\n        wcx.hbrBackground = NULL;\r\n    }\r\n\r\n    IDispatch *GetDispatch();\r\n    IUnknown *GetUnknown();\r\n\r\n    VOID UIActivate();\r\n    VOID InPlaceActivate();\r\n    VOID Show(BOOL fVisible = TRUE);\r\n    BOOL TranslateAccelerator(LPMSG pMsg);\r\n    void DoVerb(LONG iVerb);\r\n\r\n    template <typename T_OBJ>\r\n    HRESULT QueryInterfaceDx(REFIID riid, T_OBJ **ppObj)\r\n    {\r\n        if (m_pUnknown == NULL)\r\n            return E_FAIL;\r\n        return m_pUnknown->QueryInterface(riid, reinterpret_cast<void **>(ppObj));\r\n    }\r\n\r\n    // Web Browser actions\r\n    IWebBrowser2 *GetWebBrowser2();\r\n    HRESULT Navigate(BSTR URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers);\r\n    HRESULT Navigate2(VARIANT *URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers);\r\n    HRESULT NavigateDx(const WCHAR *url);\r\n    HRESULT GoBack();\r\n    HRESULT GoForward();\r\n    HRESULT GoHome();\r\n    HRESULT Refresh();\r\n    HRESULT Stop();\r\n\r\n    // Web Browser properties\r\n    HRESULT get_Visible(VARIANT_BOOL *pBool);\r\n    HRESULT put_Visible(VARIANT_BOOL Value);\r\n    HRESULT get_FullScreen(VARIANT_BOOL *pbFullScreen);\r\n    HRESULT put_FullScreen(VARIANT_BOOL bFullScreen);\r\n    HRESULT get_LocationName(BSTR *LocationName);\r\n    HRESULT get_LocationURL(BSTR *LocationURL);\r\n\r\n    // IUnknown\r\n    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);\r\n    STDMETHODIMP_(ULONG) AddRef();\r\n    STDMETHODIMP_(ULONG) Release();\r\n\r\n    // IOleClientSite\r\n    STDMETHODIMP SaveObject();\r\n    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk);\r\n    STDMETHODIMP GetContainer(IOleContainer **ppContainer);\r\n    STDMETHODIMP ShowObject();\r\n    STDMETHODIMP OnShowWindow(BOOL fShow);\r\n    STDMETHODIMP RequestNewObjectLayout();\r\n\r\n    // IOleWindow Methods\r\n    STDMETHODIMP GetWindow(HWND *phwnd);\r\n    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);\r\n\r\n    // IOleInPlaceSite Methods\r\n    STDMETHODIMP CanInPlaceActivate();\r\n    STDMETHODIMP OnInPlaceActivate();\r\n    STDMETHODIMP OnUIActivate();\r\n    STDMETHODIMP GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPRECT prcPosRect, LPRECT prcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);\r\n    STDMETHODIMP Scroll(SIZE scrollExtent);\r\n    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);\r\n    STDMETHODIMP OnInPlaceDeactivate();\r\n    STDMETHODIMP DiscardUndoState();\r\n    STDMETHODIMP DeactivateAndUndo();\r\n    STDMETHODIMP OnPosRectChange(LPCRECT prcPosRect);\r\n\r\n    // IOleInPlaceUIWindow Methods\r\n    STDMETHODIMP GetBorder(LPRECT prcBorder);\r\n    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths);\r\n    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS lpborderwidths);\r\n    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR lpszObjName);\r\n\r\n    // IOleInPlaceFrame Methods\r\n    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);\r\n    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);\r\n    STDMETHODIMP RemoveMenus(HMENU hmenuShared);\r\n    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);\r\n    STDMETHODIMP EnableModeless(BOOL fEnable);\r\n    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);\r\n\r\n    // IOleControlSite Methods\r\n    STDMETHODIMP OnControlInfoChanged();\r\n    STDMETHODIMP LockInPlaceActive(BOOL fLock);\r\n    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp);\r\n    STDMETHODIMP TransformCoords(POINTL *pptlHimetric, POINTF* pptfContainer, DWORD dwFlags);\r\n    STDMETHODIMP TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers);\r\n    STDMETHODIMP OnFocus(BOOL fGotFocus);\r\n    STDMETHODIMP ShowPropertyFrame();\r\n\r\n    // IDispatch\r\n    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);\r\n    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);\r\n    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);\r\n    STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexecinfo, UINT *puArgErr);\r\n\r\n    virtual LRESULT CALLBACK\r\n    WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\r\n\r\nprotected:\r\n    LONG            m_cRefs;\r\n    HWND            m_hwndParent;\r\n    IUnknown *      m_pUnknown;\r\n    IWebBrowser2 *  m_pWebBrowser2;\r\n    RECT            m_rc;\r\n    CLSID           m_clsid;\r\n\r\n    BOOL CreateInstanceByString(OLECHAR *str);\r\n    BOOL CreateInstanceByProgID(OLECHAR *progid);\r\n    BOOL CreateInstanceByCLSID(const CLSID& clsid);\r\n    BOOL CreateInstanceByURL(OLECHAR *url);\r\n    VOID DestroyInstance();\r\n\r\n    BOOL OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);\r\n    void OnDestroy(HWND hwnd);\r\n    void OnShowWindow(HWND hwnd, BOOL fShow, UINT status);\r\n    void OnPaint(HWND hwnd);\r\npublic:\r\n    void OnSize(HWND hwnd, UINT state, int cx, int cy);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline void MZCAPI\r\nInvokeDx(IDispatch *disp, const WCHAR *pszName, UINT cArgs, VARIANT *pArray, \r\n         WORD wFlags/* = DISPATCH_METHOD*/, VARIANT *pResult/* = NULL*/)\r\n{\r\n    MStringW strName = pszName;\r\n    OLECHAR *pName = &strName[0];\r\n\r\n    DISPID dispid;\r\n    HRESULT hr;\r\n    hr = disp->GetIDsOfNames(IID_NULL, &pName, 1, LOCALE_USER_DEFAULT, &dispid);\r\n    if (FAILED(hr))\r\n        throw MDispException(hr);\r\n\r\n    DISPID     dispid_put = DISPID_PROPERTYPUT;\r\n    DISPPARAMS params;\r\n    params.cArgs = cArgs;\r\n    params.rgvarg = pArray;\r\n    if (wFlags & DISPATCH_PROPERTYPUT)\r\n    {\r\n        params.cNamedArgs = 1;\r\n        params.rgdispidNamedArgs = &dispid_put;\r\n    }\r\n    else\r\n    {\r\n        params.cNamedArgs = 0;\r\n        params.rgdispidNamedArgs = NULL;\r\n    }\r\n\r\n    UINT uArgErr;\r\n    hr = disp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, wFlags,\r\n                      &params, pResult, NULL, &uArgErr);\r\n    if (FAILED(hr))\r\n    {\r\n        if (hr == DISP_E_TYPEMISMATCH || hr == DISP_E_PARAMNOTFOUND)\r\n            throw MDispException(hr, uArgErr);\r\n        throw MDispException(hr);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\ninline MVariant::MVariant(const void *pv, UINT cb)\r\n{\r\n    SAFEARRAYBOUND bound = { cb, 0 };\r\n    vt = VT_ARRAY | VT_UI1;\r\n    parray = SafeArrayCreate(VT_UI1, cb, &bound);\r\n\r\n    void *data;\r\n    HRESULT hr = SafeArrayAccessData(parray, &data);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        CopyMemory(data, pv, cb);\r\n        SafeArrayUnaccessData(parray);\r\n    }\r\n}\r\n\r\ninline MVariant& MVariant::operator=(const MVariant& var)\r\n{\r\n    if (this != &var)\r\n    {\r\n        VariantClear(this);\r\n        Copy(var);\r\n    }\r\n    return *this;\r\n}\r\n\r\ninline void MVariant::Copy(const MVariant& var)\r\n{\r\n    vt = var.vt;\r\n    switch (vt)\r\n    {\r\n    case VT_BSTR:\r\n        bstrVal = ::SysAllocString(var.bstrVal);\r\n        break;\r\n    case VT_UNKNOWN:\r\n        punkVal = var.punkVal;\r\n        punkVal->AddRef();\r\n        break;\r\n    case VT_DISPATCH:\r\n        pdispVal = var.pdispVal;\r\n        pdispVal->AddRef();\r\n        break;\r\n    default:\r\n        if (var.vt & VT_ARRAY)\r\n        {\r\n            SAFEARRAY *psa = NULL;\r\n            SafeArrayCopy(parray, &psa);\r\n            parray = psa;\r\n        }\r\n        else\r\n        {\r\n            CopyMemory(this, &var, sizeof(var));\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\ntemplate <typename T_OBJ>\r\ninline HRESULT MVariant::QueryInterfaceDx(REFIID riid, T_OBJ **ppvObj)\r\n{\r\n    assert(vt == VT_UNKNOWN || vt == VT_DISPATCH);\r\n    if (vt == VT_UNKNOWN)\r\n    {\r\n        return punkVal->QueryInterface(riid, reinterpret_cast<void **>(ppvObj));\r\n    }\r\n    if (vt == VT_DISPATCH)\r\n    {\r\n        return pdispVal->QueryInterface(riid, reinterpret_cast<void **>(ppvObj));\r\n    }\r\n    return E_FAIL;\r\n}\r\n\r\ninline IUnknown *MVariant::DetachUnknown()\r\n{\r\n    assert(vt == VT_UNKNOWN);\r\n    IUnknown *ret = punkVal;\r\n    vt = VT_EMPTY;\r\n    punkVal = NULL;\r\n    return ret;\r\n}\r\n\r\ninline IDispatch *MVariant::DetachDispatch()\r\n{\r\n    assert(vt == VT_DISPATCH);\r\n    IDispatch *ret = pdispVal;\r\n    vt = VT_EMPTY;\r\n    pdispVal = NULL;\r\n    return ret;\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n// inlines\r\n\r\n\r\ninline MOleCtrl::MOleCtrl() : m_cRefs(1), m_hwndParent(NULL),\r\n    m_pUnknown(NULL), m_pWebBrowser2(NULL)\r\n{\r\n    ZeroMemory(&m_clsid, sizeof(m_clsid));\r\n}\r\n\r\ninline MOleCtrl::~MOleCtrl()\r\n{\r\n}\r\n\r\ninline BOOL MOleCtrl::CreateInstanceByString(OLECHAR *str)\r\n{\r\n    CLSID clsid;\r\n    ::CLSIDFromString(str, &clsid);\r\n    return CreateInstanceByCLSID(clsid);\r\n}\r\n\r\ninline BOOL MOleCtrl::CreateInstanceByProgID(OLECHAR *progid)\r\n{\r\n    CLSID clsid;\r\n    ::CLSIDFromProgID(progid, &clsid);\r\n    return CreateInstanceByCLSID(clsid);\r\n}\r\n\r\ninline BOOL MOleCtrl::CreateInstanceByCLSID(const CLSID& clsid)\r\n{\r\n    ::CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,\r\n                       IID_IUnknown, reinterpret_cast<void **>(&m_pUnknown));\r\n    if (!m_pUnknown)\r\n        return FALSE;\r\n\r\n    HRESULT hr;\r\n    if (IsEqualIID(clsid, IID_IWebBrowser2))\r\n    {\r\n        hr = QueryInterfaceDx(IID_IWebBrowser2, &m_pWebBrowser2);\r\n        if (FAILED(hr))\r\n        {\r\n            m_pUnknown->Release();\r\n            m_pUnknown = NULL;\r\n            return FALSE;\r\n        }\r\n    }\r\n\r\n    IOleObject *pioo;\r\n    hr = QueryInterfaceDx(IID_IOleObject, &pioo);\r\n    if (FAILED(hr))\r\n        return FALSE;\r\n\r\n    pioo->SetClientSite(this);\r\n    pioo->Release();\r\n\r\n    IPersistStreamInit *ppsi;\r\n    hr = QueryInterfaceDx(IID_IPersistStreamInit, &ppsi);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        m_clsid = clsid;\r\n        ppsi->InitNew();\r\n        ppsi->Release();\r\n        return TRUE;\r\n    }\r\n    return FALSE;\r\n}\r\n\r\ninline HRESULT MOleCtrl::get_Visible(VARIANT_BOOL *pBool)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->get_Visible(pBool);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::put_Visible(VARIANT_BOOL Value)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->put_Visible(Value);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::get_FullScreen(VARIANT_BOOL *pbFullScreen)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->get_FullScreen(pbFullScreen);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::put_FullScreen(VARIANT_BOOL bFullScreen)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->put_FullScreen(bFullScreen);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::GoBack()\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->GoBack();\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::GoForward()\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->GoForward();\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::GoHome()\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->GoHome();\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::Navigate(BSTR URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->Navigate(URL, Flags, TargetFrameName, PostData, Headers);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::NavigateDx(const WCHAR *url)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        if (url == NULL)\r\n            url = L"about:blank";\r\n\r\n        MVariant vURL(url), ve;\r\n        hr = pWebBrowser2->Navigate2(vURL, ve, ve, ve, ve);\r\n\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::Navigate2(VARIANT *URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers);\r\n\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::Refresh()\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->Refresh();\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::Stop()\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->Stop();\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::get_LocationName(BSTR *LocationName)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->get_LocationName(LocationName);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline HRESULT MOleCtrl::get_LocationURL(BSTR *LocationURL)\r\n{\r\n    HRESULT hr = E_FAIL;\r\n    if (IWebBrowser2 *pWebBrowser2 = GetWebBrowser2())\r\n    {\r\n        hr = pWebBrowser2->get_LocationURL(LocationURL);\r\n        pWebBrowser2->Release();\r\n    }\r\n    return hr;\r\n}\r\n\r\ninline BOOL MOleCtrl::CreateInstanceByURL(OLECHAR *url)\r\n{\r\n    if (!CreateInstanceByCLSID(CLSID_WebBrowser))\r\n        return FALSE;\r\n\r\n    HRESULT hr;\r\n    hr = QueryInterfaceDx(IID_IWebBrowser2, &m_pWebBrowser2);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        hr = NavigateDx(url);\r\n    }\r\n    return SUCCEEDED(hr);\r\n}\r\n\r\ninline VOID MOleCtrl::UIActivate()\r\n{\r\n    DoVerb(OLEIVERB_UIACTIVATE);\r\n}\r\n\r\ninline VOID MOleCtrl::InPlaceActivate()\r\n{\r\n    DoVerb(OLEIVERB_INPLACEACTIVATE);\r\n}\r\n\r\ninline VOID MOleCtrl::Show(BOOL fVisible)\r\n{\r\n    DoVerb(fVisible ? OLEIVERB_SHOW : OLEIVERB_HIDE);\r\n}\r\n\r\ninline void MOleCtrl::DoVerb(LONG iVerb)\r\n{\r\n    if (m_pUnknown == NULL)\r\n        return;\r\n\r\n    IOleObject *pioo;\r\n    HRESULT hr = QueryInterfaceDx(IID_IOleObject, &pioo);\r\n    if (FAILED(hr))\r\n        return;\r\n\r\n    pioo->DoVerb(iVerb, NULL, this, 0, m_hwnd, &m_rc);\r\n    pioo->Release();\r\n}\r\n\r\ninline VOID MOleCtrl::DestroyInstance()\r\n{\r\n    if (!m_pUnknown)\r\n        return;\r\n\r\n    if (m_pWebBrowser2)\r\n    {\r\n        m_pWebBrowser2->Stop();\r\n        m_pWebBrowser2->Release();\r\n        m_pWebBrowser2 = NULL;\r\n    }\r\n\r\n    IOleObject *pioo;\r\n    HRESULT hr = QueryInterfaceDx(IID_IOleObject, &pioo);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        pioo->Close(OLECLOSE_NOSAVE);\r\n        pioo->SetClientSite(NULL);\r\n        pioo->Release();\r\n    }\r\n\r\n    IOleInPlaceObject *pipo;\r\n    hr = QueryInterfaceDx(IID_IOleInPlaceObject, &pipo);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        pipo->UIDeactivate();\r\n        pipo->InPlaceDeactivate();\r\n        pipo->Release();\r\n    }\r\n\r\n    m_pUnknown->Release();\r\n    m_pUnknown = NULL;\r\n}\r\n\r\ninline BOOL MOleCtrl::TranslateAccelerator(LPMSG pMsg)\r\n{\r\n    if (!m_pUnknown)\r\n        return FALSE;\r\n\r\n    IOleInPlaceActiveObject *pao;\r\n    HRESULT hr = QueryInterfaceDx(IID_IOleInPlaceActiveObject, &pao);\r\n    if (SUCCEEDED(hr))\r\n    {\r\n        hr = pao->TranslateAccelerator(pMsg);\r\n        pao->Release();\r\n    }\r\n    return FAILED(hr);\r\n}\r\n\r\ninline IDispatch *MOleCtrl::GetDispatch()\r\n{\r\n    if (!m_pUnknown)\r\n        return NULL;\r\n\r\n    IDispatch *pDispatch;\r\n    HRESULT hr = QueryInterfaceDx(IID_IDispatch, &pDispatch);\r\n    if (SUCCEEDED(hr))\r\n        return pDispatch;\r\n    return NULL;\r\n}\r\n\r\ninline IUnknown *MOleCtrl::GetUnknown()\r\n{\r\n    if (!m_pUnknown)\r\n        return NULL;\r\n\r\n    m_pUnknown->AddRef();\r\n    return m_pUnknown;\r\n}\r\n\r\ninline IWebBrowser2 *MOleCtrl::GetWebBrowser2()\r\n{\r\n    if (!m_pWebBrowser2)\r\n        return NULL;\r\n\r\n    m_pWebBrowser2->AddRef();\r\n    return m_pWebBrowser2;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::QueryInterface(REFIID riid, void **ppvObject)\r\n{\r\n    if (!ppvObject)\r\n        return E_POINTER;\r\n\r\n    *ppvObject = NULL;\r\n\r\n    if (IsEqualIID(riid, IID_IOleClientSite))\r\n        *ppvObject = dynamic_cast<IOleClientSite*>(this);\r\n    else if (IsEqualIID(riid, IID_IOleInPlaceSite))\r\n        *ppvObject = dynamic_cast<IOleInPlaceSite*>(this);\r\n    else if (IsEqualIID(riid, IID_IOleInPlaceFrame))\r\n        *ppvObject = dynamic_cast<IOleInPlaceFrame*>(this);\r\n    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))\r\n        *ppvObject = dynamic_cast<IOleInPlaceUIWindow*>(this);\r\n    else if (IsEqualIID(riid, IID_IOleControlSite))\r\n        *ppvObject = dynamic_cast<IOleControlSite*>(this);\r\n    else if (IsEqualIID(riid, IID_IOleWindow))\r\n        *ppvObject = this;\r\n    else if (IsEqualIID(riid, IID_IDispatch))\r\n        *ppvObject = dynamic_cast<IDispatch*>(this);\r\n    else if (IsEqualIID(riid, IID_IUnknown))\r\n        *ppvObject = this;\r\n\r\n    if (*ppvObject)\r\n    {\r\n        AddRef();\r\n        return S_OK;\r\n    }\r\n\r\n    return E_NOINTERFACE;\r\n}\r\n\r\ninline STDMETHODIMP_(ULONG) MOleCtrl::AddRef()\r\n{\r\n    return InterlockedIncrement(&m_cRefs);\r\n}\r\n\r\ninline STDMETHODIMP_(ULONG) MOleCtrl::Release()\r\n{\r\n    if (InterlockedDecrement(&m_cRefs) == 0)\r\n    {\r\n        delete this;\r\n        return 0;\r\n    }\r\n    return m_cRefs;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::SaveObject()\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetContainer(IOleContainer **ppContainer)\r\n{\r\n    return QueryInterface(IID_IOleContainer,\r\n                          reinterpret_cast<void **>(ppContainer));\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::ShowObject()\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnShowWindow(BOOL fShow)\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::RequestNewObjectLayout()\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetWindow(HWND *phwnd)\r\n{\r\n    *phwnd = m_hwnd;\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::ContextSensitiveHelp(BOOL fEnterMode)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::CanInPlaceActivate()\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnInPlaceActivate()\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnUIActivate()\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppIIPUIWin, LPRECT prcPosRect, LPRECT prcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)\r\n{\r\n    *ppIIPUIWin = NULL;\r\n\r\n    if (prcClipRect)\r\n        *prcClipRect = m_rc;\r\n    if (prcPosRect)\r\n        *prcPosRect = m_rc;\r\n\r\n    if (ppFrame)\r\n    {\r\n        QueryInterface(IID_IOleInPlaceFrame,\r\n                       reinterpret_cast<void **>(ppFrame));\r\n    }\r\n\r\n    if (ppIIPUIWin)\r\n        *ppIIPUIWin = NULL;\r\n\r\n    if (lpFrameInfo)\r\n    {\r\n        lpFrameInfo->fMDIApp        = FALSE;\r\n        lpFrameInfo->hwndFrame      = m_hwnd;\r\n        lpFrameInfo->haccel         = NULL;\r\n        lpFrameInfo->cAccelEntries  = 0;\r\n    }\r\n\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::Scroll(SIZE scrollExtent)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnUIDeactivate(BOOL fUndoable)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnInPlaceDeactivate()\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::DiscardUndoState()\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::DeactivateAndUndo()\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnPosRectChange(LPCRECT prcPosRect)\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetBorder(LPRECT prcBorder)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR lpszObjName)\r\n{\r\n    return S_OK;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::RemoveMenus(HMENU hmenuShared)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::SetStatusText(LPCOLESTR pszStatusText)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::EnableModeless(BOOL fEnable)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::TranslateAccelerator(LPMSG pMsg, WORD wID)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnControlInfoChanged(void)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::LockInPlaceActive(BOOL fLock)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetExtendedControl(IDispatch **ppDisp)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer, DWORD dwFlags)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::OnFocus(BOOL fGotFocus)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::ShowPropertyFrame()\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetTypeInfoCount(UINT *pctinfo)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)\r\n{\r\n    return E_NOTIMPL;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)\r\n{\r\n    *rgdispid = DISPID_UNKNOWN;\r\n    return DISP_E_UNKNOWNNAME;\r\n}\r\n\r\ninline STDMETHODIMP MOleCtrl::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexecinfo, UINT *puArgErr)\r\n{\r\n    return DISP_E_MEMBERNOTFOUND;\r\n}\r\n\r\ninline LRESULT CALLBACK MOleCtrl::WindowProcDx(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n    switch (uMsg)\r\n    {\r\n    HANDLE_MSG(hwnd, WM_CREATE, OnCreate);\r\n    HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);\r\n    HANDLE_MSG(hwnd, WM_SIZE, OnSize);\r\n    HANDLE_MSG(hwnd, WM_SHOWWINDOW, OnShowWindow);\r\n    default:\r\n        return DefaultProcDx();\r\n    }\r\n}\r\n\r\ninline BOOL MOleCtrl::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)\r\n{\r\n    m_hwndParent = GetParent(m_hwnd);\r\n\r\n    WCHAR szText[512];\r\n    GetWindowTextW(m_hwnd, szText, _countof(szText));\r\n\r\n    if (szText[0] == TEXT('{'))\r\n    {\r\n        if (!CreateInstanceByString(szText))\r\n            return FALSE;\r\n    }\r\n    else if (memcmp(szText, L"http://", 7 * sizeof(WCHAR)) == 0 ||\r\n             memcmp(szText, L"https://", 8 * sizeof(WCHAR)) == 0 ||\r\n             memcmp(szText, L"ftp://", 6 * sizeof(WCHAR)) == 0 ||\r\n             memcmp(szText, L"www.", 4 * sizeof(WCHAR)) == 0)\r\n    {\r\n        if (!CreateInstanceByURL(szText))\r\n            return FALSE;\r\n    }\r\n    else\r\n    {\r\n        if (!CreateInstanceByProgID(szText))\r\n            return FALSE;\r\n    }\r\n\r\n    OnSize(hwnd, SIZE_RESTORED, 0, 0);\r\n    InPlaceActivate();\r\n\r\n    return TRUE;\r\n}\r\n\r\ninline void MOleCtrl::OnDestroy(HWND hwnd)\r\n{\r\n    DestroyInstance();\r\n}\r\n\r\ninline void MOleCtrl::OnSize(HWND hwnd, UINT state, int cx, int cy)\r\n{\r\n    RECT rc;\r\n    ::GetClientRect(hwnd, &rc);\r\n    m_rc = rc;\r\n\r\n    if (!m_pUnknown)\r\n        return;\r\n\r\n    IOleInPlaceObject *pipo;\r\n    HRESULT hr = QueryInterfaceDx(IID_IOleInPlaceObject, &pipo);\r\n    if (FAILED(hr))\r\n        return;\r\n\r\n    pipo->SetObjectRects(&m_rc, &m_rc);\r\n    pipo->Release();\r\n}\r\n\r\ninline void MOleCtrl::OnShowWindow(HWND hwnd, BOOL fShow, UINT status)\r\n{\r\n}\r\n\r\ninline void MOleCtrl::OnPaint(HWND hwnd)\r\n{\r\n    if (!m_pUnknown)\r\n        return;\r\n\r\n    PAINTSTRUCT ps;\r\n    HRESULT hr;\r\n    if (HDC hDC = BeginPaint(m_hwnd, &ps))\r\n    {\r\n        IOleObject *pioo;\r\n        hr = QueryInterfaceDx(IID_IOleObject, &pioo);\r\n        if (SUCCEEDED(hr))\r\n        {\r\n            IViewObject *pView;\r\n            hr = pioo->QueryInterface(IID_IViewObject,\r\n                                      reinterpret_cast<void **>(&pView));\r\n            if (SUCCEEDED(hr))\r\n            {\r\n                RECTL rect;\r\n                rect.left = m_rc.left;\r\n                rect.top = m_rc.top;\r\n                rect.right = m_rc.right;\r\n                rect.bottom = m_rc.bottom;\r\n\r\n                pView->Draw(DVASPECT_CONTENT, ~0, NULL, NULL, 0,\r\n                            hDC, &rect, &rect, NULL, 0);\r\n                pView->Release();\r\n            }\r\n            pioo->Release();\r\n        }\r\n        EndPaint(m_hwnd, &ps);\r\n    }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n\r\n#endif  // ndef MZC4_MOLECTRL_HPP_\r\n
DllMain<>DllMain<>BOOL WINAPI\r\nDllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\r\n{\r\n    switch (fdwReason)\r\n    {\r\n    case DLL_PROCESS_ATTACH:\r\n        break;\r\n    case DLL_PROCESS_DETACH:\r\n        break;\r\n    }\r\n    return TRUE;\r\n}\r\n
